/* eslint-disable */
!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? e(exports) : typeof define === 'function' && define.amd ? define(['exports'], e) : e(t.echarts = {}) }(this, function (t) {
  'use strict'; function e (t, e) { function n () { this.constructor = t } if (typeof e !== 'function' && e !== null) throw new TypeError('Class extends value ' + String(e) + ' is not a constructor or null'); XS(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n()) } function n (t, e) { const n = e.browser; const i = t.match(/Firefox\/([\d.]+)/); const r = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/); const o = t.match(/Edge?\/([\d.]+)/); const a = /micromessenger/i.test(t); i && (n.firefox = !0, n.version = i[1]), r && (n.ie = !0, n.version = r[1]), o && (n.edge = !0, n.version = o[1], n.newEdge = +o[1].split('.')[0] > 18), a && (n.weChat = !0), e.svgSupported = typeof SVGRect !== 'undefined', e.touchEventsSupported = 'ontouchstart' in window && !n.ie && !n.edge, e.pointerEventsSupported = 'onpointerdown' in window && (n.edge || n.ie && +n.version >= 11), e.domSupported = typeof document !== 'undefined'; const s = document.documentElement.style; e.transform3dSupported = (n.ie && 'transition' in s || n.edge || 'WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix() || 'MozPerspective' in s) && !('OTransition' in s), e.transformSupported = e.transform3dSupported || n.ie && +n.version >= 9 } function i (t) { const e = {}; if (typeof JSON === 'undefined') return e; for (let n = 0; n < t.length; n++) { const i = String.fromCharCode(n + 32); const r = (t.charCodeAt(n) - $S) / QS; e[i] = r } return e } function r (t) { for (const e in eM)t[e] && (eM[e] = t[e]) } function o () { return dM++ } function a () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; typeof console !== 'undefined' && console.error.apply(console, t) } function s (t) { if (t == null || typeof t !== 'object') return t; let e = t; const n = rM.call(t); if (n === '[object Array]') { if (!Y(t)) { e = []; for (var i = 0, r = t.length; r > i; i++)e[i] = s(t[i]) } } else if (iM[n]) { if (!Y(t)) { const o = t.constructor; if (o.from)e = o.from(t); else { e = new o(t.length); for (var i = 0, r = t.length; r > i; i++)e[i] = t[i] } } } else if (!nM[n] && !Y(t) && !P(t)) { e = {}; for (const a in t)t.hasOwnProperty(a) && a !== pM && (e[a] = s(t[a])) } return e } function l (t, e, n) { if (!k(e) || !k(t)) return n ? s(e) : t; for (const i in e) if (e.hasOwnProperty(i) && i !== pM) { const r = t[i]; const o = e[i]; !k(o) || !k(r) || M(o) || M(r) || P(o) || P(r) || A(o) || A(r) || Y(o) || Y(r) ? !n && i in t || (t[i] = s(e[i])) : l(r, o, n) } return t } function u (t, e) { for (var n = t[0], i = 1, r = t.length; r > i; i++)n = l(n, t[i], e); return n } function h (t, e) { if (Object.assign)Object.assign(t, e); else for (const n in e)e.hasOwnProperty(n) && n !== pM && (t[n] = e[n]); return t } function c (t, e, n) { for (let i = w(e), r = 0; r < i.length; r++) { const o = i[r]; (n ? e[o] != null : t[o] == null) && (t[o] = e[o]) } return t } function p (t, e) { if (t) { if (t.indexOf) return t.indexOf(e); for (let n = 0, i = t.length; i > n; n++) if (t[n] === e) return n } return -1 } function d (t, e) { function n () {} const i = t.prototype; n.prototype = e.prototype, t.prototype = new n(); for (const r in i)i.hasOwnProperty(r) && (t.prototype[r] = i[r]); t.prototype.constructor = t, t.superClass = e } function f (t, e, n) { if (t = 'prototype' in t ? t.prototype : t, e = 'prototype' in e ? e.prototype : e, Object.getOwnPropertyNames) for (let i = Object.getOwnPropertyNames(e), r = 0; r < i.length; r++) { const o = i[r]; o !== 'constructor' && (n ? e[o] != null : t[o] == null) && (t[o] = e[o]) } else c(t, e, n) } function g (t) { return t ? typeof t === 'string' ? !1 : typeof t.length === 'number' : !1 } function y (t, e, n) { if (t && e) if (t.forEach && t.forEach === aM)t.forEach(e, n); else if (t.length === +t.length) for (let i = 0, r = t.length; r > i; i++)e.call(n, t[i], i, t); else for (const o in t)t.hasOwnProperty(o) && e.call(n, t[o], o, t) } function v (t, e, n) { if (!t) return []; if (!e) return F(t); if (t.map && t.map === uM) return t.map(e, n); for (var i = [], r = 0, o = t.length; o > r; r++)i.push(e.call(n, t[r], r, t)); return i } function m (t, e, n, i) { if (t && e) { for (let r = 0, o = t.length; o > r; r++)n = e.call(i, n, t[r], r, t); return n } } function _ (t, e, n) { if (!t) return []; if (!e) return F(t); if (t.filter && t.filter === sM) return t.filter(e, n); for (var i = [], r = 0, o = t.length; o > r; r++)e.call(n, t[r], r, t) && i.push(t[r]); return i } function x (t, e, n) { if (t && e) for (let i = 0, r = t.length; r > i; i++) if (e.call(n, t[i], i, t)) return t[i] } function w (t) { if (!t) return []; if (Object.keys) return Object.keys(t); const e = []; for (const n in t)t.hasOwnProperty(n) && e.push(n); return e } function b (t, e) { for (var n = [], i = 2; i < arguments.length; i++)n[i - 2] = arguments[i]; return function () { return t.apply(e, n.concat(lM.call(arguments))) } } function S (t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; return function () { return t.apply(this, e.concat(lM.call(arguments))) } } function M (t) { return Array.isArray ? Array.isArray(t) : rM.call(t) === '[object Array]' } function T (t) { return typeof t === 'function' } function I (t) { return typeof t === 'string' } function C (t) { return rM.call(t) === '[object String]' } function D (t) { return typeof t === 'number' } function k (t) { const e = typeof t; return e === 'function' || !!t && e === 'object' } function A (t) { return !!nM[rM.call(t)] } function L (t) { return !!iM[rM.call(t)] } function P (t) { return typeof t === 'object' && typeof t.nodeType === 'number' && typeof t.ownerDocument === 'object' } function O (t) { return t.colorStops != null } function R (t) { return t.image != null } function N (t) { return rM.call(t) === '[object RegExp]' } function z (t) { return t !== t } function B () { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; for (let n = 0, i = t.length; i > n; n++) if (t[n] != null) return t[n] } function E (t, e) { return t != null ? t : e } function V (t, e, n) { return t != null ? t : e != null ? e : n } function F (t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; return lM.apply(t, e) } function H (t) { if (typeof t === 'number') return [t, t, t, t]; const e = t.length; return e === 2 ? [t[0], t[1], t[0], t[1]] : e === 3 ? [t[0], t[1], t[2], t[1]] : t } function W (t, e) { if (!t) throw new Error(e) } function G (t) { return t == null ? null : typeof t.trim === 'function' ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '') } function X (t) { t[yM] = !0 } function Y (t) { return t[yM] } function U () { return mM ? new Map() : new vM() } function Z (t) { return new _M(t) } function j (t, e) { for (var n = new t.constructor(t.length + e.length), i = 0; i < t.length; i++)n[i] = t[i]; for (var r = t.length, i = 0; i < e.length; i++)n[i + r] = e[i]; return n } function q (t, e) { let n; if (Object.create)n = Object.create(t); else { const i = function () {}; i.prototype = t, n = new i() } return e && h(n, e), n } function K (t) { const e = t.style; e.webkitUserSelect = 'none', e.userSelect = 'none', e.webkitTapHighlightColor = 'rgba(0,0,0,0)', e['-webkit-touch-callout'] = 'none' } function $ (t, e) { return t.hasOwnProperty(e) } function Q () {} function J (t, e) { return t == null && (t = 0), e == null && (e = 0), [t, e] } function te (t, e) { return t[0] = e[0], t[1] = e[1], t } function ee (t) { return [t[0], t[1]] } function ne (t, e, n) { return t[0] = e, t[1] = n, t } function ie (t, e, n) { return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t } function re (t, e, n, i) { return t[0] = e[0] + n[0] * i, t[1] = e[1] + n[1] * i, t } function oe (t, e, n) { return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t } function ae (t) { return Math.sqrt(se(t)) } function se (t) { return t[0] * t[0] + t[1] * t[1] } function le (t, e, n) { return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t } function ue (t, e, n) { return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t } function he (t, e) { return t[0] * e[0] + t[1] * e[1] } function ce (t, e, n) { return t[0] = e[0] * n, t[1] = e[1] * n, t } function pe (t, e) { const n = ae(e); return n === 0 ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / n, t[1] = e[1] / n), t } function de (t, e) { return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])) } function fe (t, e) { return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]) } function ge (t, e) { return t[0] = -e[0], t[1] = -e[1], t } function ye (t, e, n, i) { return t[0] = e[0] + i * (n[0] - e[0]), t[1] = e[1] + i * (n[1] - e[1]), t } function ve (t, e, n) { const i = e[0]; const r = e[1]; return t[0] = n[0] * i + n[2] * r + n[4], t[1] = n[1] * i + n[3] * r + n[5], t } function me (t, e, n) { return t[0] = Math.min(e[0], n[0]), t[1] = Math.min(e[1], n[1]), t } function _e (t, e, n) { return t[0] = Math.max(e[0], n[0]), t[1] = Math.max(e[1], n[1]), t } function xe (t, e, n, i, r, o) { const a = i + '-' + r; const s = t.length; if (o.hasOwnProperty(a)) return o[a]; if (e === 1) { const l = Math.round(Math.log((1 << s) - 1 & ~r) / AM); return t[n][l] } for (var u = i | 1 << n, h = n + 1; i & 1 << h;)h++; for (var c = 0, p = 0, d = 0; s > p; p++) { const f = 1 << p; f & r || (c += (d % 2 ? -1 : 1) * t[n][p] * xe(t, e - 1, h, u, r | f, o), d++) } return o[a] = c, c } function we (t, e) { const n = [[t[0], t[1], 1, 0, 0, 0, -e[0] * t[0], -e[0] * t[1]], [0, 0, 0, t[0], t[1], 1, -e[1] * t[0], -e[1] * t[1]], [t[2], t[3], 1, 0, 0, 0, -e[2] * t[2], -e[2] * t[3]], [0, 0, 0, t[2], t[3], 1, -e[3] * t[2], -e[3] * t[3]], [t[4], t[5], 1, 0, 0, 0, -e[4] * t[4], -e[4] * t[5]], [0, 0, 0, t[4], t[5], 1, -e[5] * t[4], -e[5] * t[5]], [t[6], t[7], 1, 0, 0, 0, -e[6] * t[6], -e[6] * t[7]], [0, 0, 0, t[6], t[7], 1, -e[7] * t[6], -e[7] * t[7]]]; const i = {}; const r = xe(n, 8, 0, 0, 0, i); if (r !== 0) { for (var o = [], a = 0; a < 8; a++) for (let s = 0; s < 8; s++)o[s] == null && (o[s] = 0), o[s] += ((a + s) % 2 ? -1 : 1) * xe(n, 7, a === 0 ? 1 : 0, 1 << a, 1 << s, i) / r * e[a]; return function (t, e, n) { const i = e * o[6] + n * o[7] + 1; t[0] = (e * o[0] + n * o[1] + o[2]) / i, t[1] = (e * o[3] + n * o[4] + o[5]) / i } } } function be (t, e, n, i, r) { return Se(PM, e, i, r, !0) && Se(t, n, PM[0], PM[1]) } function Se (t, e, n, i, r) { if (e.getBoundingClientRect && ZS.domSupported && !Ie(e)) { const o = e[LM] || (e[LM] = {}); const a = Me(e, o); const s = Te(a, o, r); if (s) return s(t, n, i), !0 } return !1 } function Me (t, e) { let n = e.markers; if (n) return n; n = e.markers = []; for (let i = ['left', 'right'], r = ['top', 'bottom'], o = 0; o < 4; o++) { const a = document.createElement('div'); const s = a.style; const l = o % 2; const u = (o >> 1) % 2; s.cssText = ['position: absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'user-select: none', 'width:0', 'height:0', i[l] + ':0', r[u] + ':0', i[1 - l] + ':auto', r[1 - u] + ':auto', ''].join('!important;'), t.appendChild(a), n.push(a) } return n } function Te (t, e, n) { for (var i = n ? 'invTrans' : 'trans', r = e[i], o = e.srcCoords, a = [], s = [], l = !0, u = 0; u < 4; u++) { const h = t[u].getBoundingClientRect(); const c = 2 * u; const p = h.left; const d = h.top; a.push(p, d), l = l && o && p === o[c] && d === o[c + 1], s.push(t[u].offsetLeft, t[u].offsetTop) } return l && r ? r : (e.srcCoords = a, e[i] = n ? we(s, a) : we(a, s)) } function Ie (t) { return t.nodeName.toUpperCase() === 'CANVAS' } function Ce (t) { return t == null ? '' : (t + '').replace(OM, function (t, e) { return RM[e] }) } function De (t, e, n, i) { return n = n || {}, i ? ke(t, e, n) : BM && e.layerX != null && e.layerX !== e.offsetX ? (n.zrX = e.layerX, n.zrY = e.layerY) : e.offsetX != null ? (n.zrX = e.offsetX, n.zrY = e.offsetY) : ke(t, e, n), n } function ke (t, e, n) { if (ZS.domSupported && t.getBoundingClientRect) { const i = e.clientX; const r = e.clientY; if (Ie(t)) { const o = t.getBoundingClientRect(); return n.zrX = i - o.left, void (n.zrY = r - o.top) } if (Se(zM, t, i, r)) return n.zrX = zM[0], void (n.zrY = zM[1]) }n.zrX = n.zrY = 0 } function Ae (t) { return t || window.event } function Le (t, e, n) { if (e = Ae(e), e.zrX != null) return e; const i = e.type; const r = i && i.indexOf('touch') >= 0; if (r) { const o = i !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0]; o && De(t, o, e, n) } else { De(t, e, e, n); const a = Pe(e); e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3 } const s = e.button; return e.which == null && void 0 !== s && NM.test(e.type) && (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0), e } function Pe (t) { const e = t.wheelDelta; if (e) return e; const n = t.deltaX; const i = t.deltaY; if (n == null || i == null) return e; const r = Math.abs(i !== 0 ? i : n); const o = i > 0 ? -1 : i < 0 ? 1 : n > 0 ? -1 : 1; return 3 * r * o } function Oe (t, e, n, i) { t.addEventListener(e, n, i) } function Re (t, e, n, i) { t.removeEventListener(e, n, i) } function Ne (t) { return t.which === 2 || t.which === 3 } function ze (t) { const e = t[1][0] - t[0][0]; const n = t[1][1] - t[0][1]; return Math.sqrt(e * e + n * n) } function Be (t) { return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2] } function Ee () { return [1, 0, 0, 1, 0, 0] } function Ve (t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t } function Fe (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t } function He (t, e, n) { const i = e[0] * n[0] + e[2] * n[1]; const r = e[1] * n[0] + e[3] * n[1]; const o = e[0] * n[2] + e[2] * n[3]; const a = e[1] * n[2] + e[3] * n[3]; const s = e[0] * n[4] + e[2] * n[5] + e[4]; const l = e[1] * n[4] + e[3] * n[5] + e[5]; return t[0] = i, t[1] = r, t[2] = o, t[3] = a, t[4] = s, t[5] = l, t } function We (t, e, n) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + n[0], t[5] = e[5] + n[1], t } function Ge (t, e, n) { const i = e[0]; const r = e[2]; const o = e[4]; const a = e[1]; const s = e[3]; const l = e[5]; const u = Math.sin(n); const h = Math.cos(n); return t[0] = i * h + a * u, t[1] = -i * u + a * h, t[2] = r * h + s * u, t[3] = -r * u + h * s, t[4] = h * o + u * l, t[5] = h * l - u * o, t } function Xe (t, e, n) { const i = n[0]; const r = n[1]; return t[0] = e[0] * i, t[1] = e[1] * r, t[2] = e[2] * i, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * r, t } function Ye (t, e) { const n = e[0]; const i = e[2]; const r = e[4]; const o = e[1]; const a = e[3]; const s = e[5]; let l = n * a - o * i; return l ? (l = 1 / l, t[0] = a * l, t[1] = -o * l, t[2] = -i * l, t[3] = n * l, t[4] = (i * s - a * r) * l, t[5] = (o * r - n * s) * l, t) : null } function Ue (t) { const e = Ee(); return Fe(e, t), e } function Ze (t, e, n) { return { type: t, event: n, target: e.target, topTarget: e.topTarget, cancelBubble: !1, offsetX: n.zrX, offsetY: n.zrY, gestureEvent: n.gestureEvent, pinchX: n.pinchX, pinchY: n.pinchY, pinchScale: n.pinchScale, wheelDelta: n.zrDelta, zrByTouch: n.zrByTouch, which: n.which, stop: je } } function je () { EM(this.event) } function qe (t, e, n) { if (t[t.rectHover ? 'rectContain' : 'contain'](e, n)) { for (var i = t, r = void 0, o = !1; i;) { if (i.ignoreClip && (o = !0), !o) { const a = i.getClipPath(); if (a && !a.contain(e, n)) return !1; i.silent && (r = !0) } const s = i.__hostTarget; i = s || i.parent } return r ? QM : !0 } return !1 } function Ke (t, e, n, i, r) { for (let o = t.length - 1; o >= 0; o--) { const a = t[o]; let s = void 0; if (a !== r && !a.ignore && (s = qe(a, n, i)) && (!e.topTarget && (e.topTarget = a), s !== QM)) { e.target = a; break } } } function $e (t, e, n) { const i = t.painter; return e < 0 || e > i.getWidth() || n < 0 || n > i.getHeight() } function Qe (t) { for (var e = 0; t >= oT;)e |= 1 & t, t >>= 1; return t + e } function Je (t, e, n, i) { let r = e + 1; if (r === n) return 1; if (i(t[r++], t[e]) < 0) { for (;n > r && i(t[r], t[r - 1]) < 0;)r++; tn(t, e, r) } else for (;n > r && i(t[r], t[r - 1]) >= 0;)r++; return r - e } function tn (t, e, n) { for (n--; n > e;) { const i = t[e]; t[e++] = t[n], t[n--] = i } } function en (t, e, n, i, r) { for (i === e && i++; n > i; i++) { for (var o, a = t[i], s = e, l = i; l > s;)o = s + l >>> 1, r(a, t[o]) < 0 ? l = o : s = o + 1; let u = i - s; switch (u) { case 3:t[s + 3] = t[s + 2]; case 2:t[s + 2] = t[s + 1]; case 1:t[s + 1] = t[s]; break; default:for (;u > 0;)t[s + u] = t[s + u - 1], u-- }t[s] = a } } function nn (t, e, n, i, r, o) { let a = 0; let s = 0; let l = 1; if (o(t, e[n + r]) > 0) { for (s = i - r; s > l && o(t, e[n + r + l]) > 0;)a = l, l = (l << 1) + 1, l <= 0 && (l = s); l > s && (l = s), a += r, l += r } else { for (s = r + 1; s > l && o(t, e[n + r - l]) <= 0;)a = l, l = (l << 1) + 1, l <= 0 && (l = s); l > s && (l = s); const u = a; a = r - l, l = r - u } for (a++; l > a;) { const h = a + (l - a >>> 1); o(t, e[n + h]) > 0 ? a = h + 1 : l = h } return l } function rn (t, e, n, i, r, o) { let a = 0; let s = 0; let l = 1; if (o(t, e[n + r]) < 0) { for (s = r + 1; s > l && o(t, e[n + r - l]) < 0;)a = l, l = (l << 1) + 1, l <= 0 && (l = s); l > s && (l = s); const u = a; a = r - l, l = r - u } else { for (s = i - r; s > l && o(t, e[n + r + l]) >= 0;)a = l, l = (l << 1) + 1, l <= 0 && (l = s); l > s && (l = s), a += r, l += r } for (a++; l > a;) { const h = a + (l - a >>> 1); o(t, e[n + h]) < 0 ? l = h : a = h + 1 } return l } function on (t, e) { function n (t, e) { l[c] = t, u[c] = e, c += 1 } function i () { for (;c > 1;) { let t = c - 2; if (t >= 1 && u[t - 1] <= u[t] + u[t + 1] || t >= 2 && u[t - 2] <= u[t] + u[t - 1])u[t - 1] < u[t + 1] && t--; else if (u[t] > u[t + 1]) break; o(t) } } function r () { for (;c > 1;) { let t = c - 2; t > 0 && u[t - 1] < u[t + 1] && t--, o(t) } } function o (n) { let i = l[n]; let r = u[n]; const o = l[n + 1]; let h = u[n + 1]; u[n] = r + h, n === c - 3 && (l[n + 1] = l[n + 2], u[n + 1] = u[n + 2]), c--; const p = rn(t[o], t, i, r, 0, e); i += p, r -= p, r !== 0 && (h = nn(t[i + r - 1], t, o, h, h - 1, e), h !== 0 && (h >= r ? a(i, r, o, h) : s(i, r, o, h))) } function a (n, i, r, o) { let a = 0; for (a = 0; i > a; a++)p[a] = t[n + a]; let s = 0; let l = r; let u = n; if (t[u++] = t[l++], --o !== 0) { if (i === 1) { for (a = 0; o > a; a++)t[u + a] = t[l + a]; return void (t[u + o] = p[s]) } for (var c, d, f, g = h; ;) { c = 0, d = 0, f = !1; do if (e(t[l], p[s]) < 0) { if (t[u++] = t[l++], d++, c = 0, --o === 0) { f = !0; break } } else if (t[u++] = p[s++], c++, d = 0, --i === 1) { f = !0; break } while (g > (c | d)); if (f) break; do { if (c = rn(t[l], p, s, i, 0, e), c !== 0) { for (a = 0; c > a; a++)t[u + a] = p[s + a]; if (u += c, s += c, i -= c, i <= 1) { f = !0; break } } if (t[u++] = t[l++], --o === 0) { f = !0; break } if (d = nn(p[s], t, l, o, 0, e), d !== 0) { for (a = 0; d > a; a++)t[u + a] = t[l + a]; if (u += d, l += d, o -= d, o === 0) { f = !0; break } } if (t[u++] = p[s++], --i === 1) { f = !0; break }g-- } while (c >= aT || d >= aT); if (f) break; g < 0 && (g = 0), g += 2 } if (h = g, h < 1 && (h = 1), i === 1) { for (a = 0; o > a; a++)t[u + a] = t[l + a]; t[u + o] = p[s] } else { if (i === 0) throw new Error(); for (a = 0; i > a; a++)t[u + a] = p[s + a] } } else for (a = 0; i > a; a++)t[u + a] = p[s + a] } function s (n, i, r, o) { let a = 0; for (a = 0; o > a; a++)p[a] = t[r + a]; let s = n + i - 1; let l = o - 1; let u = r + o - 1; let c = 0; let d = 0; if (t[u--] = t[s--], --i !== 0) { if (o === 1) { for (u -= i, s -= i, d = u + 1, c = s + 1, a = i - 1; a >= 0; a--)t[d + a] = t[c + a]; return void (t[u] = p[l]) } for (var f = h; ;) { let g = 0; let y = 0; let v = !1; do if (e(p[l], t[s]) < 0) { if (t[u--] = t[s--], g++, y = 0, --i === 0) { v = !0; break } } else if (t[u--] = p[l--], y++, g = 0, --o === 1) { v = !0; break } while (f > (g | y)); if (v) break; do { if (g = i - rn(p[l], t, n, i, i - 1, e), g !== 0) { for (u -= g, s -= g, i -= g, d = u + 1, c = s + 1, a = g - 1; a >= 0; a--)t[d + a] = t[c + a]; if (i === 0) { v = !0; break } } if (t[u--] = p[l--], --o === 1) { v = !0; break } if (y = o - nn(t[s], p, 0, o, o - 1, e), y !== 0) { for (u -= y, l -= y, o -= y, d = u + 1, c = l + 1, a = 0; y > a; a++)t[d + a] = p[c + a]; if (o <= 1) { v = !0; break } } if (t[u--] = t[s--], --i === 0) { v = !0; break }f-- } while (g >= aT || y >= aT); if (v) break; f < 0 && (f = 0), f += 2 } if (h = f, h < 1 && (h = 1), o === 1) { for (u -= i, s -= i, d = u + 1, c = s + 1, a = i - 1; a >= 0; a--)t[d + a] = t[c + a]; t[u] = p[l] } else { if (o === 0) throw new Error(); for (c = u - (o - 1), a = 0; o > a; a++)t[c + a] = p[a] } } else for (c = u - (o - 1), a = 0; o > a; a++)t[c + a] = p[a] } let l; let u; var h = aT; var c = 0; var p = []; return l = [], u = [], { mergeRuns: i, forceMergeRuns: r, pushRun: n } } function an (t, e, n, i) { n || (n = 0), i || (i = t.length); let r = i - n; if (!(r < 2)) { let o = 0; if (oT > r) return o = Je(t, n, i, e), void en(t, n, i, n + o, e); const a = on(t, e); const s = Qe(r); do { if (o = Je(t, n, i, e), s > o) { let l = r; l > s && (l = s), en(t, n, n + l, n + o, e), o = l }a.pushRun(n, o), a.mergeRuns(), r -= o, n += o } while (r !== 0); a.forceMergeRuns() } } function sn () { hT || (hT = !0, console.warn('z / z2 / zlevel of displayable is invalid, which may cause unexpected errors')) } function ln (t, e) { return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel } function un (t) { return t > -yT && yT > t } function hn (t) { return t > yT || -yT > t } function cn (t, e, n, i, r) { const o = 1 - r; return o * o * (o * t + 3 * r * e) + r * r * (r * i + 3 * o * n) } function pn (t, e, n, i, r) { const o = 1 - r; return 3 * (((e - t) * o + 2 * (n - e) * r) * o + (i - n) * r * r) } function dn (t, e, n, i, r, o) { const a = i + 3 * (e - n) - t; const s = 3 * (n - 2 * e + t); const l = 3 * (e - t); const u = t - r; const h = s * s - 3 * a * l; const c = s * l - 9 * a * u; const p = l * l - 3 * s * u; let d = 0; if (un(h) && un(c)) if (un(s))o[0] = 0; else { var f = -l / s; f >= 0 && f <= 1 && (o[d++] = f) } else { const g = c * c - 4 * h * p; if (un(g)) { const y = c / h; var f = -s / a + y; var v = -y / 2; f >= 0 && f <= 1 && (o[d++] = f), v >= 0 && v <= 1 && (o[d++] = v) } else if (g > 0) { const m = gT(g); let _ = h * s + 1.5 * a * (-c + m); let x = h * s + 1.5 * a * (-c - m); _ = _ < 0 ? -fT(-_, _T) : fT(_, _T), x = x < 0 ? -fT(-x, _T) : fT(x, _T); var f = (-s - (_ + x)) / (3 * a); f >= 0 && f <= 1 && (o[d++] = f) } else { const w = (2 * h * s - 3 * a * c) / (2 * gT(h * h * h)); const b = Math.acos(w) / 3; const S = gT(h); const M = Math.cos(b); var f = (-s - 2 * S * M) / (3 * a); var v = (-s + S * (M + mT * Math.sin(b))) / (3 * a); const T = (-s + S * (M - mT * Math.sin(b))) / (3 * a); f >= 0 && f <= 1 && (o[d++] = f), v >= 0 && v <= 1 && (o[d++] = v), T >= 0 && T <= 1 && (o[d++] = T) } } return d } function fn (t, e, n, i, r) { const o = 6 * n - 12 * e + 6 * t; const a = 9 * e + 3 * i - 3 * t - 9 * n; const s = 3 * e - 3 * t; let l = 0; if (un(a)) { if (hn(o)) { var u = -s / o; u >= 0 && u <= 1 && (r[l++] = u) } } else { const h = o * o - 4 * a * s; if (un(h))r[0] = -o / (2 * a); else if (h > 0) { const c = gT(h); var u = (-o + c) / (2 * a); const p = (-o - c) / (2 * a); u >= 0 && u <= 1 && (r[l++] = u), p >= 0 && p <= 1 && (r[l++] = p) } } return l } function gn (t, e, n, i, r, o) { const a = (e - t) * r + t; const s = (n - e) * r + e; const l = (i - n) * r + n; const u = (s - a) * r + a; const h = (l - s) * r + s; const c = (h - u) * r + u; o[0] = t, o[1] = a, o[2] = u, o[3] = c, o[4] = c, o[5] = h, o[6] = l, o[7] = i } function yn (t, e, n, i, r, o, a, s, l, u, h) { let c; let p; let d; let f; let g; let y = 0.005; let v = 1 / 0; xT[0] = l, xT[1] = u; for (let m = 0; m < 1; m += 0.05)wT[0] = cn(t, n, r, a, m), wT[1] = cn(e, i, o, s, m), f = TM(xT, wT), v > f && (c = m, v = f); v = 1 / 0; for (let _ = 0; _ < 32 && !(vT > y); _++)p = c - y, d = c + y, wT[0] = cn(t, n, r, a, p), wT[1] = cn(e, i, o, s, p), f = TM(wT, xT), p >= 0 && v > f ? (c = p, v = f) : (bT[0] = cn(t, n, r, a, d), bT[1] = cn(e, i, o, s, d), g = TM(bT, xT), d <= 1 && v > g ? (c = d, v = g) : y *= 0.5); return h && (h[0] = cn(t, n, r, a, c), h[1] = cn(e, i, o, s, c)), gT(v) } function vn (t, e, n, i, r, o, a, s, l) { for (var u = t, h = e, c = 0, p = 1 / l, d = 1; l >= d; d++) { const f = d * p; const g = cn(t, n, r, a, f); const y = cn(e, i, o, s, f); const v = g - u; const m = y - h; c += Math.sqrt(v * v + m * m), u = g, h = y } return c } function mn (t, e, n, i) { const r = 1 - i; return r * (r * t + 2 * i * e) + i * i * n } function _n (t, e, n, i) { return 2 * ((1 - i) * (e - t) + i * (n - e)) } function xn (t, e, n, i, r) { const o = t - 2 * e + n; const a = 2 * (e - t); const s = t - i; let l = 0; if (un(o)) { if (hn(a)) { var u = -s / a; u >= 0 && u <= 1 && (r[l++] = u) } } else { const h = a * a - 4 * o * s; if (un(h)) { var u = -a / (2 * o); u >= 0 && u <= 1 && (r[l++] = u) } else if (h > 0) { const c = gT(h); var u = (-a + c) / (2 * o); const p = (-a - c) / (2 * o); u >= 0 && u <= 1 && (r[l++] = u), p >= 0 && p <= 1 && (r[l++] = p) } } return l } function wn (t, e, n) { const i = t + n - 2 * e; return i === 0 ? 0.5 : (t - e) / i } function bn (t, e, n, i, r) { const o = (e - t) * i + t; const a = (n - e) * i + e; const s = (a - o) * i + o; r[0] = t, r[1] = o, r[2] = s, r[3] = s, r[4] = a, r[5] = n } function Sn (t, e, n, i, r, o, a, s, l) { let u; let h = 0.005; let c = 1 / 0; xT[0] = a, xT[1] = s; for (let p = 0; p < 1; p += 0.05) { wT[0] = mn(t, n, r, p), wT[1] = mn(e, i, o, p); var d = TM(xT, wT); c > d && (u = p, c = d) }c = 1 / 0; for (let f = 0; f < 32 && !(vT > h); f++) { const g = u - h; const y = u + h; wT[0] = mn(t, n, r, g), wT[1] = mn(e, i, o, g); var d = TM(wT, xT); if (g >= 0 && c > d)u = g, c = d; else { bT[0] = mn(t, n, r, y), bT[1] = mn(e, i, o, y); const v = TM(bT, xT); y <= 1 && c > v ? (u = y, c = v) : h *= 0.5 } } return l && (l[0] = mn(t, n, r, u), l[1] = mn(e, i, o, u)), gT(c) } function Mn (t, e, n, i, r, o, a) { for (var s = t, l = e, u = 0, h = 1 / a, c = 1; a >= c; c++) { const p = c * h; const d = mn(t, n, r, p); const f = mn(e, i, o, p); const g = d - s; const y = f - l; u += Math.sqrt(g * g + y * y), s = d, l = f } return u } function Tn (t) { const e = t && ST.exec(t); if (e) { const n = e[1].split(','); const i = +G(n[0]); const r = +G(n[1]); const o = +G(n[2]); const a = +G(n[3]); if (isNaN(i + r + o + a)) return; const s = []; return function (t) { return t <= 0 ? 0 : t >= 1 ? 1 : dn(0, i, o, 1, t, s) && cn(0, r, a, 1, s[0]) } } } function In (t) { return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t } function Cn (t) { return t = Math.round(t), t < 0 ? 0 : t > 360 ? 360 : t } function Dn (t) { return t < 0 ? 0 : t > 1 ? 1 : t } function kn (t) { const e = t; return In(e.length && e.charAt(e.length - 1) === '%' ? parseFloat(e) / 100 * 255 : parseInt(e, 10)) } function An (t) { const e = t; return Dn(e.length && e.charAt(e.length - 1) === '%' ? parseFloat(e) / 100 : parseFloat(e)) } function Ln (t, e, n) { return n < 0 ? n += 1 : n > 1 && (n -= 1), 6 * n < 1 ? t + (e - t) * n * 6 : 2 * n < 1 ? e : 3 * n < 2 ? t + (e - t) * (2 / 3 - n) * 6 : t } function Pn (t, e, n) { return t + (e - t) * n } function On (t, e, n, i, r) { return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t } function Rn (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t } function Nn (t, e) { AT && Rn(AT, e), AT = kT.put(t, AT || e.slice()) } function zn (t, e) { if (t) { e = e || []; const n = kT.get(t); if (n) return Rn(e, n); t += ''; const i = t.replace(/ /g, '').toLowerCase(); if (i in DT) return Rn(e, DT[i]), Nn(t, e), e; const r = i.length; if (i.charAt(0) !== '#') { const o = i.indexOf('('); const a = i.indexOf(')'); if (o !== -1 && a + 1 === r) { const s = i.substr(0, o); const l = i.substr(o + 1, a - (o + 1)).split(','); let u = 1; switch (s) { case 'rgba':if (l.length !== 4) return l.length === 3 ? On(e, +l[0], +l[1], +l[2], 1) : On(e, 0, 0, 0, 1); u = An(l.pop()); case 'rgb':return l.length >= 3 ? (On(e, kn(l[0]), kn(l[1]), kn(l[2]), l.length === 3 ? u : An(l[3])), Nn(t, e), e) : void On(e, 0, 0, 0, 1); case 'hsla':return l.length !== 4 ? void On(e, 0, 0, 0, 1) : (l[3] = An(l[3]), Bn(l, e), Nn(t, e), e); case 'hsl':return l.length !== 3 ? void On(e, 0, 0, 0, 1) : (Bn(l, e), Nn(t, e), e); default:return } }On(e, 0, 0, 0, 1) } else { if (r === 4 || r === 5) { var h = parseInt(i.slice(1, 4), 16); return h >= 0 && h <= 4095 ? (On(e, (3840 & h) >> 4 | (3840 & h) >> 8, 240 & h | (240 & h) >> 4, 15 & h | (15 & h) << 4, r === 5 ? parseInt(i.slice(4), 16) / 15 : 1), Nn(t, e), e) : void On(e, 0, 0, 0, 1) } if (r === 7 || r === 9) { var h = parseInt(i.slice(1, 7), 16); return h >= 0 && h <= 16777215 ? (On(e, (16711680 & h) >> 16, (65280 & h) >> 8, 255 & h, r === 9 ? parseInt(i.slice(7), 16) / 255 : 1), Nn(t, e), e) : void On(e, 0, 0, 0, 1) } } } } function Bn (t, e) { const n = (parseFloat(t[0]) % 360 + 360) % 360 / 360; const i = An(t[1]); const r = An(t[2]); const o = r <= 0.5 ? r * (i + 1) : r + i - r * i; const a = 2 * r - o; return e = e || [], On(e, In(255 * Ln(a, o, n + 1 / 3)), In(255 * Ln(a, o, n)), In(255 * Ln(a, o, n - 1 / 3)), 1), t.length === 4 && (e[3] = t[3]), e } function En (t) { if (t) { let e; let n; const i = t[0] / 255; const r = t[1] / 255; const o = t[2] / 255; const a = Math.min(i, r, o); const s = Math.max(i, r, o); const l = s - a; const u = (s + a) / 2; if (l === 0)e = 0, n = 0; else { n = u < 0.5 ? l / (s + a) : l / (2 - s - a); const h = ((s - i) / 6 + l / 2) / l; const c = ((s - r) / 6 + l / 2) / l; const p = ((s - o) / 6 + l / 2) / l; i === s ? e = p - c : r === s ? e = 1 / 3 + h - p : o === s && (e = 2 / 3 + c - h), e < 0 && (e += 1), e > 1 && (e -= 1) } const d = [360 * e, n, u]; return t[3] != null && d.push(t[3]), d } } function Vn (t, e) { const n = zn(t); if (n) { for (let i = 0; i < 3; i++)n[i] = e < 0 ? n[i] * (1 - e) | 0 : (255 - n[i]) * e + n[i] | 0, n[i] > 255 ? n[i] = 255 : n[i] < 0 && (n[i] = 0); return Yn(n, n.length === 4 ? 'rgba' : 'rgb') } } function Fn (t) { const e = zn(t); return e ? ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) : void 0 } function Hn (t, e, n) { if (e && e.length && t >= 0 && t <= 1) { n = n || []; const i = t * (e.length - 1); const r = Math.floor(i); const o = Math.ceil(i); const a = e[r]; const s = e[o]; const l = i - r; return n[0] = In(Pn(a[0], s[0], l)), n[1] = In(Pn(a[1], s[1], l)), n[2] = In(Pn(a[2], s[2], l)), n[3] = Dn(Pn(a[3], s[3], l)), n } } function Wn (t, e, n) { if (e && e.length && t >= 0 && t <= 1) { const i = t * (e.length - 1); const r = Math.floor(i); const o = Math.ceil(i); const a = zn(e[r]); const s = zn(e[o]); const l = i - r; const u = Yn([In(Pn(a[0], s[0], l)), In(Pn(a[1], s[1], l)), In(Pn(a[2], s[2], l)), Dn(Pn(a[3], s[3], l))], 'rgba'); return n ? { color: u, leftIndex: r, rightIndex: o, value: i } : u } } function Gn (t, e, n, i) { let r = zn(t); return t ? (r = En(r), e != null && (r[0] = Cn(e)), n != null && (r[1] = An(n)), i != null && (r[2] = An(i)), Yn(Bn(r), 'rgba')) : void 0 } function Xn (t, e) { const n = zn(t); return n && e != null ? (n[3] = Dn(e), Yn(n, 'rgba')) : void 0 } function Yn (t, e) { if (t && t.length) { let n = t[0] + ',' + t[1] + ',' + t[2]; return (e === 'rgba' || e === 'hsva' || e === 'hsla') && (n += ',' + t[3]), e + '(' + n + ')' } } function Un (t, e) { const n = zn(t); return n ? (0.299 * n[0] + 0.587 * n[1] + 0.114 * n[2]) * n[3] / 255 + (1 - n[3]) * e : 0 } function Zn () { return Yn([Math.round(255 * Math.random()), Math.round(255 * Math.random()), Math.round(255 * Math.random())], 'rgb') } function jn (t) { let e; if (t && t !== 'transparent') { if (typeof t === 'string' && t.indexOf('rgba') > -1) { const n = zn(t); n && (t = 'rgb(' + n[0] + ',' + n[1] + ',' + n[2] + ')', e = n[3]) } } else t = 'none'; return { color: t, opacity: e == null ? 1 : e } } function qn (t) { return NT > t && t > -NT } function Kn (t) { return RT(1e3 * t) / 1e3 } function $n (t) { return RT(1e4 * t) / 1e4 } function Qn (t) { return 'matrix(' + Kn(t[0]) + ',' + Kn(t[1]) + ',' + Kn(t[2]) + ',' + Kn(t[3]) + ',' + $n(t[4]) + ',' + $n(t[5]) + ')' } function Jn (t, e, n) { return n === 'top' ? t += e / 2 : n === 'bottom' && (t -= e / 2), t } function ti (t) { return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY) } function ei (t) { const e = t.style; const n = t.getGlobalScale(); return [e.shadowColor, (e.shadowBlur || 0).toFixed(2), (e.shadowOffsetX || 0).toFixed(2), (e.shadowOffsetY || 0).toFixed(2), n[0], n[1]].join(',') } function ni (t) { return t && !!t.image } function ii (t) { return t && !!t.svgElement } function ri (t) { return ni(t) || ii(t) } function oi (t) { return t.type === 'linear' } function ai (t) { return t.type === 'radial' } function si (t) { return t && (t.type === 'linear' || t.type === 'radial') } function li (t) { return 'url(#' + t + ')' } function ui (t) { const e = t.getGlobalScale(); const n = Math.max(e[0], e[1]); return Math.max(Math.ceil(Math.log(n) / Math.log(10)), 1) } function hi (t) { const e = t.x || 0; const n = t.y || 0; const i = (t.rotation || 0) * xM; const r = E(t.scaleX, 1); const o = E(t.scaleY, 1); const a = t.skewX || 0; const s = t.skewY || 0; const l = []; return (e || n) && l.push('translate(' + e + 'px,' + n + 'px)'), i && l.push('rotate(' + i + ')'), (r !== 1 || o !== 1) && l.push('scale(' + r + ',' + o + ')'), (a || s) && l.push('skew(' + RT(a * xM) + 'deg, ' + RT(s * xM) + 'deg)'), l.join(' ') } function ci (t, e, n) { return (e - t) * n + t } function pi (t, e, n, i) { for (let r = e.length, o = 0; r > o; o++)t[o] = ci(e[o], n[o], i); return t } function di (t, e, n, i) { for (let r = e.length, o = r && e[0].length, a = 0; r > a; a++) { t[a] || (t[a] = []); for (let s = 0; o > s; s++)t[a][s] = ci(e[a][s], n[a][s], i) } return t } function fi (t, e, n, i) { for (let r = e.length, o = 0; r > o; o++)t[o] = e[o] + n[o] * i; return t } function gi (t, e, n, i) { for (let r = e.length, o = r && e[0].length, a = 0; r > a; a++) { t[a] || (t[a] = []); for (let s = 0; o > s; s++)t[a][s] = e[a][s] + n[a][s] * i } return t } function yi (t, e) { for (let n = t.length, i = e.length, r = n > i ? e : t, o = Math.min(n, i), a = r[o - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = o; s < Math.max(n, i); s++)r.push({ offset: a.offset, color: a.color.slice() }) } function vi (t, e, n) { const i = t; const r = e; if (i.push && r.push) { const o = i.length; const a = r.length; if (o !== a) { const s = o > a; if (s)i.length = a; else for (var l = o; a > l; l++)i.push(n === 1 ? r[l] : ET.call(r[l])) } for (var u = i[0] && i[0].length, l = 0; l < i.length; l++) if (n === 1)isNaN(i[l]) && (i[l] = r[l]); else for (let h = 0; u > h; h++)isNaN(i[l][h]) && (i[l][h] = r[l][h]) } } function mi (t) { if (g(t)) { const e = t.length; if (g(t[0])) { for (var n = [], i = 0; e > i; i++)n.push(ET.call(t[i])); return n } return ET.call(t) } return t } function _i (t) { return t[0] = Math.floor(t[0]) || 0, t[1] = Math.floor(t[1]) || 0, t[2] = Math.floor(t[2]) || 0, t[3] = t[3] == null ? 1 : t[3], 'rgba(' + t.join(',') + ')' } function xi (t) { return g(t && t[0]) ? 2 : 1 } function wi (t) { return t === GT || t === XT } function bi (t) { return t === FT || t === HT } function Si () { return (new Date()).getTime() } function Mi (t) { const e = t.pointerType; return e === 'pen' || e === 'touch' } function Ti (t) { t.touching = !0, t.touchTimer != null && (clearTimeout(t.touchTimer), t.touchTimer = null), t.touchTimer = setTimeout(function () { t.touching = !1, t.touchTimer = null }, 700) } function Ii (t) { t && (t.zrByTouch = !0) } function Ci (t, e) { return Le(t.dom, new eI(t, e), !0) } function Di (t, e) { for (var n = e, i = !1; n && n.nodeType !== 9 && !(i = n.domBelongToZr || n !== e && n === t.painterRoot);)n = n.parentNode; return i } function ki (t, e) { const n = e.domHandlers; ZS.pointerEventsSupported ? y(QT.pointer, function (i) { Li(e, i, function (e) { n[i].call(t, e) }) }) : (ZS.touchEventsSupported && y(QT.touch, function (i) { Li(e, i, function (r) { n[i].call(t, r), Ti(e) }) }), y(QT.mouse, function (i) { Li(e, i, function (r) { r = Ae(r), e.touching || n[i].call(t, r) }) })) } function Ai (t, e) { function n (n) { function i (i) { i = Ae(i), Di(t, i.target) || (i = Ci(t, i), e.domHandlers[n].call(t, i)) }Li(e, n, i, { capture: !0 }) }ZS.pointerEventsSupported ? y(JT.pointer, n) : ZS.touchEventsSupported || y(JT.mouse, n) } function Li (t, e, n, i) { t.mounted[e] = n, t.listenerOpts[e] = i, Oe(t.domTarget, e, n, i) } function Pi (t) { const e = t.mounted; for (const n in e)e.hasOwnProperty(n) && Re(t.domTarget, n, e[n], t.listenerOpts[n]); t.mounted = {} } function Oi (t) { return t > dI || -dI > t } function Ri (t, e) { for (let n = 0; n < _I.length; n++) { const i = _I[n]; t[i] = e[i] } } function Ni (t, e) { e = e || KS; let n = xI[e]; n || (n = xI[e] = new CT(500)); let i = n.get(t); return i == null && (i = eM.measureText(t, e).width, n.put(t, i)), i } function zi (t, e, n, i) { const r = Ni(t, e); const o = Fi(e); const a = Ei(0, r, n); const s = Vi(0, o, i); const l = new $M(a, s, r, o); return l } function Bi (t, e, n, i) { const r = ((t || '') + '').split('\n'); const o = r.length; if (o === 1) return zi(r[0], e, n, i); for (var a = new $M(0, 0, 0, 0), s = 0; s < r.length; s++) { const l = zi(r[s], e, n, i); s === 0 ? a.copy(l) : a.union(l) } return a } function Ei (t, e, n) { return n === 'right' ? t -= e : n === 'center' && (t -= e / 2), t } function Vi (t, e, n) { return n === 'middle' ? t -= e / 2 : n === 'bottom' && (t -= e), t } function Fi (t) { return Ni('å›½', t) } function Hi (t, e) { return typeof t === 'string' ? t.lastIndexOf('%') >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t } function Wi (t, e, n) { const i = e.position || 'inside'; const r = e.distance != null ? e.distance : 5; const o = n.height; const a = n.width; const s = o / 2; let l = n.x; let u = n.y; let h = 'left'; let c = 'top'; if (i instanceof Array)l += Hi(i[0], n.width), u += Hi(i[1], n.height), h = null, c = null; else switch (i) { case 'left':l -= r, u += s, h = 'right', c = 'middle'; break; case 'right':l += r + a, u += s, c = 'middle'; break; case 'top':l += a / 2, u -= r, h = 'center', c = 'bottom'; break; case 'bottom':l += a / 2, u += o + r, h = 'center'; break; case 'inside':l += a / 2, u += s, h = 'center', c = 'middle'; break; case 'insideLeft':l += r, u += s, c = 'middle'; break; case 'insideRight':l += a - r, u += s, h = 'right', c = 'middle'; break; case 'insideTop':l += a / 2, u += r, h = 'center'; break; case 'insideBottom':l += a / 2, u += o - r, h = 'center', c = 'bottom'; break; case 'insideTopLeft':l += r, u += r; break; case 'insideTopRight':l += a - r, u += r, h = 'right'; break; case 'insideBottomLeft':l += r, u += o - r, c = 'bottom'; break; case 'insideBottomRight':l += a - r, u += o - r, h = 'right', c = 'bottom' } return t = t || {}, t.x = l, t.y = u, t.align = h, t.verticalAlign = c, t } function Gi (t, e, n, i, r) { n = n || {}; const o = []; qi(t, '', t, e, n, i, o, r); let a = o.length; let s = !1; const l = n.done; const u = n.aborted; const h = function () { s = !0, a--, a <= 0 && (s ? l && l() : u && u()) }; const c = function () { a--, a <= 0 && (s ? l && l() : u && u()) }; a || l && l(), o.length > 0 && n.during && o[0].during(function (t, e) { n.during(e) }); for (let p = 0; p < o.length; p++) { const d = o[p]; h && d.done(h), c && d.aborted(c), n.force && d.duration(n.duration), d.start(n.easing) } return o } function Xi (t, e, n) { for (let i = 0; n > i; i++)t[i] = e[i] } function Yi (t) { return g(t[0]) } function Ui (t, e, n) { if (g(e[n])) if (g(t[n]) || (t[n] = []), L(e[n])) { const i = e[n].length; t[n].length !== i && (t[n] = new e[n].constructor(i), Xi(t[n], e[n], i)) } else { const r = e[n]; const o = t[n]; const a = r.length; if (Yi(r)) for (let s = r[0].length, l = 0; a > l; l++)o[l] ? Xi(o[l], r[l], s) : o[l] = Array.prototype.slice.call(r[l]); else Xi(o, r, a); o.length = r.length } else t[n] = e[n] } function Zi (t, e) { return t === e || g(t) && g(e) && ji(t, e) } function ji (t, e) { const n = t.length; if (n !== e.length) return !1; for (let i = 0; n > i; i++) if (t[i] !== e[i]) return !1; return !0 } function qi (t, e, n, i, r, o, a, s) { for (var l = w(i), u = r.duration, h = r.delay, c = r.additive, d = r.setToFinal, f = !k(o), y = t.animators, v = [], m = 0; m < l.length; m++) { var x = l[m]; const b = i[x]; if (b != null && n[x] != null && (f || o[x])) if (!k(b) || g(b) || O(b))v.push(x); else { if (e) { s || (n[x] = b, t.updateDuringAnimation(e)); continue }qi(t, x, n[x], b, r, o && o[x], a, s) } else s || (n[x] = b, t.updateDuringAnimation(e), v.push(x)) } let S = v.length; if (!c && S) for (var M = 0; M < y.length; M++) { var T = y[M]; if (T.targetName === e) { const I = T.stopTracks(v); if (I) { const C = p(y, T); y.splice(C, 1) } } } if (r.force || (v = _(v, function (t) { return !Zi(i[t], n[t]) }), S = v.length), S > 0 || r.force && !a.length) { let D = void 0; let A = void 0; let L = void 0; if (s) { A = {}, d && (D = {}); for (var M = 0; S > M; M++) { var x = v[M]; A[x] = n[x], d ? D[x] = i[x] : n[x] = i[x] } } else if (d) { L = {}; for (var M = 0; S > M; M++) { var x = v[M]; L[x] = mi(n[x]), Ui(n, i, x) } } var T = new jT(n, !1, !1, c ? _(y, function (t) { return t.targetName === e }) : null); T.targetName = e, r.scope && (T.scope = r.scope), d && D && T.whenWithKeys(0, D, v), L && T.whenWithKeys(0, L, v), T.whenWithKeys(u == null ? 500 : u, s ? A : i, v).delay(h || 0), t.addAnimator(T, e), a.push(T) } } function Ki (t) { delete kI[t] } function $i (t) { if (!t) return !1; if (typeof t === 'string') return Un(t, 1) < lI; if (t.colorStops) { for (var e = t.colorStops, n = 0, i = e.length, r = 0; i > r; r++)n += Un(e[r].color, 1); return n /= i, lI > n } return !1 } function Qi (t, e) { const n = new AI(o(), t, e); return kI[n.id] = n, n } function Ji (t) { t.dispose() } function tr () { for (const t in kI)kI.hasOwnProperty(t) && kI[t].dispose(); kI = {} } function er (t) { return kI[t] } function nr (t, e) { DI[t] = e } function ir (t) { return t.replace(/^\s+|\s+$/g, '') } function rr (t, e, n, i) { const r = e[0]; const o = e[1]; const a = n[0]; const s = n[1]; const l = o - r; const u = s - a; if (l === 0) return u === 0 ? a : (a + s) / 2; if (i) if (l > 0) { if (r >= t) return a; if (t >= o) return s } else { if (t >= r) return a; if (o >= t) return s } else { if (t === r) return a; if (t === o) return s } return (t - r) / l * u + a } function or (t, e) {
    switch (t) {
      case 'center':case 'middle':t = '50%'; break; case 'left':case 'top':t = '0%'; break; case 'right':case 'bottom':t = '100%'
    } return I(t) ? ir(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : t == null ? 0 / 0 : +t
  } function ar (t, e, n) { return e == null && (e = 10), e = Math.min(Math.max(0, e), RI), t = (+t).toFixed(e), n ? t : +t } function sr (t) { return t.sort(function (t, e) { return t - e }), t } function lr (t) { if (t = +t, isNaN(t)) return 0; if (t > 1e-14) for (let e = 1, n = 0; n < 15; n++, e *= 10) if (Math.round(t * e) / e === t) return n; return ur(t) } function ur (t) { const e = t.toString().toLowerCase(); const n = e.indexOf('e'); const i = n > 0 ? +e.slice(n + 1) : 0; const r = n > 0 ? n : e.length; const o = e.indexOf('.'); const a = o < 0 ? 0 : r - 1 - o; return Math.max(0, a - i) } function hr (t, e) { const n = Math.log; const i = Math.LN10; const r = Math.floor(n(t[1] - t[0]) / i); const o = Math.round(n(Math.abs(e[1] - e[0])) / i); const a = Math.min(Math.max(-r + o, 0), 20); return isFinite(a) ? a : 20 } function cr (t, e, n) { if (!t[e]) return 0; const i = pr(t, n); return i[e] || 0 } function pr (t, e) { const n = m(t, function (t, e) { return t + (isNaN(e) ? 0 : e) }, 0); if (n === 0) return []; for (var i = Math.pow(10, e), r = v(t, function (t) { return (isNaN(t) ? 0 : t) / n * i * 100 }), o = 100 * i, a = v(r, function (t) { return Math.floor(t) }), s = m(a, function (t, e) { return t + e }, 0), l = v(r, function (t, e) { return t - a[e] }); o > s;) { for (var u = Number.NEGATIVE_INFINITY, h = null, c = 0, p = l.length; p > c; ++c)l[c] > u && (u = l[c], h = c); ++a[h], l[h] = 0, ++s } return v(a, function (t) { return t / i }) } function dr (t, e) { const n = Math.max(lr(t), lr(e)); const i = t + e; return n > RI ? i : ar(i, n) } function fr (t) { const e = 2 * Math.PI; return (t % e + e) % e } function gr (t) { return t > -OI && OI > t } function yr (t) { if (t instanceof Date) return t; if (I(t)) { const e = zI.exec(t); if (!e) return new Date(0 / 0); if (e[8]) { let n = +e[4] || 0; return e[8].toUpperCase() !== 'Z' && (n -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, n, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0)) } return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0) } return new Date(t == null ? 0 / 0 : Math.round(t)) } function vr (t) { return Math.pow(10, mr(t)) } function mr (t) { if (t === 0) return 0; let e = Math.floor(Math.log(t) / Math.LN10); return t / Math.pow(10, e) >= 10 && e++, e } function _r (t, e) { let n; const i = mr(t); const r = Math.pow(10, i); const o = t / r; return n = e ? o < 1.5 ? 1 : o < 2.5 ? 2 : o < 4 ? 3 : o < 7 ? 5 : 10 : o < 1 ? 1 : o < 2 ? 2 : o < 3 ? 3 : o < 5 ? 5 : 10, t = n * r, i >= -20 ? +t.toFixed(i < 0 ? -i : 0) : t } function xr (t, e) { const n = (t.length - 1) * e + 1; const i = Math.floor(n); const r = +t[i - 1]; const o = n - i; return o ? r + o * (t[i] - r) : r } function wr (t) { function e (t, n, i) { return t.interval[i] < n.interval[i] || t.interval[i] === n.interval[i] && (t.close[i] - n.close[i] === (i ? -1 : 1) || !i && e(t, n, 1)) }t.sort(function (t, n) { return e(t, n, 0) ? -1 : 1 }); for (let n = -1 / 0, i = 1, r = 0; r < t.length;) { for (var o = t[r].interval, a = t[r].close, s = 0; s < 2; s++)o[s] <= n && (o[s] = n, a[s] = s ? 1 : 1 - i), n = o[s], i = a[s]; o[0] === o[1] && a[0] * a[1] !== 1 ? t.splice(r, 1) : r++ } return t } function br (t) { const e = parseFloat(t); return e == t && (e !== 0 || !I(t) || t.indexOf('x') <= 0) ? e : 0 / 0 } function Sr (t) { return !isNaN(br(t)) } function Mr () { return Math.round(9 * Math.random()) } function Tr (t, e) { return e === 0 ? t : Tr(e, t % e) } function Ir (t, e) { return t == null ? e : e == null ? t : t * e / Tr(t, e) } function Cr (t) { throw new Error(t) } function Dr (t, e, n) { return (e - t) * n + t } function kr (t) { return t instanceof Array ? t : t == null ? [] : [t] } function Ar (t, e, n) { if (t) { t[e] = t[e] || {}, t.emphasis = t.emphasis || {}, t.emphasis[e] = t.emphasis[e] || {}; for (let i = 0, r = n.length; r > i; i++) { const o = n[i]; !t.emphasis[e].hasOwnProperty(o) && t[e].hasOwnProperty(o) && (t.emphasis[e][o] = t[e][o]) } } } function Lr (t) { return !k(t) || M(t) || t instanceof Date ? t : t.value } function Pr (t) { return k(t) && !(t instanceof Array) } function Or (t, e, n) { const i = n === 'normalMerge'; const r = n === 'replaceMerge'; const o = n === 'replaceAll'; t = t || [], e = (e || []).slice(); const a = Z(); y(e, function (t, n) { return k(t) ? void 0 : void (e[n] = null) }); const s = Rr(t, a, n); return (i || r) && Nr(s, t, a, e), i && zr(s, e), i || r ? Br(s, e, r) : o && Er(s, e), Vr(s), s } function Rr (t, e, n) { const i = []; if (n === 'replaceAll') return i; for (let r = 0; r < t.length; r++) { const o = t[r]; o && o.id != null && e.set(o.id, r), i.push({ existing: n === 'replaceMerge' || Xr(o) ? null : o, newOption: null, keyInfo: null, brandNew: null }) } return i } function Nr (t, e, n, i) { y(i, function (r, o) { if (r && r.id != null) { const a = Hr(r.id); const s = n.get(a); if (s != null) { const l = t[s]; W(!l.newOption, 'Duplicated option on id "' + a + '".'), l.newOption = r, l.existing = e[s], i[o] = null } } }) } function zr (t, e) { y(e, function (n, i) { if (n && n.name != null) for (let r = 0; r < t.length; r++) { const o = t[r].existing; if (!t[r].newOption && o && (o.id == null || n.id == null) && !Xr(n) && !Xr(o) && Fr('name', o, n)) return t[r].newOption = n, void (e[i] = null) } }) } function Br (t, e, n) { y(e, function (e) { if (e) { for (var i, r = 0; (i = t[r]) && (i.newOption || Xr(i.existing) || i.existing && e.id != null && !Fr('id', e, i.existing));)r++; i ? (i.newOption = e, i.brandNew = n) : t.push({ newOption: e, brandNew: n, existing: null, keyInfo: null }), r++ } }) } function Er (t, e) { y(e, function (e) { t.push({ newOption: e, brandNew: !0, existing: null, keyInfo: null }) }) } function Vr (t) { const e = Z(); y(t, function (t) { const n = t.existing; n && e.set(n.id, t) }), y(t, function (t) { const n = t.newOption; W(!n || n.id == null || !e.get(n.id) || e.get(n.id) === t, 'id duplicates: ' + (n && n.id)), n && n.id != null && e.set(n.id, t), !t.keyInfo && (t.keyInfo = {}) }), y(t, function (t, n) { const i = t.existing; const r = t.newOption; const o = t.keyInfo; if (k(r)) { if (o.name = r.name != null ? Hr(r.name) : i ? i.name : BI + n, i)o.id = Hr(i.id); else if (r.id != null)o.id = Hr(r.id); else { let a = 0; do o.id = '\x00' + o.name + '\x00' + a++; while (e.get(o.id)) }e.set(o.id, t) } }) } function Fr (t, e, n) { const i = Wr(e[t], null); const r = Wr(n[t], null); return i != null && r != null && i === r } function Hr (t) { return Wr(t, '') } function Wr (t, e) { return t == null ? e : I(t) ? t : D(t) || C(t) ? t + '' : e } function Gr (t) { const e = t.name; return !(!e || !e.indexOf(BI)) } function Xr (t) { return t && t.id != null && Hr(t.id).indexOf(EI) === 0 } function Yr (t) { return EI + t } function Ur (t, e, n) { y(t, function (t) { const i = t.newOption; k(i) && (t.keyInfo.mainType = e, t.keyInfo.subType = Zr(e, i, t.existing, n)) }) } function Zr (t, e, n, i) { const r = e.type ? e.type : n ? n.subType : i.determineSubType(t, e); return r } function jr (t, e) { return e.dataIndexInside != null ? e.dataIndexInside : e.dataIndex != null ? M(e.dataIndex) ? v(e.dataIndex, function (e) { return t.indexOfRawIndex(e) }) : t.indexOfRawIndex(e.dataIndex) : e.name != null ? M(e.name) ? v(e.name, function (e) { return t.indexOfName(e) }) : t.indexOfName(e.name) : void 0 } function qr () { const t = '__ec_inner_' + FI++; return function (e) { return e[t] || (e[t] = {}) } } function Kr (t, e, n) { const i = $r(e, n); const r = i.mainTypeSpecified; const o = i.queryOptionMap; const a = i.others; const s = a; const l = n ? n.defaultMainType : null; return !r && l && o.set(l, {}), o.each(function (e, i) { const r = Qr(t, i, e, { useDefault: l === i, enableAll: n && n.enableAll != null ? n.enableAll : !0, enableNone: n && n.enableNone != null ? n.enableNone : !0 }); s[i + 'Models'] = r.models, s[i + 'Model'] = r.models[0] }), s } function $r (t, e) { let n; if (I(t)) { const i = {}; i[t + 'Index'] = 0, n = i } else n = t; const r = Z(); const o = {}; let a = !1; return y(n, function (t, n) { if (n === 'dataIndex' || n === 'dataIndexInside') return void (o[n] = t); const i = n.match(/^(\w+)(Index|Id|Name)$/) || []; const s = i[1]; const l = (i[2] || '').toLowerCase(); if (s && l && !(e && e.includeMainTypes && p(e.includeMainTypes, s) < 0)) { a = a || !!s; const u = r.get(s) || r.set(s, {}); u[l] = t } }), { mainTypeSpecified: a, queryOptionMap: r, others: o } } function Qr (t, e, n, i) { i = i || HI; let r = n.index; let o = n.id; let a = n.name; const s = { models: null, specified: r != null || o != null || a != null }; if (!s.specified) { let l = void 0; return s.models = i.useDefault && (l = t.getComponent(e)) ? [l] : [], s } return r === 'none' || r === !1 ? (W(i.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (r === 'all' && (W(i.enableAll, '`"all"` is not a valid value on index option.'), r = o = a = null), s.models = t.queryComponents({ mainType: e, index: r, id: o, name: a }), s) } function Jr (t, e, n) { t.setAttribute ? t.setAttribute(e, n) : t[e] = n } function to (t, e) { return t.getAttribute ? t.getAttribute(e) : t[e] } function eo (t) { return t === 'auto' ? ZS.domSupported ? 'html' : 'richText' : t || 'html' } function no (t, e, n, i, r) { const o = e == null || e === 'auto'; if (i == null) return i; if (D(i)) { var a = Dr(n || 0, i, r); return ar(a, o ? Math.max(lr(n || 0), lr(i)) : e) } if (I(i)) return r < 1 ? n : i; for (var s = [], l = n, u = i, h = Math.max(l ? l.length : 0, u.length), c = 0; h > c; ++c) { const p = t.getDimensionInfo(c); if (p && p.type === 'ordinal')s[c] = (r < 1 && l ? l : u)[c]; else { const d = l && l[c] ? l[c] : 0; const f = u[c]; var a = Dr(d, f, r); s[c] = ar(a, o ? Math.max(lr(d), lr(f)) : e) } } return s } function io (t) { const e = { main: '', sub: '' }; if (t) { const n = t.split(GI); e.main = n[0] || '', e.sub = n[1] || '' } return e } function ro (t) { W(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal') } function oo (t) { return !(!t || !t[YI]) } function ao (t) { t.$constructor = t, t.extend = function (t) { let n; const i = this; return so(i) ? n = (function (t) { function n () { return t.apply(this, arguments) || this } return e(n, t), n }(i)) : (n = function () { (t.$constructor || i).apply(this, arguments) }, d(n, this)), h(n.prototype, t), n[YI] = !0, n.extend = this.extend, n.superCall = ho, n.superApply = co, n.superClass = i, n } } function so (t) { return T(t) && /^class\s/.test(Function.prototype.toString.call(t)) } function lo (t, e) { t.extend = e.extend } function uo (t) { const e = ['__\x00is_clz', UI++].join('_'); t.prototype[e] = !0, t.isInstance = function (t) { return !(!t || !t[e]) } } function ho (t, e) { for (var n = [], i = 2; i < arguments.length; i++)n[i - 2] = arguments[i]; return this.superClass.prototype[e].apply(t, n) } function co (t, e, n) { return this.superClass.prototype[e].apply(t, n) } function po (t) { function e (t) { let e = n[t.main]; return e && e[XI] || (e = n[t.main] = {}, e[XI] = !0), e } var n = {}; t.registerClass = function (t) { const i = t.type || t.prototype.type; if (i) { ro(i), t.prototype.type = i; const r = io(i); if (r.sub) { if (r.sub !== XI) { const o = e(r); o[r.sub] = t } } else n[r.main] = t } return t }, t.getClass = function (t, e, i) { let r = n[t]; if (r && r[XI] && (r = e ? r[e] : null), i && !r) throw new Error(e ? 'Component ' + t + '.' + (e || '') + ' is used but not imported.' : t + '.type should be specified.'); return r }, t.getClassesByMainType = function (t) { const e = io(t); const i = []; const r = n[e.main]; return r && r[XI] ? y(r, function (t, e) { e !== XI && i.push(t) }) : i.push(r), i }, t.hasClass = function (t) { const e = io(t); return !!n[e.main] }, t.getAllClassMainTypes = function () { const t = []; return y(n, function (e, n) { t.push(n) }), t }, t.hasSubTypes = function (t) { const e = io(t); const i = n[e.main]; return i && i[XI] } } function fo (t, e) { for (let n = 0; n < t.length; n++)t[n][1] || (t[n][1] = t[n][0]); return e = e || !1, function (n, i, r) { for (var o = {}, a = 0; a < t.length; a++) { const s = t[a][1]; if (!(i && p(i, s) >= 0 || r && p(r, s) < 0)) { const l = n.getShallow(s, e); l != null && (o[t[a][0]] = l) } } return o } } function go (t) { if (typeof t === 'string') { const e = KI.get(t); return e && e.image } return t } function yo (t, e, n, i, r) { if (t) { if (typeof t === 'string') { if (e && e.__zrImageSrc === t || !n) return e; const o = KI.get(t); const a = { hostEl: n, cb: i, cbPayload: r }; return o ? (e = o.image, !mo(e) && o.pending.push(a)) : (e = eM.loadImage(t, vo, vo), e.__zrImageSrc = t, KI.put(t, e.__cachedImgObj = { image: e, pending: [a] })), e } return t } return e } function vo () { const t = this.__cachedImgObj; this.onload = this.onerror = this.__cachedImgObj = null; for (let e = 0; e < t.pending.length; e++) { const n = t.pending[e]; const i = n.cb; i && i(this, n.cbPayload), n.hostEl.dirty() }t.pending.length = 0 } function mo (t) { return t && t.width && t.height } function _o (t, e, n, i, r) { if (!e) return ''; const o = (t + '').split('\n'); r = xo(e, n, i, r); for (let a = 0, s = o.length; s > a; a++)o[a] = wo(o[a], r); return o.join('\n') } function xo (t, e, n, i) { i = i || {}; const r = h({}, i); r.font = e, n = E(n, '...'), r.maxIterations = E(i.maxIterations, 2); const o = r.minChar = E(i.minChar, 0); r.cnCharWidth = Ni('å›½', e); const a = r.ascCharWidth = Ni('a', e); r.placeholder = E(i.placeholder, ''); for (var s = t = Math.max(0, t - 1), l = 0; o > l && s >= a; l++)s -= a; let u = Ni(n, e); return u > s && (n = '', u = 0), s = t - u, r.ellipsis = n, r.ellipsisWidth = u, r.contentWidth = s, r.containerWidth = t, r } function wo (t, e) { const n = e.containerWidth; const i = e.font; const r = e.contentWidth; if (!n) return ''; let o = Ni(t, i); if (n >= o) return t; for (let a = 0; ;a++) { if (r >= o || a >= e.maxIterations) { t += e.ellipsis; break } const s = a === 0 ? bo(t, r, e.ascCharWidth, e.cnCharWidth) : o > 0 ? Math.floor(t.length * r / o) : 0; t = t.substr(0, s), o = Ni(t, i) } return t === '' && (t = e.placeholder), t } function bo (t, e, n, i) { for (var r = 0, o = 0, a = t.length; a > o && e > r; o++) { const s = t.charCodeAt(o); r += s >= 0 && s <= 127 ? n : i } return o } function So (t, e) { t != null && (t += ''); let n; const i = e.overflow; const r = e.padding; const o = e.font; const a = i === 'truncate'; const s = Fi(o); const l = E(e.lineHeight, s); const u = !!e.backgroundColor; const h = e.lineOverflow === 'truncate'; let c = e.width; n = c == null || i !== 'break' && i !== 'breakAll' ? t ? t.split('\n') : [] : t ? Do(t, e.font, c, i === 'breakAll', 0).lines : []; const p = n.length * l; const d = E(e.height, p); if (p > d && h) { const f = Math.floor(d / l); n = n.slice(0, f) } if (t && a && c != null) for (var g = xo(c, o, e.ellipsis, { minChar: e.truncateMinChar, placeholder: e.placeholder }), y = 0; y < n.length; y++)n[y] = wo(n[y], g); for (var v = d, m = 0, y = 0; y < n.length; y++)m = Math.max(Ni(n[y], o), m); c == null && (c = m); let _ = m; return r && (v += r[0] + r[2], _ += r[1] + r[3], c += r[1] + r[3]), u && (_ = c), { lines: n, height: d, outerWidth: _, outerHeight: v, lineHeight: l, calculatedLineHeight: s, contentWidth: m, contentHeight: p, width: c } } function Mo (t, e) { function n (t, e, n) { t.width = e, t.lineHeight = n, p += n, d = Math.max(d, e) } const i = new tC(); if (t != null && (t += ''), !t) return i; for (var r, o = e.width, a = e.height, s = e.overflow, l = s !== 'break' && s !== 'breakAll' || o == null ? null : { width: o, accumWidth: 0, breakAll: s === 'breakAll' }, u = $I.lastIndex = 0; (r = $I.exec(t)) != null;) { const h = r.index; h > u && To(i, t.substring(u, h), e, l), To(i, r[2], e, l, r[1]), u = $I.lastIndex }u < t.length && To(i, t.substring(u, t.length), e, l); const c = []; var p = 0; var d = 0; const f = e.padding; const g = s === 'truncate'; const y = e.lineOverflow === 'truncate'; t:for (var v = 0; v < i.lines.length; v++) { for (var m = i.lines[v], _ = 0, x = 0, w = 0; w < m.tokens.length; w++) { var b = m.tokens[w]; const S = b.styleName && e.rich[b.styleName] || {}; const M = b.textPadding = S.padding; const T = M ? M[1] + M[3] : 0; const I = b.font = S.font || e.font; b.contentHeight = Fi(I); let C = E(S.height, b.contentHeight); if (b.innerHeight = C, M && (C += M[0] + M[2]), b.height = C, b.lineHeight = V(S.lineHeight, e.lineHeight, C), b.align = S && S.align || e.align, b.verticalAlign = S && S.verticalAlign || 'middle', y && a != null && p + b.lineHeight > a) { w > 0 ? (m.tokens = m.tokens.slice(0, w), n(m, x, _), i.lines = i.lines.slice(0, v + 1)) : i.lines = i.lines.slice(0, v); break t } const D = S.width; const k = D == null || D === 'auto'; if (typeof D === 'string' && D.charAt(D.length - 1) === '%')b.percentWidth = D, c.push(b), b.contentWidth = Ni(b.text, I); else { if (k) { const A = S.backgroundColor; let L = A && A.image; L && (L = go(L), mo(L) && (b.width = Math.max(b.width, L.width * C / L.height))) } const P = g && o != null ? o - x : null; P != null && P < b.width ? !k || T > P ? (b.text = '', b.width = b.contentWidth = 0) : (b.text = _o(b.text, P - T, I, e.ellipsis, { minChar: e.truncateMinChar }), b.width = b.contentWidth = Ni(b.text, I)) : b.contentWidth = Ni(b.text, I) }b.width += T, x += b.width, S && (_ = Math.max(_, b.lineHeight)) }n(m, x, _) }i.outerWidth = i.width = E(o, d), i.outerHeight = i.height = E(a, p), i.contentHeight = p, i.contentWidth = d, f && (i.outerWidth += f[1] + f[3], i.outerHeight += f[0] + f[2]); for (var v = 0; v < c.length; v++) { var b = c[v]; const O = b.percentWidth; b.width = parseInt(O, 10) / 100 * i.width } return i } function To (t, e, n, i, r) { let o; let a; const s = e === ''; const l = r && n.rich[r] || {}; const u = t.lines; const h = l.font || n.font; let c = !1; if (i) { const p = l.padding; const d = p ? p[1] + p[3] : 0; if (l.width != null && l.width !== 'auto') { const f = Hi(l.width, i.width) + d; u.length > 0 && f + i.accumWidth > i.width && (o = e.split('\n'), c = !0), i.accumWidth = f } else { const g = Do(e, h, i.width, i.breakAll, i.accumWidth); i.accumWidth = g.accumWidth + d, a = g.linesWidths, o = g.lines } } else o = e.split('\n'); for (let y = 0; y < o.length; y++) { const v = o[y]; const m = new QI(); if (m.styleName = r, m.text = v, m.isLineHolder = !v && !s, m.width = typeof l.width === 'number' ? l.width : a ? a[y] : Ni(v, h), y || c)u.push(new JI([m])); else { const _ = (u[u.length - 1] || (u[0] = new JI())).tokens; const x = _.length; x === 1 && _[0].isLineHolder ? _[0] = m : (v || !x || s) && _.push(m) } } } function Io (t) { const e = t.charCodeAt(0); return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303 } function Co (t) { return Io(t) ? eC[t] ? !0 : !1 : !0 } function Do (t, e, n, i, r) { for (var o = [], a = [], s = '', l = '', u = 0, h = 0, c = 0; c < t.length; c++) { const p = t.charAt(c); if (p !== '\n') { const d = Ni(p, e); const f = i ? !1 : !Co(p); (o.length ? h + d > n : r + h + d > n) ? h ? (s || l) && (f ? (s || (s = l, l = '', u = 0, h = u), o.push(s), a.push(h - u), l += p, u += d, s = '', h = u) : (l && (s += l, l = '', u = 0), o.push(s), a.push(h), s = p, h = d)) : f ? (o.push(l), a.push(u), l = p, u = d) : (o.push(p), a.push(d)) : (h += d, f ? (l += p, u += d) : (l && (s += l, l = '', u = 0), s += p)) } else l && (s += l, h += u), o.push(s), a.push(h), s = '', l = '', u = 0, h = 0 } return o.length || s || (s = t, l = '', u = 0), l && (s += l), s && (o.push(s), a.push(h)), o.length === 1 && (h += r), { accumWidth: h, lines: o, linesWidths: a } } function ko (t, e, n) { return lC.copy(t.getBoundingRect()), t.transform && lC.applyTransform(t.transform), uC.width = e, uC.height = n, !lC.intersect(uC) } function Ao (t, e, n) { if (t.length !== 0) { for (var i = t[0], r = i[0], o = i[0], a = i[1], s = i[1], l = 1; l < t.length; l++)i = t[l], r = hC(r, i[0]), o = cC(o, i[0]), a = hC(a, i[1]), s = cC(s, i[1]); e[0] = r, e[1] = a, n[0] = o, n[1] = s } } function Lo (t, e, n, i, r, o) { r[0] = hC(t, n), r[1] = hC(e, i), o[0] = cC(t, n), o[1] = cC(e, i) } function Po (t, e, n, i, r, o, a, s, l, u) { const h = fn; const c = cn; let p = h(t, n, r, a, mC); l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0; for (var d = 0; p > d; d++) { const f = c(t, n, r, a, mC[d]); l[0] = hC(f, l[0]), u[0] = cC(f, u[0]) }p = h(e, i, o, s, _C); for (var d = 0; p > d; d++) { const g = c(e, i, o, s, _C[d]); l[1] = hC(g, l[1]), u[1] = cC(g, u[1]) }l[0] = hC(t, l[0]), u[0] = cC(t, u[0]), l[0] = hC(a, l[0]), u[0] = cC(a, u[0]), l[1] = hC(e, l[1]), u[1] = cC(e, u[1]), l[1] = hC(s, l[1]), u[1] = cC(s, u[1]) } function Oo (t, e, n, i, r, o, a, s) { const l = wn; const u = mn; const h = cC(hC(l(t, n, r), 1), 0); const c = cC(hC(l(e, i, o), 1), 0); const p = u(t, n, r, h); const d = u(e, i, o, c); a[0] = hC(t, r, p), a[1] = hC(e, o, d), s[0] = cC(t, r, p), s[1] = cC(e, o, d) } function Ro (t, e, n, i, r, o, a, s, l) { const u = me; const h = _e; const c = Math.abs(r - o); if (c % fC < 1e-4 && c > 1e-4) return s[0] = t - n, s[1] = e - i, l[0] = t + n, void (l[1] = e + i); if (gC[0] = dC(r) * n + t, gC[1] = pC(r) * i + e, yC[0] = dC(o) * n + t, yC[1] = pC(o) * i + e, u(s, gC, yC), h(l, gC, yC), r %= fC, r < 0 && (r += fC), o %= fC, o < 0 && (o += fC), r > o && !a ? o += fC : o > r && a && (r += fC), a) { const p = o; o = r, r = p } for (let d = 0; o > d; d += Math.PI / 2)d > r && (vC[0] = dC(d) * n + t, vC[1] = pC(d) * i + e, u(s, vC, s), h(l, vC, l)) } function No (t) { const e = Math.round(t / PC * 1e8) / 1e8; return e % 2 * PC } function zo (t, e) { let n = No(t[0]); n < 0 && (n += OC); const i = n - t[0]; let r = t[1]; r += i, !e && r - n >= OC ? r = n + OC : e && n - r >= OC ? r = n - OC : !e && n > r ? r = n + (OC - No(n - r)) : e && r > n && (r = n - (OC - No(r - n))), t[0] = n, t[1] = r } function Bo (t, e, n, i, r, o, a) { if (r === 0) return !1; const s = r; let l = 0; let u = t; if (a > e + s && a > i + s || e - s > a && i - s > a || o > t + s && o > n + s || t - s > o && n - s > o) return !1; if (t === n) return Math.abs(o - t) <= s / 2; l = (e - i) / (t - n), u = (t * i - n * e) / (t - n); const h = l * o - a + u; const c = h * h / (l * l + 1); return s / 2 * s / 2 >= c } function Eo (t, e, n, i, r, o, a, s, l, u, h) { if (l === 0) return !1; const c = l; if (h > e + c && h > i + c && h > o + c && h > s + c || e - c > h && i - c > h && o - c > h && s - c > h || u > t + c && u > n + c && u > r + c && u > a + c || t - c > u && n - c > u && r - c > u && a - c > u) return !1; const p = yn(t, e, n, i, r, o, a, s, u, h, null); return c / 2 >= p } function Vo (t, e, n, i, r, o, a, s, l) { if (a === 0) return !1; const u = a; if (l > e + u && l > i + u && l > o + u || e - u > l && i - u > l && o - u > l || s > t + u && s > n + u && s > r + u || t - u > s && n - u > s && r - u > s) return !1; const h = Sn(t, e, n, i, r, o, s, l, null); return u / 2 >= h } function Fo (t) { return t %= BC, t < 0 && (t += BC), t } function Ho (t, e, n, i, r, o, a, s, l) { if (a === 0) return !1; const u = a; s -= t, l -= e; const h = Math.sqrt(s * s + l * l); if (h - u > n || n > h + u) return !1; if (Math.abs(i - r) % EC < 1e-4) return !0; if (o) { const c = i; i = Fo(r), r = Fo(c) } else i = Fo(i), r = Fo(r); i > r && (r += EC); let p = Math.atan2(l, s); return p < 0 && (p += EC), p >= i && r >= p || p + EC >= i && r >= p + EC } function Wo (t, e, n, i, r, o) { if (o > e && o > i || e > o && i > o) return 0; if (i === e) return 0; const a = (o - e) / (i - e); let s = e > i ? 1 : -1; (a === 1 || a === 0) && (s = e > i ? 0.5 : -0.5); const l = a * (n - t) + t; return l === r ? 1 / 0 : l > r ? s : 0 } function Go (t, e) { return Math.abs(t - e) < HC } function Xo () { const t = GC[0]; GC[0] = GC[1], GC[1] = t } function Yo (t, e, n, i, r, o, a, s, l, u) { if (u > e && u > i && u > o && u > s || e > u && i > u && o > u && s > u) return 0; const h = dn(e, i, o, s, u, WC); if (h === 0) return 0; for (var c = 0, p = -1, d = void 0, f = void 0, g = 0; h > g; g++) { const y = WC[g]; const v = y === 0 || y === 1 ? 0.5 : 1; const m = cn(t, n, r, a, y); l > m || (p < 0 && (p = fn(e, i, o, s, GC), GC[1] < GC[0] && p > 1 && Xo(), d = cn(e, i, o, s, GC[0]), p > 1 && (f = cn(e, i, o, s, GC[1]))), c += p === 2 ? y < GC[0] ? e > d ? v : -v : y < GC[1] ? d > f ? v : -v : f > s ? v : -v : y < GC[0] ? e > d ? v : -v : d > s ? v : -v) } return c } function Uo (t, e, n, i, r, o, a, s) { if (s > e && s > i && s > o || e > s && i > s && o > s) return 0; const l = xn(e, i, o, s, WC); if (l === 0) return 0; const u = wn(e, i, o); if (u >= 0 && u <= 1) { for (var h = 0, c = mn(e, i, o, u), p = 0; l > p; p++) { var d = WC[p] === 0 || WC[p] === 1 ? 0.5 : 1; var f = mn(t, n, r, WC[p]); a > f || (h += WC[p] < u ? e > c ? d : -d : c > o ? d : -d) } return h } var d = WC[0] === 0 || WC[0] === 1 ? 0.5 : 1; var f = mn(t, n, r, WC[0]); return a > f ? 0 : e > o ? d : -d } function Zo (t, e, n, i, r, o, a, s) { if (s -= e, s > n || -n > s) return 0; const l = Math.sqrt(n * n - s * s); WC[0] = -l, WC[1] = l; const u = Math.abs(i - r); if (u < 1e-4) return 0; if (u >= FC - 1e-4) { i = 0, r = FC; var h = o ? 1 : -1; return a >= WC[0] + t && a <= WC[1] + t ? h : 0 } if (i > r) { const c = i; i = r, r = c }i < 0 && (i += FC, r += FC); for (var p = 0, d = 0; d < 2; d++) { const f = WC[d]; if (f + t > a) { let g = Math.atan2(s, f); var h = o ? 1 : -1; g < 0 && (g = FC + g), (g >= i && r >= g || g + FC >= i && r >= g + FC) && (g > Math.PI / 2 && g < 1.5 * Math.PI && (h = -h), p += h) } } return p } function jo (t, e, n, i, r) { for (var o, a, s = t.data, l = t.len(), u = 0, h = 0, c = 0, p = 0, d = 0, f = 0; l > f;) { const g = s[f++]; const y = f === 1; switch (g === VC.M && f > 1 && (n || (u += Wo(h, c, p, d, i, r))), y && (h = s[f], c = s[f + 1], p = h, d = c), g) { case VC.M:p = s[f++], d = s[f++], h = p, c = d; break; case VC.L:if (n) { if (Bo(h, c, s[f], s[f + 1], e, i, r)) return !0 } else u += Wo(h, c, s[f], s[f + 1], i, r) || 0; h = s[f++], c = s[f++]; break; case VC.C:if (n) { if (Eo(h, c, s[f++], s[f++], s[f++], s[f++], s[f], s[f + 1], e, i, r)) return !0 } else u += Yo(h, c, s[f++], s[f++], s[f++], s[f++], s[f], s[f + 1], i, r) || 0; h = s[f++], c = s[f++]; break; case VC.Q:if (n) { if (Vo(h, c, s[f++], s[f++], s[f], s[f + 1], e, i, r)) return !0 } else u += Uo(h, c, s[f++], s[f++], s[f], s[f + 1], i, r) || 0; h = s[f++], c = s[f++]; break; case VC.A:var v = s[f++]; var m = s[f++]; var _ = s[f++]; var x = s[f++]; var w = s[f++]; var b = s[f++]; f += 1; var S = !!(1 - s[f++]); o = Math.cos(w) * _ + v, a = Math.sin(w) * x + m, y ? (p = o, d = a) : u += Wo(h, c, o, a, i, r); var M = (i - v) * x / _ + v; if (n) { if (Ho(v, m, x, w, w + b, S, e, M, r)) return !0 } else u += Zo(v, m, x, w, w + b, S, M, r); h = Math.cos(w + b) * _ + v, c = Math.sin(w + b) * x + m; break; case VC.R:p = h = s[f++], d = c = s[f++]; var T = s[f++]; var I = s[f++]; if (o = p + T, a = d + I, n) { if (Bo(p, d, o, d, e, i, r) || Bo(o, d, o, a, e, i, r) || Bo(o, a, p, a, e, i, r) || Bo(p, a, p, d, e, i, r)) return !0 } else u += Wo(o, d, o, a, i, r), u += Wo(p, a, p, d, i, r); break; case VC.Z:if (n) { if (Bo(h, c, p, d, e, i, r)) return !0 } else u += Wo(h, c, p, d, i, r); h = p, c = d } } return n || Go(c, d) || (u += Wo(h, c, p, d, i, r) || 0), u !== 0 } function qo (t, e, n) { return jo(t, 0, !1, e, n) } function Ko (t, e, n, i) { return jo(t, e, !0, n, i) } function $o (t) { return !!(t && typeof t !== 'string' && t.width && t.height) } function Qo (t, e) { let n; let i; let r; let o; let a = e.x; let s = e.y; let l = e.width; let u = e.height; const h = e.r; l < 0 && (a += l, l = -l), u < 0 && (s += u, u = -u), typeof h === 'number' ? n = i = r = o = h : h instanceof Array ? h.length === 1 ? n = i = r = o = h[0] : h.length === 2 ? (n = r = h[0], i = o = h[1]) : h.length === 3 ? (n = h[0], i = o = h[1], r = h[2]) : (n = h[0], i = h[1], r = h[2], o = h[3]) : n = i = r = o = 0; let c; n + i > l && (c = n + i, n *= l / c, i *= l / c), r + o > l && (c = r + o, r *= l / c, o *= l / c), i + r > u && (c = i + r, i *= u / c, r *= u / c), n + o > u && (c = n + o, n *= u / c, o *= u / c), t.moveTo(a + n, s), t.lineTo(a + l - i, s), i !== 0 && t.arc(a + l - i, s + i, i, -Math.PI / 2, 0), t.lineTo(a + l, s + u - r), r !== 0 && t.arc(a + l - r, s + u - r, r, 0, Math.PI / 2), t.lineTo(a + o, s + u), o !== 0 && t.arc(a + o, s + u - o, o, Math.PI / 2, Math.PI), t.lineTo(a, s + n), n !== 0 && t.arc(a + n, s + n, n, Math.PI, 1.5 * Math.PI) } function Jo (t, e, n) { if (e) { const i = e.x1; const r = e.x2; const o = e.y1; const a = e.y2; t.x1 = i, t.x2 = r, t.y1 = o, t.y2 = a; const s = n && n.lineWidth; return s ? (JC(2 * i) === JC(2 * r) && (t.x1 = t.x2 = ea(i, s, !0)), JC(2 * o) === JC(2 * a) && (t.y1 = t.y2 = ea(o, s, !0)), t) : t } } function ta (t, e, n) { if (e) { const i = e.x; const r = e.y; const o = e.width; const a = e.height; t.x = i, t.y = r, t.width = o, t.height = a; const s = n && n.lineWidth; return s ? (t.x = ea(i, s, !0), t.y = ea(r, s, !0), t.width = Math.max(ea(i + o, s, !1) - t.x, o === 0 ? 0 : 1), t.height = Math.max(ea(r + a, s, !1) - t.y, a === 0 ? 0 : 1), t) : t } } function ea (t, e, n) { if (!e) return t; const i = JC(2 * t); return (i + JC(e)) % 2 === 0 ? i / 2 : (i + (n ? 1 : -1)) / 2 } function na (t) { return typeof t !== 'string' || t.indexOf('px') === -1 && t.indexOf('rem') === -1 && t.indexOf('em') === -1 ? isNaN(+t) ? jS + 'px' : t + 'px' : t } function ia (t, e) { for (let n = 0; n < uD.length; n++) { const i = uD[n]; const r = e[i]; r != null && (t[i] = r) } } function ra (t) { return t.fontSize != null || t.fontFamily || t.fontWeight } function oa (t) { return aa(t), y(t.rich, aa), t } function aa (t) { if (t) { t.font = aD.makeFont(t); let e = t.align; e === 'middle' && (e = 'center'), t.align = e == null || sD[e] ? e : 'left'; let n = t.verticalAlign; n === 'center' && (n = 'middle'), t.verticalAlign = n == null || lD[n] ? n : 'top'; const i = t.padding; i && (t.padding = H(t.padding)) } } function sa (t, e) { return t == null || e <= 0 || t === 'transparent' || t === 'none' ? null : t.image || t.colorStops ? '#000' : t } function la (t) { return t == null || t === 'none' ? null : t.image || t.colorStops ? '#000' : t } function ua (t, e, n) { return e === 'right' ? t - n[1] : e === 'center' ? t + n[3] / 2 - n[1] / 2 : t + n[3] } function ha (t) { let e = t.text; return e != null && (e += ''), e } function ca (t) { return !!(t.backgroundColor || t.lineHeight || t.borderWidth && t.borderColor) } function pa (t) { return t != null && t !== 'none' } function da (t) { if (I(t)) { let e = DD.get(t); return e || (e = Vn(t, -0.1), DD.put(t, e)), e } if (O(t)) { const n = h({}, t); return n.colorStops = v(t.colorStops, function (t) { return { offset: t.offset, color: Vn(t.color, -0.1) } }), n } return t } function fa (t, e, n) { t.onHoverStateChange && (t.hoverState || 0) !== n && t.onHoverStateChange(e), t.hoverState = n } function ga (t) { fa(t, 'emphasis', mD) } function ya (t) { t.hoverState === mD && fa(t, 'normal', yD) } function va (t) { fa(t, 'blur', vD) } function ma (t) { t.hoverState === vD && fa(t, 'normal', yD) } function _a (t) { t.selected = !0 } function xa (t) { t.selected = !1 } function wa (t, e, n) { e(t, n) } function ba (t, e, n) { wa(t, e, n), t.isGroup && t.traverse(function (t) { wa(t, e, n) }) } function Sa (t, e) { switch (e) { case 'emphasis':t.hoverState = mD; break; case 'normal':t.hoverState = yD; break; case 'blur':t.hoverState = vD; break; case 'select':t.selected = !0 } } function Ma (t, e, n, i) { for (var r = t.style, o = {}, a = 0; a < e.length; a++) { const s = e[a]; const l = r[s]; o[s] = l == null ? i && i[s] : l } for (var a = 0; a < t.animators.length; a++) { const u = t.animators[a]; u.__fromStateTransition && u.__fromStateTransition.indexOf(n) < 0 && u.targetName === 'style' && u.saveTo(o, e) } return o } function Ta (t, e, n, i) { const r = n && p(n, 'select') >= 0; let o = !1; if (t instanceof ZC) { const a = fD(t); const s = r ? a.selectFill || a.normalFill : a.normalFill; const l = r ? a.selectStroke || a.normalStroke : a.normalStroke; if (pa(s) || pa(l)) { i = i || {}; let u = i.style || {}; u.fill === 'inherit' ? (o = !0, i = h({}, i), u = h({}, u), u.fill = s) : !pa(u.fill) && pa(s) ? (o = !0, i = h({}, i), u = h({}, u), u.fill = da(s)) : !pa(u.stroke) && pa(l) && (o || (i = h({}, i), u = h({}, u)), u.stroke = da(l)), i.style = u } } if (i && i.z2 == null) { o || (i = h({}, i)); const c = t.z2EmphasisLift; i.z2 = t.z2 + (c != null ? c : wD) } return i } function Ia (t, e, n) { if (n && n.z2 == null) { n = h({}, n); const i = t.z2SelectLift; n.z2 = t.z2 + (i != null ? i : bD) } return n } function Ca (t, e, n) { const i = p(t.currentStates, e) >= 0; const r = t.style.opacity; const o = i ? null : Ma(t, ['opacity'], e, { opacity: 1 }); n = n || {}; let a = n.style || {}; return a.opacity == null && (n = h({}, n), a = h({ opacity: i ? r : 0.1 * o.opacity }, a), n.style = a), n } function Da (t, e) { const n = this.states[t]; if (this.style) { if (t === 'emphasis') return Ta(this, t, e, n); if (t === 'blur') return Ca(this, t, n); if (t === 'select') return Ia(this, t, n) } return n } function ka (t) { t.stateProxy = Da; const e = t.getTextContent(); const n = t.getTextGuideLine(); e && (e.stateProxy = Da), n && (n.stateProxy = Da) } function Aa (t, e) { !Ea(t, e) && !t.__highByOuter && ba(t, ga) } function La (t, e) { !Ea(t, e) && !t.__highByOuter && ba(t, ya) } function Pa (t, e) { t.__highByOuter |= 1 << (e || 0), ba(t, ga) } function Oa (t, e) { !(t.__highByOuter &= ~(1 << (e || 0))) && ba(t, ya) } function Ra (t) { ba(t, va) } function Na (t) { ba(t, ma) } function za (t) { ba(t, _a) } function Ba (t) { ba(t, xa) } function Ea (t, e) { return t.__highDownSilentOnTouch && e.zrByTouch } function Va (t) { const e = t.getModel(); const n = []; const i = []; e.eachComponent(function (e, r) { const o = gD(r); const a = e === 'series'; const s = a ? t.getViewOfSeriesModel(r) : t.getViewOfComponentModel(r); !a && i.push(s), o.isBlured && (s.group.traverse(function (t) { ma(t) }), a && n.push(r)), o.isBlured = !1 }), y(i, function (t) { t && t.toggleBlurSeries && t.toggleBlurSeries(n, !1, e) }) } function Fa (t, e, n, i) { function r (t, e) { for (let n = 0; n < e.length; n++) { const i = t.getItemGraphicEl(e[n]); i && Na(i) } } const o = i.getModel(); if (n = n || 'coordinateSystem', t != null && e && e !== 'none') { const a = o.getSeriesByIndex(t); let s = a.coordinateSystem; s && s.master && (s = s.master); const l = []; o.eachSeries(function (t) { const o = a === t; let u = t.coordinateSystem; u && u.master && (u = u.master); const h = u && s ? u === s : o; if (!(n === 'series' && !o || n === 'coordinateSystem' && !h || e === 'series' && o)) { const c = i.getViewOfSeriesModel(t); if (c.group.traverse(function (t) { va(t) }), g(e))r(t.getData(), e); else if (k(e)) for (let p = w(e), d = 0; d < p.length; d++)r(t.getData(p[d]), e[p[d]]); l.push(t), gD(t).isBlured = !0 } }), o.eachComponent(function (t, e) { if (t !== 'series') { const n = i.getViewOfComponentModel(e); n && n.toggleBlurSeries && n.toggleBlurSeries(l, !0, o) } }) } } function Ha (t, e, n) { if (t != null && e != null) { const i = n.getModel().getComponent(t, e); if (i) { gD(i).isBlured = !0; const r = n.getViewOfComponentModel(i); r && r.focusBlurEnabled && r.group.traverse(function (t) { va(t) }) } } } function Wa (t, e, n) { const i = t.seriesIndex; const r = t.getData(e.dataType); if (r) { let o = jr(r, e); o = (M(o) ? o[0] : o) || 0; let a = r.getItemGraphicEl(o); if (!a) for (let s = r.count(), l = 0; !a && s > l;)a = r.getItemGraphicEl(l++); if (a) { const u = hD(a); Fa(i, u.focus, u.blurScope, n) } else { const h = t.get(['emphasis', 'focus']); const c = t.get(['emphasis', 'blurScope']); h != null && Fa(i, h, c, n) } } } function Ga (t, e, n, i) { const r = { focusSelf: !1, dispatchers: null }; if (t == null || t === 'series' || e == null || n == null) return r; const o = i.getModel().getComponent(t, e); if (!o) return r; const a = i.getViewOfComponentModel(o); if (!a || !a.findHighDownDispatchers) return r; for (var s, l = a.findHighDownDispatchers(n), u = 0; u < l.length; u++) if (hD(l[u]).focus === 'self') { s = !0; break } return { focusSelf: s, dispatchers: l } } function Xa (t, e, n) { const i = hD(t); const r = Ga(i.componentMainType, i.componentIndex, i.componentHighDownName, n); const o = r.dispatchers; const a = r.focusSelf; o ? (a && Ha(i.componentMainType, i.componentIndex, n), y(o, function (t) { return Aa(t, e) })) : (Fa(i.seriesIndex, i.focus, i.blurScope, n), i.focus === 'self' && Ha(i.componentMainType, i.componentIndex, n), Aa(t, e)) } function Ya (t, e, n) { Va(n); const i = hD(t); const r = Ga(i.componentMainType, i.componentIndex, i.componentHighDownName, n).dispatchers; r ? y(r, function (t) { return La(t, e) }) : La(t, e) } function Ua (t, e) { if (is(e)) { const n = e.dataType; const i = t.getData(n); let r = jr(i, e); M(r) || (r = [r]), t[e.type === CD ? 'toggleSelect' : e.type === TD ? 'select' : 'unselect'](r, n) } } function Za (t) { const e = t.getAllData(); y(e, function (e) { const n = e.data; const i = e.type; n.eachItemGraphicEl(function (e, n) { t.isSelected(n, i) ? za(e) : Ba(e) }) }) } function ja (t) { const e = []; return t.eachSeries(function (t) { const n = t.getAllData(); y(n, function (n) { const i = (n.data, n.type); const r = t.getSelectedDataIndices(); if (r.length > 0) { const o = { dataIndex: r, seriesIndex: t.seriesIndex }; i != null && (o.dataType = i), e.push(o) } }) }), e } function qa (t, e, n) { ts(t, !0), ba(t, ka), Qa(t, e, n) } function Ka (t) { ts(t, !1) } function $a (t, e, n, i) { i ? Ka(t) : qa(t, e, n) } function Qa (t, e, n) { const i = hD(t); e != null ? (i.focus = e, i.blurScope = n) : i.focus && (i.focus = null) } function Ja (t, e, n, i) { n = n || 'itemStyle'; for (let r = 0; r < kD.length; r++) { const o = kD[r]; const a = e.getModel([o, n]); const s = t.ensureState(o); s.style = i ? i(a) : a[AD[n]]() } } function ts (t, e) { const n = e === !1; const i = t; t.highDownSilentOnTouch && (i.__highDownSilentOnTouch = t.highDownSilentOnTouch), (!n || i.__highDownDispatcher) && (i.__highByOuter = i.__highByOuter || 0, i.__highDownDispatcher = !n) } function es (t) { return !(!t || !t.__highDownDispatcher) } function ns (t) { let e = dD[t]; return e == null && pD <= 32 && (e = dD[t] = pD++), e } function is (t) { const e = t.type; return e === TD || e === ID || e === CD } function rs (t) { const e = t.type; return e === SD || e === MD } function os (t) { const e = fD(t); e.normalFill = t.style.fill, e.normalStroke = t.style.stroke; const n = t.states.select || {}; e.selectFill = n.style && n.style.fill || null, e.selectStroke = n.style && n.style.stroke || null } function as (t, e) { if (e) { let n; let i; let r; let o; let a; let s; const l = t.data; const u = t.len(); const h = LD.M; const c = LD.C; const p = LD.L; const d = LD.R; const f = LD.A; const g = LD.Q; for (r = 0, o = 0; u > r;) { switch (n = l[r++], o = r, i = 0, n) { case h:i = 1; break; case p:i = 1; break; case c:i = 3; break; case g:i = 2; break; case f:var y = e[4]; var v = e[5]; var m = OD(e[0] * e[0] + e[1] * e[1]); var _ = OD(e[2] * e[2] + e[3] * e[3]); var x = RD(-e[1] / _, e[0] / m); l[r] *= m, l[r++] += y, l[r] *= _, l[r++] += v, l[r++] *= m, l[r++] *= _, l[r++] += x, l[r++] += x, r += 2, o = r; break; case d:s[0] = l[r++], s[1] = l[r++], ve(s, s, e), l[o++] = s[0], l[o++] = s[1], s[0] += l[r++], s[1] += l[r++], ve(s, s, e), l[o++] = s[0], l[o++] = s[1] } for (a = 0; i > a; a++) { const w = PD[a]; w[0] = l[r++], w[1] = l[r++], ve(w, w, e), l[o++] = w[0], l[o++] = w[1] } }t.increaseVersion() } } function ss (t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) } function ls (t, e) { return (t[0] * e[0] + t[1] * e[1]) / (ss(t) * ss(e)) } function us (t, e) { return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(ls(t, e)) } function hs (t, e, n, i, r, o, a, s, l, u, h) { const c = l * (ED / 180); const p = BD(c) * (t - n) / 2 + zD(c) * (e - i) / 2; const d = -1 * zD(c) * (t - n) / 2 + BD(c) * (e - i) / 2; const f = p * p / (a * a) + d * d / (s * s); f > 1 && (a *= ND(f), s *= ND(f)); const g = (r === o ? -1 : 1) * ND((a * a * s * s - a * a * d * d - s * s * p * p) / (a * a * d * d + s * s * p * p)) || 0; const y = g * a * d / s; const v = g * -s * p / a; const m = (t + n) / 2 + BD(c) * y - zD(c) * v; const _ = (e + i) / 2 + zD(c) * y + BD(c) * v; const x = us([1, 0], [(p - y) / a, (d - v) / s]); const w = [(p - y) / a, (d - v) / s]; const b = [(-1 * p - y) / a, (-1 * d - v) / s]; let S = us(w, b); if (ls(w, b) <= -1 && (S = ED), ls(w, b) >= 1 && (S = 0), S < 0) { const M = Math.round(S / ED * 1e6) / 1e6; S = 2 * ED + M % 2 * ED }h.addData(u, m, _, a, s, x, S, c, o) } function cs (t) {
    const e = new zC(); if (!t) return e; let n; let i = 0; let r = 0; let o = i; let a = r; const s = zC.CMD; const l = t.match(VD); if (!l) return e; for (let u = 0; u < l.length; u++) {
      for (var h = l[u], c = h.charAt(0), p = void 0, d = h.match(FD) || [], f = d.length, g = 0; f > g; g++)d[g] = parseFloat(d[g]); for (let y = 0; f > y;) {
        let v = void 0; let m = void 0; let _ = void 0; let x = void 0; let w = void 0; let b = void 0; let S = void 0; let M = i; let T = r; let I = void 0; let C = void 0; switch (c) {
          case 'l':i += d[y++], r += d[y++], p = s.L, e.addData(p, i, r); break; case 'L':i = d[y++], r = d[y++], p = s.L, e.addData(p, i, r); break; case 'm':i += d[y++], r += d[y++], p = s.M, e.addData(p, i, r), o = i, a = r, c = 'l'; break; case 'M':i = d[y++], r = d[y++], p = s.M, e.addData(p, i, r), o = i, a = r, c = 'L'; break; case 'h':i += d[y++], p = s.L, e.addData(p, i, r); break; case 'H':i = d[y++], p = s.L, e.addData(p, i, r); break; case 'v':r += d[y++], p = s.L, e.addData(p, i, r); break; case 'V':r = d[y++], p = s.L, e.addData(p, i, r); break; case 'C':p = s.C, e.addData(p, d[y++], d[y++], d[y++], d[y++], d[y++], d[y++]), i = d[y - 2], r = d[y - 1]; break; case 'c':p = s.C, e.addData(p, d[y++] + i, d[y++] + r, d[y++] + i, d[y++] + r, d[y++] + i, d[y++] + r), i += d[y - 2], r += d[y - 1]; break; case 'S':v = i, m = r, I = e.len(), C = e.data, n === s.C && (v += i - C[I - 4], m += r - C[I - 3]), p = s.C, M = d[y++], T = d[y++], i = d[y++], r = d[y++], e.addData(p, v, m, M, T, i, r)
            break; case 's':v = i, m = r, I = e.len(), C = e.data, n === s.C && (v += i - C[I - 4], m += r - C[I - 3]), p = s.C, M = i + d[y++], T = r + d[y++], i += d[y++], r += d[y++], e.addData(p, v, m, M, T, i, r); break; case 'Q':M = d[y++], T = d[y++], i = d[y++], r = d[y++], p = s.Q, e.addData(p, M, T, i, r); break; case 'q':M = d[y++] + i, T = d[y++] + r, i += d[y++], r += d[y++], p = s.Q, e.addData(p, M, T, i, r); break; case 'T':v = i, m = r, I = e.len(), C = e.data, n === s.Q && (v += i - C[I - 4], m += r - C[I - 3]), i = d[y++], r = d[y++], p = s.Q, e.addData(p, v, m, i, r); break; case 't':v = i, m = r, I = e.len(), C = e.data, n === s.Q && (v += i - C[I - 4], m += r - C[I - 3]), i += d[y++], r += d[y++], p = s.Q, e.addData(p, v, m, i, r); break; case 'A':_ = d[y++], x = d[y++], w = d[y++], b = d[y++], S = d[y++], M = i, T = r, i = d[y++], r = d[y++], p = s.A, hs(M, T, i, r, b, S, _, x, w, p, e); break; case 'a':_ = d[y++], x = d[y++], w = d[y++], b = d[y++], S = d[y++], M = i, T = r, i += d[y++], r += d[y++], p = s.A, hs(M, T, i, r, b, S, _, x, w, p, e)
        }
      }(c === 'z' || c === 'Z') && (p = s.Z, e.addData(p), i = o, r = a), n = p
    } return e.toStatic(), e
  } function ps (t) { return t.setData != null } function ds (t, e) { const n = cs(t); const i = h({}, e); return i.buildPath = function (t) { if (ps(t)) { t.setData(n.data); var e = t.getContext(); e && t.rebuildPath(e, 1) } else { var e = t; n.rebuildPath(e, 1) } }, i.applyTransform = function (t) { as(n, t), this.dirtyShape() }, i } function fs (t, e) { return new HD(ds(t, e)) } function gs (t, n) { const i = ds(t, n); const r = (function (t) { function n (e) { const n = t.call(this, e) || this; return n.applyTransform = i.applyTransform, n.buildPath = i.buildPath, n } return e(n, t), n }(HD)); return r } function ys (t, e) { for (var n = [], i = t.length, r = 0; i > r; r++) { const o = t[r]; n.push(o.getUpdatedPathProxy(!0)) } const a = new ZC(e); return a.createPathProxy(), a.buildPath = function (t) { if (ps(t)) { t.appendPath(n); const e = t.getContext(); e && t.rebuildPath(e, 1) } }, a } function vs (t, e, n, i, r, o, a, s) { const l = n - t; const u = i - e; const h = a - r; const c = s - o; let p = c * l - h * u; return nk > p * p ? void 0 : (p = (h * (e - o) - c * (t - r)) / p, [t + p * l, e + p * u]) } function ms (t, e, n, i, r, o, a) { const s = t - n; const l = e - i; const u = (a ? o : -o) / JD(s * s + l * l); const h = u * l; const c = -u * s; const p = t + h; const d = e + c; const f = n + h; const g = i + c; const y = (p + f) / 2; const v = (d + g) / 2; const m = f - p; const _ = g - d; const x = m * m + _ * _; const w = r - o; const b = p * g - f * d; const S = (_ < 0 ? -1 : 1) * JD(tk(0, w * w * x - b * b)); let M = (b * _ - m * S) / x; let T = (-b * m - _ * S) / x; const I = (b * _ + m * S) / x; const C = (-b * m + _ * S) / x; const D = M - y; const k = T - v; const A = I - y; const L = C - v; return D * D + k * k > A * A + L * L && (M = I, T = C), { cx: M, cy: T, x0: -h, y0: -c, x1: M * (r / w - 1), y1: T * (r / w - 1) } } function _s (t) { let e; if (M(t)) { const n = t.length; if (!n) return t; e = n === 1 ? [t[0], t[0], 0, 0] : n === 2 ? [t[0], t[0], t[1], t[1]] : n === 3 ? t.concat(t[2]) : t } else e = [t, t, t, t]; return e } function xs (t, e) { let n; let i = tk(e.r, 0); let r = tk(e.r0 || 0, 0); const o = i > 0; const a = r > 0; if (o || a) { if (o || (i = r, r = 0), r > i) { const s = i; i = r, r = s } const l = e.startAngle; const u = e.endAngle; if (!isNaN(l) && !isNaN(u)) { const h = e.cx; const c = e.cy; const p = !!e.clockwise; let d = QD(u - l); const f = d > ZD && d % ZD; if (f > nk && (d = f), i > nk) if (d > ZD - nk)t.moveTo(h + i * qD(l), c + i * jD(l)), t.arc(h, c, i, l, u, !p), r > nk && (t.moveTo(h + r * qD(u), c + r * jD(u)), t.arc(h, c, r, u, l, p)); else { let g = void 0; let y = void 0; let v = void 0; let m = void 0; let _ = void 0; let x = void 0; let w = void 0; let b = void 0; let S = void 0; let M = void 0; let T = void 0; let I = void 0; let C = void 0; let D = void 0; let k = void 0; let A = void 0; const L = i * qD(l); const P = i * jD(l); const O = r * qD(u); const R = r * jD(u); const N = d > nk; if (N) { const z = e.cornerRadius; z && (n = _s(z), g = n[0], y = n[1], v = n[2], m = n[3]); const B = QD(i - r) / 2; if (_ = ek(B, v), x = ek(B, m), w = ek(B, g), b = ek(B, y), T = S = tk(_, x), I = M = tk(w, b), (S > nk || M > nk) && (C = i * qD(u), D = i * jD(u), k = r * qD(l), A = r * jD(l), UD > d)) { const E = vs(L, P, k, A, C, D, O, R); if (E) { const V = L - E[0]; const F = P - E[1]; const H = C - E[0]; const W = D - E[1]; const G = 1 / jD(KD((V * H + F * W) / (JD(V * V + F * F) * JD(H * H + W * W))) / 2); const X = JD(E[0] * E[0] + E[1] * E[1]); T = ek(S, (i - X) / (G + 1)), I = ek(M, (r - X) / (G - 1)) } } } if (N) if (T > nk) { var Y = ek(v, T); var U = ek(m, T); var Z = ms(k, A, L, P, i, Y, p); var j = ms(C, D, O, R, i, U, p); t.moveTo(h + Z.cx + Z.x0, c + Z.cy + Z.y0), S > T && Y === U ? t.arc(h + Z.cx, c + Z.cy, T, $D(Z.y0, Z.x0), $D(j.y0, j.x0), !p) : (Y > 0 && t.arc(h + Z.cx, c + Z.cy, Y, $D(Z.y0, Z.x0), $D(Z.y1, Z.x1), !p), t.arc(h, c, i, $D(Z.cy + Z.y1, Z.cx + Z.x1), $D(j.cy + j.y1, j.cx + j.x1), !p), U > 0 && t.arc(h + j.cx, c + j.cy, U, $D(j.y1, j.x1), $D(j.y0, j.x0), !p)) } else t.moveTo(h + L, c + P), t.arc(h, c, i, l, u, !p); else t.moveTo(h + L, c + P); if (r > nk && N) if (I > nk) { var Y = ek(g, I); var U = ek(y, I); var Z = ms(O, R, C, D, r, -U, p); var j = ms(L, P, k, A, r, -Y, p); t.lineTo(h + Z.cx + Z.x0, c + Z.cy + Z.y0), M > I && Y === U ? t.arc(h + Z.cx, c + Z.cy, I, $D(Z.y0, Z.x0), $D(j.y0, j.x0), !p) : (U > 0 && t.arc(h + Z.cx, c + Z.cy, U, $D(Z.y0, Z.x0), $D(Z.y1, Z.x1), !p), t.arc(h, c, r, $D(Z.cy + Z.y1, Z.cx + Z.x1), $D(j.cy + j.y1, j.cx + j.x1), p), Y > 0 && t.arc(h + j.cx, c + j.cy, Y, $D(j.y1, j.x1), $D(j.y0, j.x0), !p)) } else t.lineTo(h + O, c + R), t.arc(h, c, r, u, l, p); else t.lineTo(h + O, c + R) } else t.moveTo(h, c); t.closePath() } } } function ws (t, e, n, i) { let r; let o; let a; let s; const l = []; const u = []; const h = []; const c = []; if (i) { a = [1 / 0, 1 / 0], s = [-1 / 0, -1 / 0]; for (var p = 0, d = t.length; d > p; p++)me(a, a, t[p]), _e(s, s, t[p]); me(a, a, i[0]), _e(s, s, i[1]) } for (var p = 0, d = t.length; d > p; p++) { const f = t[p]; if (n)r = t[p ? p - 1 : d - 1], o = t[(p + 1) % d]; else { if (p === 0 || p === d - 1) { l.push(ee(t[p])); continue }r = t[p - 1], o = t[p + 1] }oe(u, o, r), ce(u, u, e); let g = de(f, r); let y = de(f, o); const v = g + y; v !== 0 && (g /= v, y /= v), ce(h, u, -g), ce(c, u, y); const m = ie([], f, h); const _ = ie([], f, c); i && (_e(m, m, a), me(m, m, s), _e(_, _, a), me(_, _, s)), l.push(m), l.push(_) } return n && l.push(l.shift()), l } function bs (t, e, n) { const i = e.smooth; const r = e.points; if (r && r.length >= 2) { if (i) { const o = ws(r, i, n, e.smoothConstraint); t.moveTo(r[0][0], r[0][1]); for (var a = r.length, s = 0; (n ? a : a - 1) > s; s++) { const l = o[2 * s]; const u = o[2 * s + 1]; const h = r[(s + 1) % a]; t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1]) } } else { t.moveTo(r[0][0], r[0][1]); for (var s = 1, c = r.length; c > s; s++)t.lineTo(r[s][0], r[s][1]) }n && t.closePath() } } function Ss (t, e, n) { const i = t.cpx2; const r = t.cpy2; return i != null || r != null ? [(n ? pn : cn)(t.x1, t.cpx1, t.cpx2, t.x2, e), (n ? pn : cn)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(n ? _n : mn)(t.x1, t.cpx1, t.x2, e), (n ? _n : mn)(t.y1, t.cpy1, t.y2, e)] } function Ms (t, e, n, i, r) { let o; if (e && e.ecModel) { const a = e.ecModel.getUpdatePayload(); o = a && a.animation } const s = e && e.isAnimationEnabled(); const l = t === 'update'; if (s) { let u = void 0; let h = void 0; let c = void 0; i ? (u = E(i.duration, 200), h = E(i.easing, 'cubicOut'), c = 0) : (u = e.getShallow(l ? 'animationDurationUpdate' : 'animationDuration'), h = e.getShallow(l ? 'animationEasingUpdate' : 'animationEasing'), c = e.getShallow(l ? 'animationDelayUpdate' : 'animationDelay')), o && (o.duration != null && (u = o.duration), o.easing != null && (h = o.easing), o.delay != null && (c = o.delay)), T(c) && (c = c(n, r)), T(u) && (u = u(n)); const p = { duration: u || 0, delay: c, easing: h }; return p } return null } function Ts (t, e, n, i, r, o, a) { let s; let l = !1; T(r) ? (a = o, o = r, r = null) : k(r) && (o = r.cb, a = r.during, l = r.isFrom, s = r.removeOpt, r = r.dataIndex); const u = t === 'leave'; u || e.stopAnimation('leave'); const h = Ms(t, i, r, u ? s || {} : null, i && i.getAnimationDelayParams ? i.getAnimationDelayParams(e, r) : null); if (h && h.duration > 0) { const c = h.duration; const p = h.delay; const d = h.easing; const f = { duration: c, delay: p || 0, easing: d, done: o, force: !!o || !!a, setToFinal: !u, scope: t, during: a }; l ? e.animateFrom(n, f) : e.animateTo(n, f) } else e.stopAnimation(), !l && e.attr(n), a && a(1), o && o() } function Is (t, e, n, i, r, o) { Ts('update', t, e, n, i, r, o) } function Cs (t, e, n, i, r, o) { Ts('enter', t, e, n, i, r, o) } function Ds (t) { if (!t.__zr) return !0; for (let e = 0; e < t.animators.length; e++) { const n = t.animators[e]; if (n.scope === 'leave') return !0 } return !1 } function ks (t, e, n, i, r, o) { Ds(t) || Ts('leave', t, e, n, i, r, o) } function As (t, e, n, i) { t.removeTextContent(), t.removeTextGuideLine(), ks(t, { style: { opacity: 0 } }, e, n, i) } function Ls (t, e, n) { function i () { t.parent && t.parent.remove(t) }t.isGroup ? t.traverse(function (t) { t.isGroup || As(t, e, n, i) }) : As(t, e, n, i) } function Ps (t) { Ak(t).oldStyle = t.style } function Os (t) { return ZC.extend(t) } function Rs (t, e) { return Rk(t, e) } function Ns (t, e) { Ok[t] = e } function zs (t) { return Ok.hasOwnProperty(t) ? Ok[t] : void 0 } function Bs (t, e, n, i) { const r = fs(t, e); return n && (i === 'center' && (n = Vs(n, r.getBoundingRect())), Fs(r, n)), r } function Es (t, e, n) { var i = new QC({ style: { image: t, x: e.x, y: e.y, width: e.width, height: e.height }, onload: function (t) { if (n === 'center') { const r = { width: t.width, height: t.height }; i.setStyle(Vs(e, r)) } } }); return i } function Vs (t, e) { let n; const i = e.width / e.height; let r = t.height * i; r <= t.width ? n = t.height : (r = t.width, n = r / i); const o = t.x + t.width / 2; const a = t.y + t.height / 2; return { x: o - r / 2, y: a - n / 2, width: r, height: n } } function Fs (t, e) { if (t.applyTransform) { const n = t.getBoundingRect(); const i = n.calculateTransform(e); t.applyTransform(i) } } function Hs (t, e) { return Jo(t, t, { lineWidth: e }), t } function Ws (t) { return ta(t.shape, t.shape, t.style), t } function Gs (t, e) { for (var n = Ve([]); t && t !== e;)He(n, t.getLocalTransform(), n), t = t.parent; return n } function Xs (t, e, n) { return e && !g(e) && (e = mI.getLocalTransform(e)), n && (e = Ye([], e)), ve([], t, e) } function Ys (t, e, n) { const i = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]); const r = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]); let o = [t === 'left' ? -i : t === 'right' ? i : 0, t === 'top' ? -r : t === 'bottom' ? r : 0]; return o = Xs(o, e, n), Math.abs(o[0]) > Math.abs(o[1]) ? o[0] > 0 ? 'right' : 'left' : o[1] > 0 ? 'bottom' : 'top' } function Us (t) { return !t.isGroup } function Zs (t) { return t.shape != null } function js (t, e, n) { function i (t) { const e = {}; return t.traverse(function (t) { Us(t) && t.anid && (e[t.anid] = t) }), e } function r (t) { const e = { x: t.x, y: t.y, rotation: t.rotation }; return Zs(t) && (e.shape = h({}, t.shape)), e } if (t && e) { const o = i(t); e.traverse(function (t) { if (Us(t) && t.anid) { const e = o[t.anid]; if (e) { const i = r(t); t.attr(r(e)), Is(t, i, n, hD(t).dataIndex) } } }) } } function qs (t, e) { return v(t, function (t) { let n = t[0]; n = Lk(n, e.x), n = Pk(n, e.x + e.width); let i = t[1]; return i = Lk(i, e.y), i = Pk(i, e.y + e.height), [n, i] }) } function Ks (t, e) { const n = Lk(t.x, e.x); const i = Pk(t.x + t.width, e.x + e.width); const r = Lk(t.y, e.y); const o = Pk(t.y + t.height, e.y + e.height); return i >= n && o >= r ? { x: n, y: r, width: i - n, height: o - r } : void 0 } function $s (t, e, n) { const i = h({ rectHover: !0 }, e); const r = i.style = { strokeNoScale: !0 }; return n = n || { x: -1, y: -1, width: 2, height: 2 }, t ? t.indexOf('image://') === 0 ? (r.image = t.slice(8), c(r, n), new QC(i)) : Bs(t.replace('path://', ''), i, n, 'center') : void 0 } function Qs (t, e, n, i, r) { for (let o = 0, a = r[r.length - 1]; o < r.length; o++) { const s = r[o]; if (Js(t, e, n, i, s[0], s[1], a[0], a[1])) return !0; a = s } } function Js (t, e, n, i, r, o, a, s) { const l = n - t; const u = i - e; const h = a - r; const c = s - o; const p = tl(h, c, l, u); if (el(p)) return !1; const d = t - r; const f = e - o; const g = tl(d, f, l, u) / p; if (g < 0 || g > 1) return !1; const y = tl(d, f, h, c) / p; return y < 0 || y > 1 ? !1 : !0 } function tl (t, e, n, i) { return t * i - n * e } function el (t) { return t <= 1e-6 && t >= -1e-6 } function nl (t) { const e = t.itemTooltipOption; const n = t.componentModel; const i = t.itemName; const r = I(e) ? { formatter: e } : e; const o = n.mainType; const a = n.componentIndex; const s = { componentType: o, name: i, $vars: ['name'] }; s[o + 'Index'] = a; const l = t.formatterParamsExtra; l && y(w(l), function (t) { $(s, t) || (s[t] = l[t], s.$vars.push(t)) }); const u = hD(t.el); u.componentMainType = o, u.componentIndex = a, u.tooltipConfig = { name: i, option: c({ content: i, formatterParams: s }, r) } } function il (t, e) { let n; t.isGroup && (n = e(t)), n || t.traverse(e) } function rl (t, e) { if (t) if (M(t)) for (let n = 0; n < t.length; n++)il(t[n], e); else il(t, e) } function ol (t, e) { for (let n = 0; n < _D.length; n++) { const i = _D[n]; const r = e[i]; const o = t.ensureState(i); o.style = o.style || {}, o.style.text = r } const a = t.currentStates.slice(); t.clearStates(!0), t.setStyle({ text: e.normal }), t.useStates(a, !0) } function al (t, e, n) { let i; const r = t.labelFetcher; const o = t.labelDataIndex; const a = t.labelDimIndex; const s = e.normal; r && (i = r.getFormattedLabel(o, 'normal', null, a, s && s.get('formatter'), n != null ? { interpolatedValue: n } : null)), i == null && (i = T(t.defaultText) ? t.defaultText(o, t, n) : t.defaultText); for (var l = { normal: i }, u = 0; u < _D.length; u++) { const h = _D[u]; const c = e[h]; l[h] = E(r ? r.getFormattedLabel(o, h, null, a, c && c.get('formatter')) : null, i) } return l } function sl (t, e, n, i) { n = n || Ek; for (var r = t instanceof aD, o = !1, a = 0; a < xD.length; a++) { var s = e[xD[a]]; if (s && s.getShallow('show')) { o = !0; break } } let l = r ? t : t.getTextContent(); if (o) { r || (l || (l = new aD(), t.setTextContent(l)), t.stateProxy && (l.stateProxy = t.stateProxy)); const u = al(n, e); const h = e.normal; const c = !!h.getShallow('show'); const p = ul(h, i && i.normal, n, !1, !r); p.text = u.normal, r || t.setTextConfig(hl(h, n, !1)); for (var a = 0; a < _D.length; a++) { const d = _D[a]; var s = e[d]; if (s) { const f = l.ensureState(d); const g = !!E(s.getShallow('show'), c); if (g !== c && (f.ignore = !g), f.style = ul(s, i && i[d], n, !0, !r), f.style.text = u[d], !r) { const y = t.ensureState(d); y.textConfig = hl(s, n, !0) } } }l.silent = !!h.getShallow('silent'), l.style.x != null && (p.x = l.style.x), l.style.y != null && (p.y = l.style.y), l.ignore = !c, l.useStyle(p), l.dirty(), n.enableTextSetter && (Wk(l).setLabelText = function (t) { const i = al(n, e, t); ol(l, i) }) } else l && (l.ignore = !0); t.dirty() } function ll (t, e) { e = e || 'label'; for (var n = { normal: t.getModel(e) }, i = 0; i < _D.length; i++) { const r = _D[i]; n[r] = t.getModel([r, e]) } return n } function ul (t, e, n, i, r) { const o = {}; return cl(o, t, n, i, r), e && h(o, e), o } function hl (t, e, n) { e = e || {}; let i; const r = {}; let o = t.getShallow('rotate'); const a = E(t.getShallow('distance'), n ? null : 5); const s = t.getShallow('offset'); return i = t.getShallow('position') || (n ? null : 'inside'), i === 'outside' && (i = e.defaultOutsidePosition || 'top'), i != null && (r.position = i), s != null && (r.offset = s), o != null && (o *= Math.PI / 180, r.rotation = o), a != null && (r.distance = a), r.outsideFill = t.get('color') === 'inherit' ? e.inheritColor || null : 'auto', r } function cl (t, e, n, i, r) { n = n || Ek; let o; const a = e.ecModel; const s = a && a.option.textStyle; const l = pl(e); if (l) { o = {}; for (const u in l) if (l.hasOwnProperty(u)) { const h = e.getModel(['rich', u]); dl(o[u] = {}, h, s, n, i, r, !1, !0) } }o && (t.rich = o); const c = e.get('overflow'); c && (t.overflow = c); const p = e.get('minMargin'); p != null && (t.margin = p), dl(t, e, s, n, i, r, !0, !1) } function pl (t) { for (var e; t && t !== t.ecModel;) { const n = (t.option || Ek).rich; if (n) { e = e || {}; for (let i = w(n), r = 0; r < i.length; r++) { const o = i[r]; e[o] = 1 } }t = t.parentModel } return e } function dl (t, e, n, i, r, o, a, s) { n = !r && n || Ek; const l = i && i.inheritColor; let u = e.getShallow('color'); let h = e.getShallow('textBorderColor'); let c = E(e.getShallow('opacity'), n.opacity); (u === 'inherit' || u === 'auto') && (u = l || null), (h === 'inherit' || h === 'auto') && (h = l || null), o || (u = u || n.color, h = h || n.textBorderColor), u != null && (t.fill = u), h != null && (t.stroke = h); const p = E(e.getShallow('textBorderWidth'), n.textBorderWidth); p != null && (t.lineWidth = p); const d = E(e.getShallow('textBorderType'), n.textBorderType); d != null && (t.lineDash = d); const f = E(e.getShallow('textBorderDashOffset'), n.textBorderDashOffset); f != null && (t.lineDashOffset = f), r || c != null || s || (c = i && i.defaultOpacity), c != null && (t.opacity = c), r || o || t.fill == null && i.inheritColor && (t.fill = i.inheritColor); for (var g = 0; g < Vk.length; g++) { var y = Vk[g]; var v = E(e.getShallow(y), n[y]); v != null && (t[y] = v) } for (var g = 0; g < Fk.length; g++) { var y = Fk[g]; var v = e.getShallow(y); v != null && (t[y] = v) } if (t.verticalAlign == null) { const m = e.getShallow('baseline'); m != null && (t.verticalAlign = m) } if (!a || !i.disableBox) { for (var g = 0; g < Hk.length; g++) { var y = Hk[g]; var v = e.getShallow(y); v != null && (t[y] = v) } const _ = e.getShallow('borderType'); _ != null && (t.borderDash = _), t.backgroundColor !== 'auto' && t.backgroundColor !== 'inherit' || !l || (t.backgroundColor = l), t.borderColor !== 'auto' && t.borderColor !== 'inherit' || !l || (t.borderColor = l) } } function fl (t, e) { const n = e && e.getModel('textStyle'); return G([t.fontStyle || n && n.getShallow('fontStyle') || '', t.fontWeight || n && n.getShallow('fontWeight') || '', (t.fontSize || n && n.getShallow('fontSize') || 12) + 'px', t.fontFamily || n && n.getShallow('fontFamily') || 'sans-serif'].join(' ')) } function gl (t, e, n, i, r) { function o (i) { const o = no(n, a.precision, l, u, i); a.interpolatedValue = i === 1 ? null : o; const h = al({ labelDataIndex: e, labelFetcher: r, defaultText: s ? s(o) : o + '' }, a.statesModels, o); ol(t, h) } var a = Wk(t); if (a.valueAnimation && a.prevValue !== a.value) { var s = a.defaultInterpolatedText; var l = E(a.interpolatedValue, a.prevValue); var u = a.value; t.percent = 0, (a.prevValue == null ? Cs : Is)(t, { percent: 1 }, i, e, null, o) } } function yl (t) { return [t || '', tA++].join('_') } function vl (t) { const e = {}; t.registerSubTypeDefaulter = function (t, n) { const i = io(t); e[i.main] = n }, t.determineSubType = function (n, i) { let r = i.type; if (!r) { const o = io(n).main; t.hasSubTypes(n) && e[o] && (r = e[o](i)) } return r } } function ml (t, e) { function n (t) { const n = {}; const o = []; return y(t, function (a) { const s = i(n, a); const l = s.originalDeps = e(a); const u = r(l, t); s.entryCount = u.length, s.entryCount === 0 && o.push(a), y(u, function (t) { p(s.predecessor, t) < 0 && s.predecessor.push(t); const e = i(n, t); p(e.successor, t) < 0 && e.successor.push(a) }) }), { graph: n, noEntryList: o } } function i (t, e) { return t[e] || (t[e] = { predecessor: [], successor: [] }), t[e] } function r (t, e) { const n = []; return y(t, function (t) { p(e, t) >= 0 && n.push(t) }), n }t.topologicalTravel = function (t, e, i, r) { function o (t) { l[t].entryCount--, l[t].entryCount === 0 && u.push(t) } function a (t) { h[t] = !0, o(t) } if (t.length) { const s = n(e); var l = s.graph; var u = s.noEntryList; var h = {}; for (y(t, function (t) { h[t] = !0 }); u.length;) { const c = u.pop(); const p = l[c]; const d = !!h[c]; d && (i.call(r, c, p.originalDeps.slice()), delete h[c]), y(p.successor, d ? a : o) }y(h, function () { const t = ''; throw new Error(t) }) } } } function _l (t, e) { return l(l({}, t, !0), e, !0) } function xl (t, e) { t = t.toUpperCase(), sA[t] = new Jk(e), aA[t] = e } function wl (t) { if (I(t)) { const e = aA[t.toUpperCase()] || {}; return t === iA || t === rA ? s(e) : l(s(e), s(aA[oA]), !1) } return l(s(t), s(aA[oA]), !1) } function bl (t) { return sA[t] } function Sl () { return sA[oA] } function Ml (t, e) { return t += '', '0000'.substr(0, e - t.length) + t } function Tl (t) { switch (t) { case 'half-year':case 'quarter':return 'month'; case 'week':case 'half-week':return 'day'; case 'half-day':case 'quarter-day':return 'hour'; default:return t } } function Il (t) { return t === Tl(t) } function Cl (t) { switch (t) { case 'year':case 'month':return 'day'; case 'millisecond':return 'millisecond'; default:return 'second' } } function Dl (t, e, n, i) { const r = yr(t); const o = r[Pl(n)](); const a = r[Ol(n)]() + 1; const s = Math.floor((a - 1) / 3) + 1; const l = r[Rl(n)](); const u = r['get' + (n ? 'UTC' : '') + 'Day'](); const h = r[Nl(n)](); const c = (h - 1) % 12 + 1; const p = r[zl(n)](); const d = r[Bl(n)](); const f = r[El(n)](); const g = i instanceof Jk ? i : bl(i || lA) || Sl(); const y = g.getModel('time'); const v = y.get('month'); const m = y.get('monthAbbr'); const _ = y.get('dayOfWeek'); const x = y.get('dayOfWeekAbbr'); return (e || '').replace(/{yyyy}/g, o + '').replace(/{yy}/g, o % 100 + '').replace(/{Q}/g, s + '').replace(/{MMMM}/g, v[a - 1]).replace(/{MMM}/g, m[a - 1]).replace(/{MM}/g, Ml(a, 2)).replace(/{M}/g, a + '').replace(/{dd}/g, Ml(l, 2)).replace(/{d}/g, l + '').replace(/{eeee}/g, _[u]).replace(/{ee}/g, x[u]).replace(/{e}/g, u + '').replace(/{HH}/g, Ml(h, 2)).replace(/{H}/g, h + '').replace(/{hh}/g, Ml(c + '', 2)).replace(/{h}/g, c + '').replace(/{mm}/g, Ml(p, 2)).replace(/{m}/g, p + '').replace(/{ss}/g, Ml(d, 2)).replace(/{s}/g, d + '').replace(/{SSS}/g, Ml(f, 3)).replace(/{S}/g, f + '') } function kl (t, e, n, i, r) { let o = null; if (I(n))o = n; else if (T(n))o = n(t.value, e, { level: t.level }); else { const a = h({}, fA); if (t.level > 0) for (var s = 0; s < vA.length; ++s)a[vA[s]] = '{primary|' + a[vA[s]] + '}'; const l = n ? n.inherit === !1 ? n : c(n, a) : a; const u = Al(t.value, r); if (l[u])o = l[u]; else if (l.inherit) { for (var p = mA.indexOf(u), s = p - 1; s >= 0; --s) if (l[u]) { o = l[u]; break }o = o || a.none } if (M(o)) { let d = t.level == null ? 0 : t.level >= 0 ? t.level : o.length + t.level; d = Math.min(d, o.length - 1), o = o[d] } } return Dl(new Date(t.value), o, r, i) } function Al (t, e) { const n = yr(t); const i = n[Ol(e)]() + 1; const r = n[Rl(e)](); const o = n[Nl(e)](); const a = n[zl(e)](); const s = n[Bl(e)](); const l = n[El(e)](); const u = l === 0; const h = u && s === 0; const c = h && a === 0; const p = c && o === 0; const d = p && r === 1; const f = d && i === 1; return f ? 'year' : d ? 'month' : p ? 'day' : c ? 'hour' : h ? 'minute' : u ? 'second' : 'millisecond' } function Ll (t, e, n) { const i = D(t) ? yr(t) : t; switch (e = e || Al(t, n)) { case 'year':return i[Pl(n)](); case 'half-year':return i[Ol(n)]() >= 6 ? 1 : 0; case 'quarter':return Math.floor((i[Ol(n)]() + 1) / 4); case 'month':return i[Ol(n)](); case 'day':return i[Rl(n)](); case 'half-day':return i[Nl(n)]() / 24; case 'hour':return i[Nl(n)](); case 'minute':return i[zl(n)](); case 'second':return i[Bl(n)](); case 'millisecond':return i[El(n)]() } } function Pl (t) { return t ? 'getUTCFullYear' : 'getFullYear' } function Ol (t) { return t ? 'getUTCMonth' : 'getMonth' } function Rl (t) { return t ? 'getUTCDate' : 'getDate' } function Nl (t) { return t ? 'getUTCHours' : 'getHours' } function zl (t) { return t ? 'getUTCMinutes' : 'getMinutes' } function Bl (t) { return t ? 'getUTCSeconds' : 'getSeconds' } function El (t) { return t ? 'getUTCMilliseconds' : 'getMilliseconds' } function Vl (t) { return t ? 'setUTCFullYear' : 'setFullYear' } function Fl (t) { return t ? 'setUTCMonth' : 'setMonth' } function Hl (t) { return t ? 'setUTCDate' : 'setDate' } function Wl (t) { return t ? 'setUTCHours' : 'setHours' } function Gl (t) { return t ? 'setUTCMinutes' : 'setMinutes' } function Xl (t) { return t ? 'setUTCSeconds' : 'setSeconds' } function Yl (t) { return t ? 'setUTCMilliseconds' : 'setMilliseconds' } function Ul (t, e, n, i, r, o, a, s) { const l = new aD({ style: { text: t, font: e, align: n, verticalAlign: i, padding: r, rich: o, overflow: a ? 'truncate' : null, lineHeight: s } }); return l.getBoundingRect() } function Zl (t) { if (!Sr(t)) return I(t) ? t : '-'; const e = (t + '').split('.'); return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (e.length > 1 ? '.' + e[1] : '') } function jl (t, e) { return t = (t || '').toLowerCase().replace(/-(.)/g, function (t, e) { return e.toUpperCase() }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t } function ql (t, e, n) { function i (t) { return t && G(t) ? t : '-' } function r (t) { return !(t == null || isNaN(t) || !isFinite(t)) } const o = '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}'; const a = e === 'time'; const s = t instanceof Date; if (a || s) { const l = a ? yr(t) : t; if (!isNaN(+l)) return Dl(l, o, n); if (s) return '-' } if (e === 'ordinal') return C(t) ? i(t) : D(t) && r(t) ? t + '' : '-'; const u = br(t); return r(u) ? Zl(u) : C(t) ? i(t) : typeof t === 'boolean' ? t + '' : '-' } function Kl (t, e, n) { M(e) || (e = [e]); const i = e.length; if (!i) return ''; for (var r = e[0].$vars || [], o = 0; o < r.length; o++) { const a = xA[o]; t = t.replace(wA(a), wA(a, 0)) } for (let s = 0; i > s; s++) for (let l = 0; l < r.length; l++) { const u = e[s][r[l]]; t = t.replace(wA(xA[l], s), n ? Ce(u) : u) } return t } function $l (t, e, n) { return y(e, function (e, i) { t = t.replace('{' + i + '}', n ? Ce(e) : e) }), t } function Ql (t, e) { const n = I(t) ? { color: t, extraCssText: e } : t || {}; const i = n.color; const r = n.type; e = n.extraCssText; const o = n.renderMode || 'html'; if (!i) return ''; if (o === 'html') return r === 'subItem' ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Ce(i) + ';' + (e || '') + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Ce(i) + ';' + (e || '') + '"></span>'; const a = n.markerId || 'markerX'; return { renderMode: o, content: '{' + a + '|}  ', style: r === 'subItem' ? { width: 4, height: 4, borderRadius: 2, backgroundColor: i } : { width: 10, height: 10, borderRadius: 5, backgroundColor: i } } } function Jl (t, e, n) { (t === 'week' || t === 'month' || t === 'quarter' || t === 'half-year' || t === 'year') && (t = 'MM-dd\nyyyy'); const i = yr(e); const r = n ? 'getUTC' : 'get'; const o = i[r + 'FullYear'](); const a = i[r + 'Month']() + 1; const s = i[r + 'Date'](); const l = i[r + 'Hours'](); const u = i[r + 'Minutes'](); const h = i[r + 'Seconds'](); const c = i[r + 'Milliseconds'](); return t = t.replace('MM', Ml(a, 2)).replace('M', a).replace('yyyy', o).replace('yy', Ml(o % 100 + '', 2)).replace('dd', Ml(s, 2)).replace('d', s).replace('hh', Ml(l, 2)).replace('h', l).replace('mm', Ml(u, 2)).replace('m', u).replace('ss', Ml(h, 2)).replace('s', h).replace('SSS', Ml(c, 3)) } function tu (t) { return t ? t.charAt(0).toUpperCase() + t.substr(1) : t } function eu (t, e) { return e = e || 'transparent', I(t) ? t : k(t) ? t.colorStops && (t.colorStops[0] || {}).color || e : e } function nu (t, e) { if (e === '_blank' || e === 'blank') { const n = window.open(); n.opener = null, n.location.href = t } else window.open(t, e) } function iu (t, e, n, i, r) { let o = 0; let a = 0; i == null && (i = 1 / 0), r == null && (r = 1 / 0); let s = 0; e.eachChild(function (l, u) { let h; let c; const p = l.getBoundingRect(); const d = e.childAt(u + 1); const f = d && d.getBoundingRect(); if (t === 'horizontal') { const g = p.width + (f ? -f.x + p.x : 0); h = o + g, h > i || l.newline ? (o = 0, h = g, a += s + n, s = p.height) : s = Math.max(s, p.height) } else { const y = p.height + (f ? -f.y + p.y : 0); c = a + y, c > r || l.newline ? (o += s + n, a = 0, c = y, s = p.width) : s = Math.max(s, p.width) }l.newline || (l.x = o, l.y = a, l.markRedraw(), t === 'horizontal' ? o = h + n : a = c + n) }) } function ru (t, e, n) { n = _A(n || 0); const i = e.width; const r = e.height; let o = or(t.left, i); let a = or(t.top, r); const s = or(t.right, i); const l = or(t.bottom, r); let u = or(t.width, i); let h = or(t.height, r); const c = n[2] + n[0]; const p = n[1] + n[3]; const d = t.aspect; switch (isNaN(u) && (u = i - s - p - o), isNaN(h) && (h = r - l - c - a), d != null && (isNaN(u) && isNaN(h) && (d > i / r ? u = 0.8 * i : h = 0.8 * r), isNaN(u) && (u = d * h), isNaN(h) && (h = u / d)), isNaN(o) && (o = i - s - u - p), isNaN(a) && (a = r - l - h - c), t.left || t.right) { case 'center':o = i / 2 - u / 2 - n[3]; break; case 'right':o = i - u - p } switch (t.top || t.bottom) { case 'middle':case 'center':a = r / 2 - h / 2 - n[0]; break; case 'bottom':a = r - h - c }o = o || 0, a = a || 0, isNaN(u) && (u = i - p - o - (s || 0)), isNaN(h) && (h = r - c - a - (l || 0)); const f = new $M(o + n[3], a + n[0], u, h); return f.margin = n, f } function ou (t, e, n, i, r, o) { const a = !r || !r.hv || r.hv[0]; const s = !r || !r.hv || r.hv[1]; const l = r && r.boundingMode || 'all'; if (o = o || t, o.x = t.x, o.y = t.y, !a && !s) return !1; let u; if (l === 'raw')u = t.type === 'group' ? new $M(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect(); else if (u = t.getBoundingRect(), t.needLocalTransform()) { const h = t.getLocalTransform(); u = u.clone(), u.applyTransform(h) } const p = ru(c({ width: u.width, height: u.height }, e), n, i); const d = a ? p.x - u.x : 0; const f = s ? p.y - u.y : 0; return l === 'raw' ? (o.x = d, o.y = f) : (o.x += d, o.y += f), o === t && t.markRedraw(), !0 } function au (t, e) { return t[MA[e][0]] != null || t[MA[e][1]] != null && t[MA[e][2]] != null } function su (t) { const e = t.layoutMode || t.constructor.layoutMode; return k(e) ? e : e ? { type: e } : null } function lu (t, e, n) { function i (n, i) { const a = {}; let l = 0; const u = {}; let h = 0; const c = 2; if (bA(n, function (e) { u[e] = t[e] }), bA(n, function (t) { r(e, t) && (a[t] = u[t] = e[t]), o(a, t) && l++, o(u, t) && h++ }), s[i]) return o(e, n[1]) ? u[n[2]] = null : o(e, n[2]) && (u[n[1]] = null), u; if (h !== c && l) { if (l >= c) return a; for (let p = 0; p < n.length; p++) { const d = n[p]; if (!r(a, d) && r(t, d)) { a[d] = t[d]; break } } return a } return u } function r (t, e) { return t.hasOwnProperty(e) } function o (t, e) { return t[e] != null && t[e] !== 'auto' } function a (t, e, n) { bA(t, function (t) { e[t] = n[t] }) } var s = n && n.ignoreSize; !M(s) && (s = [s, s]); const l = i(MA[0], 0); const u = i(MA[1], 1); a(MA[0], t, l), a(MA[1], t, u) } function uu (t) { return hu({}, t) } function hu (t, e) { return e && t && bA(SA, function (n) { e.hasOwnProperty(n) && (t[n] = e[n]) }), t } function cu (t) { let e = []; return y(CA.getClassesByMainType(t), function (t) { e = e.concat(t.dependencies || t.prototype.dependencies || []) }), e = v(e, function (t) { return io(t).main }), t !== 'dataset' && p(e, 'dataset') <= 0 && e.unshift('dataset'), e } function pu (t) { GA(t).datasetMap = Z() } function du (t, e, n) { function i (t, e, n) { for (let i = 0; n > i; i++)t.push(e + i) } function r (t) { const e = t.dimsDef; return e ? e.length : 1 } const o = {}; const a = fu(e); if (!a || !t) return o; let s; let l; const u = []; const h = []; const c = e.ecModel; const p = GA(c).datasetMap; const d = a.uid + '_' + n.seriesLayoutBy; t = t.slice(), y(t, function (e, n) { const i = k(e) ? e : t[n] = { name: e }; i.type === 'ordinal' && s == null && (s = n, l = r(i)), o[i.name] = [] }); const f = p.get(d) || p.set(d, { categoryWayDim: l, valueWayDim: 0 }); return y(t, function (t, e) { const n = t.name; const a = r(t); if (s == null) { var l = f.valueWayDim; i(o[n], l, a), i(h, l, a), f.valueWayDim += a } else if (s === e)i(o[n], 0, a), i(u, 0, a); else { var l = f.categoryWayDim; i(o[n], l, a), i(h, l, a), f.categoryWayDim += a } }), u.length && (o.itemName = u), h.length && (o.seriesName = h), o } function fu (t) { const e = t.get('data', !0); return e ? void 0 : Qr(t.ecModel, 'dataset', { index: t.get('datasetIndex', !0), id: t.get('datasetId', !0) }, HI).models[0] } function gu (t) { return t.get('transform', !0) || t.get('fromTransformResult', !0) ? Qr(t.ecModel, 'dataset', { index: t.get('fromDatasetIndex', !0), id: t.get('fromDatasetId', !0) }, HI).models : [] } function yu (t, e) { return vu(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e) } function vu (t, e, n, i, r, o) { function a (t) { const e = I(t); return t != null && isFinite(t) && t !== '' ? e ? WA.Might : WA.Not : e && t !== '-' ? WA.Must : void 0 } let s; const l = 5; if (L(t)) return WA.Not; let u, h; if (i) { const c = i[o]; k(c) ? (u = c.name, h = c.type) : I(c) && (u = c) } if (h != null) return h === 'ordinal' ? WA.Must : WA.Not; if (e === NA) { const p = t; if (n === HA) { for (var d = p[o], f = 0; f < (d || []).length && l > f; f++) if ((s = a(d[r + f])) != null) return s } else for (var f = 0; f < p.length && l > f; f++) { const g = p[r + f]; if (g && (s = a(g[o])) != null) return s } } else if (e === zA) { const y = t; if (!u) return WA.Not; for (var f = 0; f < y.length && l > f; f++) { var v = y[f]; if (v && (s = a(v[u])) != null) return s } } else if (e === BA) { const m = t; if (!u) return WA.Not; var d = m[u]; if (!d || L(d)) return WA.Not; for (var f = 0; f < d.length && l > f; f++) if ((s = a(d[f])) != null) return s } else if (e === RA) for (var _ = t, f = 0; f < _.length && l > f; f++) { var v = _[f]; const x = Lr(v); if (!M(x)) return WA.Not; if ((s = a(x[o])) != null) return s } return WA.Not } function mu (t, e) { W(XA.get(t) == null && e), XA.set(t, e) } function _u (t, e, n) { const i = XA.get(e); if (!i) return n; const r = i(t); return r ? n.concat(r) : n } function xu (t, e) { for (var n = t.length, i = 0; n > i; i++) if (t[i].length > e) return t[i]; return t[n - 1] } function wu (t, e, n, i, r, o, a) { o = o || t; const s = e(o); const l = s.paletteIdx || 0; const u = s.paletteNameMap = s.paletteNameMap || {}; if (u.hasOwnProperty(r)) return u[r]; let h = a != null && i ? xu(i, a) : n; if (h = h || n, h && h.length) { const c = h[l]; return r && (u[r] = c), s.paletteIdx = (l + 1) % h.length, c } } function bu (t, e) { e(t).paletteIdx = 0, e(t).paletteNameMap = {} } function Su (t, e) { if (e) { const n = e.seriesIndex; const i = e.seriesId; const r = e.seriesName; return n != null && t.componentIndex !== n || i != null && t.id !== i || r != null && t.name !== r } } function Mu (t, e) { const n = t.color && !t.colorLayer; y(e, function (e, i) { i === 'colorLayer' && n || CA.hasClass(i) || (typeof e === 'object' ? t[i] = t[i] ? l(t[i], e, !1) : s(e) : t[i] == null && (t[i] = e)) }) } function Tu (t, e, n) { if (M(e)) { const i = Z(); return y(e, function (t) { if (t != null) { const e = Wr(t, null); e != null && i.set(t, !0) } }), _(n, function (e) { return e && i.get(e[t]) }) } const r = Wr(e, null); return _(n, function (e) { return e && r != null && e[t] === r }) } function Iu (t, e) { return e.hasOwnProperty('subType') ? _(t, function (t) { return t && t.subType === e.subType }) : t } function Cu (t) { const e = Z(); return t && y(kr(t.replaceMerge), function (t) { e.set(t, !0) }), { replaceMergeMainTypeMap: e } } function Du (t, e, n) { function i (t) { y(e, function (e) { e(t, n) }) } let r; let o; const a = []; const s = t.baseOption; const l = t.timeline; const u = t.options; const h = t.media; const c = !!t.media; const p = !!(u || l || s && s.timeline); return s ? (o = s, o.timeline || (o.timeline = l)) : ((p || c) && (t.options = t.media = null), o = t), c && M(h) && y(h, function (t) { t && t.option && (t.query ? a.push(t) : r || (r = t)) }), i(o), y(u, function (t) { return i(t) }), y(a, function (t) { return i(t.option) }), { baseOption: o, timelineOptions: u || [], mediaDefault: r, mediaList: a } } function ku (t, e, n) { const i = { width: e, height: n, aspectratio: e / n }; let r = !0; return y(t, function (t, e) { const n = e.match(aL); if (n && n[1] && n[2]) { const o = n[1]; const a = n[2].toLowerCase(); Au(i[a], t, o) || (r = !1) } }), r } function Au (t, e, n) { return n === 'min' ? t >= e : n === 'max' ? e >= t : t === e } function Lu (t, e) { return t.join(',') === e.join(',') } function Pu (t) { const e = t && t.itemStyle; if (e) for (let n = 0, i = hL.length; i > n; n++) { const r = hL[n]; const o = e.normal; const a = e.emphasis; o && o[r] && (t[r] = t[r] || {}, t[r].normal ? l(t[r].normal, o[r]) : t[r].normal = o[r], o[r] = null), a && a[r] && (t[r] = t[r] || {}, t[r].emphasis ? l(t[r].emphasis, a[r]) : t[r].emphasis = a[r], a[r] = null) } } function Ou (t, e, n) { if (t && t[e] && (t[e].normal || t[e].emphasis)) { const i = t[e].normal; const r = t[e].emphasis; i && (n ? (t[e].normal = t[e].emphasis = null, c(t[e], i)) : t[e] = i), r && (t.emphasis = t.emphasis || {}, t.emphasis[e] = r, r.focus && (t.emphasis.focus = r.focus), r.blurScope && (t.emphasis.blurScope = r.blurScope)) } } function Ru (t) { Ou(t, 'itemStyle'), Ou(t, 'lineStyle'), Ou(t, 'areaStyle'), Ou(t, 'label'), Ou(t, 'labelLine'), Ou(t, 'upperLabel'), Ou(t, 'edgeLabel') } function Nu (t, e) { const n = uL(t) && t[e]; const i = uL(n) && n.textStyle; if (i) for (let r = 0, o = VI.length; o > r; r++) { const a = VI[r]; i.hasOwnProperty(a) && (n[a] = i[a]) } } function zu (t) { t && (Ru(t), Nu(t, 'label'), t.emphasis && Nu(t.emphasis, 'label')) } function Bu (t) { if (uL(t)) { Pu(t), Ru(t), Nu(t, 'label'), Nu(t, 'upperLabel'), Nu(t, 'edgeLabel'), t.emphasis && (Nu(t.emphasis, 'label'), Nu(t.emphasis, 'upperLabel'), Nu(t.emphasis, 'edgeLabel')); let e = t.markPoint; e && (Pu(e), zu(e)); let n = t.markLine; n && (Pu(n), zu(n)); const i = t.markArea; i && zu(i); let r = t.data; if (t.type === 'graph') { r = r || t.nodes; const o = t.links || t.edges; if (o && !L(o)) for (var a = 0; a < o.length; a++)zu(o[a]); y(t.categories, function (t) { Ru(t) }) } if (r && !L(r)) for (var a = 0; a < r.length; a++)zu(r[a]); if (e = t.markPoint, e && e.data) for (var s = e.data, a = 0; a < s.length; a++)zu(s[a]); if (n = t.markLine, n && n.data) for (var l = n.data, a = 0; a < l.length; a++)M(l[a]) ? (zu(l[a][0]), zu(l[a][1])) : zu(l[a]); t.type === 'gauge' ? (Nu(t, 'axisLabel'), Nu(t, 'title'), Nu(t, 'detail')) : t.type === 'treemap' ? (Ou(t.breadcrumb, 'itemStyle'), y(t.levels, function (t) { Ru(t) })) : t.type === 'tree' && Ru(t.leaves) } } function Eu (t) { return M(t) ? t : t ? [t] : [] } function Vu (t) { return (M(t) ? t[0] : t) || {} } function Fu (t, e) { lL(Eu(t.series), function (t) { uL(t) && Bu(t) }); const n = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar']; e && n.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis'), lL(n, function (e) { lL(Eu(t[e]), function (t) { t && (Nu(t, 'axisLabel'), Nu(t.axisPointer, 'label')) }) }), lL(Eu(t.parallel), function (t) { const e = t && t.parallelAxisDefault; Nu(e, 'axisLabel'), Nu(e && e.axisPointer, 'label') }), lL(Eu(t.calendar), function (t) { Ou(t, 'itemStyle'), Nu(t, 'dayLabel'), Nu(t, 'monthLabel'), Nu(t, 'yearLabel') }), lL(Eu(t.radar), function (t) { Nu(t, 'name'), t.name && t.axisName == null && (t.axisName = t.name, delete t.name), t.nameGap != null && t.axisNameGap == null && (t.axisNameGap = t.nameGap, delete t.nameGap) }), lL(Eu(t.geo), function (t) { uL(t) && (zu(t), lL(Eu(t.regions), function (t) { zu(t) })) }), lL(Eu(t.timeline), function (t) { zu(t), Ou(t, 'label'), Ou(t, 'itemStyle'), Ou(t, 'controlStyle', !0); const e = t.data; M(e) && y(e, function (t) { k(t) && (Ou(t, 'label'), Ou(t, 'itemStyle')) }) }), lL(Eu(t.toolbox), function (t) { Ou(t, 'iconStyle'), lL(t.feature, function (t) { Ou(t, 'iconStyle') }) }), Nu(Vu(t.axisPointer), 'label'), Nu(Vu(t.tooltip).axisPointer, 'label') } function Hu (t, e) { for (var n = e.split(','), i = t, r = 0; r < n.length && (i = i && i[n[r]], i != null); r++);return i } function Wu (t, e, n, i) { for (var r, o = e.split(','), a = t, s = 0; s < o.length - 1; s++)r = o[s], a[r] == null && (a[r] = {}), a = a[r]; (i || a[o[s]] == null) && (a[o[s]] = n) } function Gu (t) { t && y(cL, function (e) { e[0] in t && !(e[1] in t) && (t[e[1]] = t[e[0]]) }) } function Xu (t) { const e = t && t.itemStyle; if (e) for (let n = 0; n < dL.length; n++) { const i = dL[n][1]; const r = dL[n][0]; e[i] != null && (e[r] = e[i]) } } function Yu (t) { t && t.alignTo === 'edge' && t.margin != null && t.edgeDistance == null && (t.edgeDistance = t.margin) } function Uu (t) {
    t && t.downplay && !t.blur && (t.blur = t.downplay)
  } function Zu (t) { t && t.focusNodeAdjacency != null && (t.emphasis = t.emphasis || {}, t.emphasis.focus == null && (t.emphasis.focus = 'adjacency')) } function ju (t, e) { if (t) for (let n = 0; n < t.length; n++)e(t[n]), t[n] && ju(t[n].children, e) } function qu (t, e) { Fu(t, e), t.series = kr(t.series), y(t.series, function (t) { if (k(t)) { const e = t.type; if (e === 'line')t.clipOverflow != null && (t.clip = t.clipOverflow); else if (e === 'pie' || e === 'gauge') { t.clockWise != null && (t.clockwise = t.clockWise), Yu(t.label); var n = t.data; if (n && !L(n)) for (var i = 0; i < n.length; i++)Yu(n[i]); t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && (t.emphasis.scaleSize = t.hoverOffset)) } else if (e === 'gauge') { const r = Hu(t, 'pointer.color'); r != null && Wu(t, 'itemStyle.color', r) } else if (e === 'bar') { Xu(t), Xu(t.backgroundStyle), Xu(t.emphasis); var n = t.data; if (n && !L(n)) for (var i = 0; i < n.length; i++) typeof n[i] === 'object' && (Xu(n[i]), Xu(n[i] && n[i].emphasis)) } else if (e === 'sunburst') { const o = t.highlightPolicy; o && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = o)), Uu(t), ju(t.data, Uu) } else e === 'graph' || e === 'sankey' ? Zu(t) : e === 'map' && (t.mapType && !t.map && (t.map = t.mapType), t.mapLocation && c(t, t.mapLocation)); t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && (t.emphasis.scale = t.hoverAnimation)), Gu(t) } }), t.dataRange && (t.visualMap = t.dataRange), y(pL, function (e) { let n = t[e]; n && (M(n) || (n = [n]), y(n, function (t) { Gu(t) })) }) } function Ku (t) { const e = Z(); t.eachSeries(function (t) { const n = t.get('stack'); if (n) { const i = e.get(n) || e.set(n, []); const r = t.getData(); const o = { stackResultDimension: r.getCalculationInfo('stackResultDimension'), stackedOverDimension: r.getCalculationInfo('stackedOverDimension'), stackedDimension: r.getCalculationInfo('stackedDimension'), stackedByDimension: r.getCalculationInfo('stackedByDimension'), isStackedByIndex: r.getCalculationInfo('isStackedByIndex'), data: r, seriesModel: t }; if (!o.stackedDimension || !o.isStackedByIndex && !o.stackedByDimension) return; i.length && r.setCalculationInfo('stackedOnSeries', i[i.length - 1].seriesModel), i.push(o) } }), e.each($u) } function $u (t) { y(t, function (e, n) { const i = []; const r = [0 / 0, 0 / 0]; const o = [e.stackResultDimension, e.stackedOverDimension]; const a = e.data; const s = e.isStackedByIndex; const l = e.seriesModel.get('stackStrategy') || 'samesign'; a.modify(o, function (o, u, h) { let c = a.get(e.stackedDimension, h); if (isNaN(c)) return r; let p, d; s ? d = a.getRawIndex(h) : p = a.get(e.stackedByDimension, h); for (var f = 0 / 0, g = n - 1; g >= 0; g--) { const y = t[g]; if (s || (d = y.data.rawIndexOf(y.stackedByDimension, p)), d >= 0) { const v = y.data.getByRawIndex(y.stackResultDimension, d); if (l === 'all' || l === 'positive' && v > 0 || l === 'negative' && v < 0 || l === 'samesign' && c >= 0 && v > 0 || l === 'samesign' && c <= 0 && v < 0) { c = dr(c, v), f = v; break } } } return i[0] = c, i[1] = f, i }) }) } function Qu (t) { return t instanceof fL } function Ju (t, e, n) { n = n || nh(t); const i = e.seriesLayoutBy; const r = ih(t, n, i, e.sourceHeader, e.dimensions); const o = new fL({ data: t, sourceFormat: n, seriesLayoutBy: i, dimensionsDefine: r.dimensionsDefine, startIndex: r.startIndex, dimensionsDetectedCount: r.dimensionsDetectedCount, metaRawOption: s(e) }); return o } function th (t) { return new fL({ data: t, sourceFormat: L(t) ? EA : RA }) } function eh (t) { return new fL({ data: t.data, sourceFormat: t.sourceFormat, seriesLayoutBy: t.seriesLayoutBy, dimensionsDefine: s(t.dimensionsDefine), startIndex: t.startIndex, dimensionsDetectedCount: t.dimensionsDetectedCount }) } function nh (t) { let e = VA; if (L(t))e = EA; else if (M(t)) { t.length === 0 && (e = NA); for (let n = 0, i = t.length; i > n; n++) { const r = t[n]; if (r != null) { if (M(r)) { e = NA; break } if (k(r)) { e = zA; break } } } } else if (k(t)) for (const o in t) if ($(t, o) && g(t[o])) { e = BA; break } return e } function ih (t, e, n, i, r) { let o, a; if (!t) return { dimensionsDefine: oh(r), startIndex: a, dimensionsDetectedCount: o }; if (e === NA) { const s = t; i === 'auto' || i == null ? ah(function (t) { t != null && t !== '-' && (I(t) ? a == null && (a = 1) : a = 0) }, n, s, 10) : a = D(i) ? i : i ? 1 : 0, r || a !== 1 || (r = [], ah(function (t, e) { r[e] = t != null ? t + '' : '' }, n, s, 1 / 0)), o = r ? r.length : n === HA ? s.length : s[0] ? s[0].length : null } else if (e === zA)r || (r = rh(t)); else if (e === BA)r || (r = [], y(t, function (t, e) { r.push(e) })); else if (e === RA) { const l = Lr(t[0]); o = M(l) && l.length || 1 } return { startIndex: a, dimensionsDefine: oh(r), dimensionsDetectedCount: o } } function rh (t) { for (var e, n = 0; n < t.length && !(e = t[n++]););return e ? w(e) : void 0 } function oh (t) { if (t) { const e = Z(); return v(t, function (t) { t = k(t) ? t : { name: t }; const n = { name: t.name, displayName: t.displayName, type: t.type }; if (n.name == null) return n; n.name += '', n.displayName == null && (n.displayName = n.name); const i = e.get(n.name); return i ? n.name += '-' + i.count++ : e.set(n.name, { count: 1 }), n }) } } function ah (t, e, n, i) { if (e === HA) for (var r = 0; r < n.length && i > r; r++)t(n[r] ? n[r][0] : null, r); else for (var o = n[0] || [], r = 0; r < o.length && i > r; r++)t(o[r], r) } function sh (t) { const e = t.sourceFormat; return e === zA || e === BA } function lh (t, e) { const n = vL[ch(t, e)]; return n } function uh (t, e) { const n = _L[ch(t, e)]; return n } function hh (t) { const e = wL[t]; return e } function ch (t, e) { return t === NA ? t + '_' + e : t } function ph (t, e, n) { if (t) { const i = t.getRawDataItem(e); if (i != null) { const r = t.getStore(); const o = r.getSource().sourceFormat; if (n != null) { const a = t.getDimensionIndex(n); const s = r.getDimensionProperty(a); return hh(o)(i, a, s) } let l = i; return o === RA && (l = Lr(i)), l } } } function dh (t) { let e, n; return k(t) ? t.type && (n = t) : e = t, { text: e, frag: n } } function fh (t) { return new ML(t) } function gh (t, e) { const n = e && e.type; return n === 'ordinal' ? t : (n !== 'time' || D(t) || t == null || t === '-' || (t = +yr(t)), t == null || t === '' ? 0 / 0 : +t) } function yh (t, e) { const n = new DL(); const i = t.data; const r = n.sourceFormat = t.sourceFormat; const o = t.startIndex; const a = ''; t.seriesLayoutBy !== FA && Cr(a); const s = []; const l = {}; const u = t.dimensionsDefine; if (u)y(u, function (t, e) { const n = t.name; const i = { index: e, name: n, displayName: t.displayName }; if (s.push(i), n != null) { const r = ''; $(l, n) && Cr(r), l[n] = i } }); else for (let h = 0; h < t.dimensionsDetectedCount; h++)s.push({ index: h }); const c = lh(r, FA); e.__isBuiltIn && (n.getRawDataItem = function (t) { return c(i, o, s, t) }, n.getRawData = gM(vh, null, t)), n.cloneRawData = gM(mh, null, t); const p = uh(r, FA); n.count = gM(p, null, i, o, s); const d = hh(r); n.retrieveValue = function (t, e) { const n = c(i, o, s, t); return f(n, e) }; var f = n.retrieveValueFromItem = function (t, e) { if (t != null) { const n = s[e]; return n ? d(t, e, n.name) : void 0 } }; return n.getDimensionInfo = gM(_h, null, s, l), n.cloneAllDimensionInfo = gM(xh, null, s), n } function vh (t) { const e = t.sourceFormat; if (!Mh(e)) { const n = ''; Cr(n) } return t.data } function mh (t) { const e = t.sourceFormat; const n = t.data; if (!Mh(e)) { const i = ''; Cr(i) } if (e === NA) { for (var r = [], o = 0, a = n.length; a > o; o++)r.push(n[o].slice()); return r } if (e === zA) { for (var r = [], o = 0, a = n.length; a > o; o++)r.push(h({}, n[o])); return r } } function _h (t, e, n) { return n != null ? D(n) || !isNaN(n) && !$(e, n) ? t[n] : $(e, n) ? e[n] : void 0 : void 0 } function xh (t) { return s(t) } function wh (t) { t = s(t); let e = t.type; const n = ''; e || Cr(n); const i = e.split(':'); i.length !== 2 && Cr(n); let r = !1; i[0] === 'echarts' && (e = i[1], r = !0), t.__isBuiltIn = r, kL.set(e, t) } function bh (t, e, n) { const i = kr(t); const r = i.length; const o = ''; r || Cr(o); for (let a = 0, s = r; s > a; a++) { const l = i[a]; e = Sh(l, e, n, r === 1 ? null : a), a !== s - 1 && (e.length = Math.max(e.length, 1)) } return e } function Sh (t, e) { const n = ''; e.length || Cr(n), k(t) || Cr(n); const i = t.type; const r = kL.get(i); r || Cr(n); const o = v(e, function (t) { return yh(t, r) }); const a = kr(r.transform({ upstream: o[0], upstreamList: o, config: s(t.config) })); return v(a, function (t, n) { const i = ''; k(t) || Cr(i), t.data || Cr(i); const r = nh(t.data); Mh(r) || Cr(i); let o; const a = e[0]; if (a && n === 0 && !t.dimensions) { const s = a.startIndex; s && (t.data = a.data.slice(0, s).concat(t.data)), o = { seriesLayoutBy: FA, sourceHeader: s, dimensions: a.metaRawOption.dimensions } } else o = { seriesLayoutBy: FA, sourceHeader: 0, dimensions: t.dimensions }; return Ju(t.data, o, null) }) } function Mh (t) { return t === NA || t === zA } function Th (t) { return t > 65535 ? LL : PL } function Ih () { return [1 / 0, -1 / 0] } function Ch (t) { const e = t.constructor; return e === Array ? t.slice() : new e(t) } function Dh (t, e, n, i, r) { const o = NL[n || 'float']; if (r) { const a = t[e]; const s = a && a.length; if (s !== i) { for (var l = new o(i), u = 0; s > u; u++)l[u] = a[u]; t[e] = l } } else t[e] = new o(i) } function kh (t) { const e = t.option.transform; e && X(t.option.transform) } function Ah (t) { return t.mainType === 'series' } function Lh (t) { throw new Error(t) } function Ph (t, e) { const n = t.color || '#6e7079'; const i = t.fontSize || 12; const r = t.fontWeight || '400'; const o = t.color || '#464646'; const a = t.fontSize || 14; const s = t.fontWeight || '900'; return e === 'html' ? { nameStyle: 'font-size:' + Ce(i + '') + 'px;color:' + Ce(n) + ';font-weight:' + Ce(r + ''), valueStyle: 'font-size:' + Ce(a + '') + 'px;color:' + Ce(o) + ';font-weight:' + Ce(s + '') } : { nameStyle: { fontSize: i, fill: n, fontWeight: r }, valueStyle: { fontSize: a, fill: o, fontWeight: s } } } function Oh (t, e) { return e.type = t, e } function Rh (t) { return t.type === 'section' } function Nh (t) { return Rh(t) ? Bh : Eh } function zh (t) { if (Rh(t)) { let e = 0; const n = t.blocks.length; const i = n > 1 || n > 0 && !t.noHeader; return y(t.blocks, function (t) { const n = zh(t); n >= e && (e = n + +(i && (!n || Rh(t) && !t.noHeader))) }), e } return 0 } function Bh (t, e, n, i) { const r = e.noHeader; const o = Fh(zh(e)); const a = []; let s = e.blocks || []; W(!s || M(s)), s = s || []; const l = t.orderMode; if (e.sortBlocks && l) { s = s.slice(); const u = { valueAsc: 'asc', valueDesc: 'desc' }; if ($(u, l)) { const c = new CL(u[l], null); s.sort(function (t, e) { return c.evaluate(t.sortParam, e.sortParam) }) } else l === 'seriesDesc' && s.reverse() }y(s, function (n, r) { const s = e.valueFormatter; const l = Nh(n)(s ? h(h({}, t), { valueFormatter: s }) : t, n, r > 0 ? o.html : 0, i); l != null && a.push(l) }); const p = t.renderMode === 'richText' ? a.join(o.richText) : Hh(a.join(''), r ? n : o.html); if (r) return p; const d = ql(e.header, 'ordinal', t.useUTC); const f = Ph(i, t.renderMode).nameStyle; return t.renderMode === 'richText' ? Xh(t, d, f) + o.richText + p : Hh('<div style="' + f + ';' + EL + ';">' + Ce(d) + '</div>' + p, n) } function Eh (t, e, n, i) { const r = t.renderMode; const o = e.noName; const a = e.noValue; const s = !e.markerType; const l = e.name; const u = t.useUTC; const h = e.valueFormatter || t.valueFormatter || function (t) { return t = M(t) ? t : [t], v(t, function (t, e) { return ql(t, M(d) ? d[e] : d, u) }) }; if (!o || !a) { const c = s ? '' : t.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || '#333', r); const p = o ? '' : ql(l, 'ordinal', u); var d = e.valueType; const f = a ? [] : h(e.value); const g = !s || !o; const y = !s && o; const m = Ph(i, r); const _ = m.nameStyle; const x = m.valueStyle; return r === 'richText' ? (s ? '' : c) + (o ? '' : Xh(t, p, _)) + (a ? '' : Yh(t, f, g, y, x)) : Hh((s ? '' : c) + (o ? '' : Wh(p, !s, _)) + (a ? '' : Gh(f, g, y, x)), n) } } function Vh (t, e, n, i, r, o) { if (t) { const a = Nh(t); const s = { useUTC: r, renderMode: n, orderMode: i, markupStyleCreator: e, valueFormatter: t.valueFormatter }; return a(s, t, 0, o) } } function Fh (t) { return { html: VL[t], richText: FL[t] } } function Hh (t, e) { const n = '<div style="clear:both"></div>'; const i = 'margin: ' + e + 'px 0 0'; return '<div style="' + i + ';' + EL + ';">' + t + n + '</div>' } function Wh (t, e, n) { const i = e ? 'margin-left:2px' : ''; return '<span style="' + n + ';' + i + '">' + Ce(t) + '</span>' } function Gh (t, e, n, i) { const r = n ? '10px' : '20px'; const o = e ? 'float:right;margin-left:' + r : ''; return t = M(t) ? t : [t], '<span style="' + o + ';' + i + '">' + v(t, function (t) { return Ce(t) }).join('&nbsp;&nbsp;') + '</span>' } function Xh (t, e, n) { return t.markupStyleCreator.wrapRichTextStyle(e, n) } function Yh (t, e, n, i, r) { const o = [r]; const a = i ? 10 : 20; return n && o.push({ padding: [0, 0, 0, a], align: 'right' }), t.markupStyleCreator.wrapRichTextStyle(M(e) ? e.join('  ') : e, o) } function Uh (t, e) { const n = t.getData().getItemVisual(e, 'style'); const i = n[t.visualDrawType]; return eu(i) } function Zh (t, e) { const n = t.get('padding'); return n != null ? n : e === 'richText' ? [8, 10] : 10 } function jh (t) { let e; let n; let i; let r; const o = t.series; const a = t.dataIndex; const s = t.multipleSeries; const l = o.getData(); const u = l.mapDimensionsAll('defaultedTooltip'); const h = u.length; const c = o.getRawValue(a); const p = M(c); const d = Uh(o, a); if (h > 1 || p && !h) { const f = qh(c, o, a, u, d); e = f.inlineValues, n = f.inlineValueTypes, i = f.blocks, r = f.inlineValues[0] } else if (h) { const g = l.getDimensionInfo(u[0]); r = e = ph(l, a, u[0]), n = g.type } else r = e = p ? c[0] : c; const y = Gr(o); const v = y && o.name || ''; const m = l.getName(a); const _ = s ? v : m; return Oh('section', { header: v, noHeader: s || !y, sortParam: r, blocks: [Oh('nameValue', { markerType: 'item', markerColor: d, name: _, noName: !G(_), value: e, valueType: n })].concat(i || []) }) } function qh (t, e, n, i, r) { function o (t, e) { const n = a.getDimensionInfo(e); n && n.otherDims.tooltip !== !1 && (s ? h.push(Oh('nameValue', { markerType: 'subItem', markerColor: r, name: n.displayName, value: t, valueType: n.type })) : (l.push(t), u.push(n.type))) } var a = e.getData(); var s = m(t, function (t, e, n) { const i = a.getDimensionInfo(n); return t = t || i && i.tooltip !== !1 && i.displayName != null }, !1); var l = []; var u = []; var h = []; return i.length ? y(i, function (t) { o(ph(a, n, t), t) }) : y(t, o), { inlineValues: l, inlineValueTypes: u, blocks: h } } function Kh (t, e) { return t.getName(e) || t.getId(e) } function $h (t) { const e = t.name; Gr(t) || (t.name = Qh(t) || e) } function Qh (t) { const e = t.getRawData(); const n = e.mapDimensionsAll('seriesName'); const i = []; return y(n, function (t) { const n = e.getDimensionInfo(t); n.displayName && i.push(n.displayName) }), i.join(' ') } function Jh (t) { return t.model.getRawData().count() } function tc (t) { const e = t.model; return e.setData(e.getRawData().cloneShallow()), ec } function ec (t, e) { e.outputData && t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData) } function nc (t, e) { y(j(t.CHANGABLE_METHODS, t.DOWNSAMPLE_METHODS), function (n) { t.wrapMethod(n, S(ic, e)) }) } function ic (t, e) { const n = rc(t); return n && n.setOutputEnd((e || this).count()), e } function rc (t) { const e = (t.ecModel || {}).scheduler; const n = e && e.getPipeline(t.uid); if (n) { let i = n.currentTask; if (i) { const r = i.agentStubMap; r && (i = r.get(t.uid)) } return i } } function oc () { const t = qr(); return function (e) { const n = t(e); const i = e.pipelineContext; const r = !!n.large; const o = !!n.progressiveRender; const a = n.large = !(!i || !i.large); const s = n.progressiveRender = !(!i || !i.progressiveRender); return !(r === a && o === s) && 'reset' } } function ac (t, e, n) { t && es(t) && (e === 'emphasis' ? Pa : Oa)(t, n) } function sc (t, e, n) { const i = jr(t, e); const r = e && e.highlightKey != null ? ns(e.highlightKey) : null; i != null ? y(kr(i), function (e) { ac(t.getItemGraphicEl(e), n, r) }) : t.eachItemGraphicEl(function (t) { ac(t, n, r) }) } function lc (t) { return ZL(t.model) } function uc (t) { const e = t.model; const n = t.ecModel; const i = t.api; const r = t.payload; const o = e.pipelineContext.progressiveRender; const a = t.view; const s = r && UL(r).updateMethod; const l = o ? 'incrementalPrepareRender' : s && a[s] ? s : 'render'; return l !== 'render' && a[l](e, n, i, r), KL[l] } function hc (t, e, n) { function i () { h = (new Date()).getTime(), c = null, t.apply(a, s || []) } let r; let o; let a; let s; let l; let u = 0; var h = 0; var c = null; e = e || 0; const p = function () { for (var t = [], p = 0; p < arguments.length; p++)t[p] = arguments[p]; r = (new Date()).getTime(), a = this, s = t; const d = l || e; const f = l || n; l = null, o = r - (f ? u : h) - d, clearTimeout(c), f ? c = setTimeout(i, d) : o >= 0 ? i() : c = setTimeout(i, -o), u = r }; return p.clear = function () { c && (clearTimeout(c), c = null) }, p.debounceNextCall = function (t) { l = t }, p } function cc (t, e, n, i) { let r = t[e]; if (r) { const o = r[$L] || r; const a = r[JL]; const s = r[QL]; if (s !== n || a !== i) { if (n == null || !i) return t[e] = o; r = t[e] = hc(o, n, i === 'debounce'), r[$L] = o, r[JL] = i, r[QL] = n } return r } } function pc (t, e) { const n = t[e]; n && n[$L] && (n.clear && n.clear(), t[e] = n[$L]) } function dc (t, e) { const n = t.visualStyleMapper || eP[e]; return n || (console.warn("Unknown style type '" + e + "'."), eP.itemStyle) } function fc (t, e) { const n = t.visualDrawType || nP[e]; return n || (console.warn("Unknown style type '" + e + "'."), 'fill') } function gc (t, e) { e = e || {}, c(e, { text: 'loading', textColor: '#000', fontSize: 12, fontWeight: 'normal', fontStyle: 'normal', fontFamily: 'sans-serif', maskColor: 'rgba(255, 255, 255, 0.8)', showSpinner: !0, color: '#5470c6', spinnerRadius: 10, lineWidth: 5, zlevel: 0 }); const n = new CI(); const i = new nD({ style: { fill: e.maskColor }, zlevel: e.zlevel, z: 1e4 }); n.add(i); const r = new aD({ style: { text: e.text, fill: e.textColor, fontSize: e.fontSize, fontWeight: e.fontWeight, fontStyle: e.fontStyle, fontFamily: e.fontFamily }, zlevel: e.zlevel, z: 10001 }); const o = new nD({ style: { fill: 'none' }, textContent: r, textConfig: { position: 'right', distance: 10 }, zlevel: e.zlevel, z: 10001 }); n.add(o); let a; return e.showSpinner && (a = new mk({ shape: { startAngle: -sP / 2, endAngle: -sP / 2 + 0.1, r: e.spinnerRadius }, style: { stroke: e.color, lineCap: 'round', lineWidth: e.lineWidth }, zlevel: e.zlevel, z: 10001 }), a.animateShape(!0).when(1e3, { endAngle: 3 * sP / 2 }).start('circularInOut'), a.animateShape(!0).when(1e3, { startAngle: 3 * sP / 2 }).delay(300).start('circularInOut'), n.add(a)), n.resize = function () { const n = r.getBoundingRect().width; const s = e.showSpinner ? e.spinnerRadius : 0; const l = (t.getWidth() - 2 * s - (e.showSpinner && n ? 10 : 0) - n) / 2 - (e.showSpinner && n ? 0 : 5 + n / 2) + (e.showSpinner ? 0 : n / 2) + (n ? 0 : s); const u = t.getHeight() / 2; e.showSpinner && a.setShape({ cx: l, cy: u }), o.setShape({ x: l - s, y: u - s, width: 2 * s, height: 2 * s }), i.setShape({ x: 0, y: 0, width: t.getWidth(), height: t.getHeight() }) }, n.resize(), n } function yc (t) { t.overallReset(t.ecModel, t.api, t.payload) } function vc (t) { return t.overallProgress && mc } function mc () { this.agent.dirty(), this.getDownstream().dirty() } function _c () { this.agent && this.agent.dirty() } function xc (t) { return t.plan ? t.plan(t.model, t.ecModel, t.api, t.payload) : null } function wc (t) { t.useClearVisual && t.data.clearAllVisual(); const e = t.resetDefines = kr(t.reset(t.model, t.ecModel, t.api, t.payload)); return e.length > 1 ? v(e, function (t, e) { return bc(e) }) : uP } function bc (t) { return function (e, n) { const i = n.data; const r = n.resetDefines[t]; if (r && r.dataEach) for (let o = e.start; o < e.end; o++)r.dataEach(i, o); else r && r.progress && r.progress(e, i) } } function Sc (t) { return t.data.count() } function Mc (t) { qL = null; try { t(hP, cP) } catch (e) {} return qL } function Tc (t, e) { for (const n in e.prototype)t[n] = Q } function Ic (t, e, n) { switch (n) { case 'color':var i = t.getItemVisual(e, 'style'); return i[t.getVisual('drawType')]; case 'opacity':return t.getItemVisual(e, 'style').opacity; case 'symbol':case 'symbolSize':case 'liftZ':return t.getItemVisual(e, n) } } function Cc (t, e) { switch (e) { case 'color':var n = t.getVisual('style'); return n[t.getVisual('drawType')]; case 'opacity':return t.getVisual('style').opacity; case 'symbol':case 'symbolSize':case 'liftZ':return t.getVisual(e) } } function Dc (t, e, n, i) { switch (n) { case 'color':var r = t.ensureUniqueItemVisual(e, 'style'); r[t.getVisual('drawType')] = i, t.setItemVisual(e, 'colorFromPalette', !1); break; case 'opacity':t.ensureUniqueItemVisual(e, 'style').opacity = i; break; case 'symbol':case 'symbolSize':case 'liftZ':t.setItemVisual(e, n, i) } } function kc (t, e, n, i, r) { const o = t + e; n.isSilent(o) || i.eachComponent({ mainType: 'series', subType: 'pie' }, function (t) { for (let e = t.seriesIndex, i = t.option.selectedMap, a = r.selected, s = 0; s < a.length; s++) if (a[s].seriesIndex === e) { const l = t.getData(); const u = jr(l, r.fromActionPayload); n.trigger(o, { type: o, seriesId: t.id, name: l.getName(M(u) ? u[0] : u), selected: I(i) ? i : h({}, i) }) } }) } function Ac (t, e, n) { t.on('selectchanged', function (t) { const i = n.getModel(); t.isFromClick ? (kc('map', 'selectchanged', e, i, t), kc('pie', 'selectchanged', e, i, t)) : t.fromAction === 'select' ? (kc('map', 'selected', e, i, t), kc('pie', 'selected', e, i, t)) : t.fromAction === 'unselect' && (kc('map', 'unselected', e, i, t), kc('pie', 'unselected', e, i, t)) }) } function Lc (t, e, n) { for (var i; t && (!e(t) || (i = t, !n));)t = t.__hostTarget || t.parent; return i } function Pc (t, e) { if (this.type !== 'image') { const n = this.style; this.__isEmptyBrush ? (n.stroke = t, n.fill = e || '#fff', n.lineWidth = 2) : this.shape.symbolType === 'line' ? n.stroke = t : n.fill = t, this.markRedraw() } } function Oc (t, e, n, i, r, o, a) { const s = t.indexOf('empty') === 0; s && (t = t.substr(5, 1).toLowerCase() + t.substr(6)); let l; return l = t.indexOf('image://') === 0 ? Es(t.slice(8), new $M(e, n, i, r), a ? 'center' : 'cover') : t.indexOf('path://') === 0 ? Bs(t.slice(7), {}, new $M(e, n, i, r), a ? 'center' : 'cover') : new RP({ shape: { symbolType: t, x: e, y: n, width: i, height: r } }), l.__isEmptyBrush = s, l.setColor = Pc, o && l.setColor(o), l } function Rc (t) { return M(t) || (t = [+t, +t]), [t[0] || 0, t[1] || 0] } function Nc (t, e) { return t != null ? (M(t) || (t = [t, t]), [or(t[0], e[0]) || 0, or(E(t[1], t[0]), e[1]) || 0]) : void 0 } function zc (t) { return isFinite(t) } function Bc (t, e, n) { let i = e.x == null ? 0 : e.x; let r = e.x2 == null ? 1 : e.x2; let o = e.y == null ? 0 : e.y; let a = e.y2 == null ? 0 : e.y2; e.global || (i = i * n.width + n.x, r = r * n.width + n.x, o = o * n.height + n.y, a = a * n.height + n.y), i = zc(i) ? i : 0, r = zc(r) ? r : 1, o = zc(o) ? o : 0, a = zc(a) ? a : 0; const s = t.createLinearGradient(i, o, r, a); return s } function Ec (t, e, n) { const i = n.width; const r = n.height; const o = Math.min(i, r); let a = e.x == null ? 0.5 : e.x; let s = e.y == null ? 0.5 : e.y; let l = e.r == null ? 0.5 : e.r; e.global || (a = a * i + n.x, s = s * r + n.y, l *= o), a = zc(a) ? a : 0.5, s = zc(s) ? s : 0.5, l = l >= 0 && zc(l) ? l : 0.5; const u = t.createRadialGradient(a, s, 0, a, s, l); return u } function Vc (t, e, n) { for (var i = e.type === 'radial' ? Ec(t, e, n) : Bc(t, e, n), r = e.colorStops, o = 0; o < r.length; o++)i.addColorStop(r[o].offset, r[o].color); return i } function Fc (t, e) { if (t === e || !t && !e) return !1; if (!t || !e || t.length !== e.length) return !0; for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return !0; return !1 } function Hc (t) { return parseInt(t, 10) } function Wc (t, e, n) { const i = ['width', 'height'][e]; const r = ['clientWidth', 'clientHeight'][e]; const o = ['paddingLeft', 'paddingTop'][e]; const a = ['paddingRight', 'paddingBottom'][e]; if (n[i] != null && n[i] !== 'auto') return parseFloat(n[i]); const s = document.defaultView.getComputedStyle(t); return (t[r] || Hc(s[i]) || Hc(t.style[i])) - (Hc(s[o]) || 0) - (Hc(s[a]) || 0) | 0 } function Gc (t, e) { return t && t !== 'solid' && e > 0 ? t === 'dashed' ? [4 * e, 2 * e] : t === 'dotted' ? [e] : D(t) ? [t] : M(t) ? t : null : null } function Xc (t) { const e = t.style; let n = e.lineDash && e.lineWidth > 0 && Gc(e.lineDash, e.lineWidth); let i = e.lineDashOffset; if (n) { const r = e.strokeNoScale && t.getLineScale ? t.getLineScale() : 1; r && r !== 1 && (n = v(n, function (t) { return t / r }), i /= r) } return [n, i] } function Yc (t) { const e = t.stroke; return !(e == null || e === 'none' || !(t.lineWidth > 0)) } function Uc (t) { return typeof t === 'string' && t !== 'none' } function Zc (t) { const e = t.fill; return e != null && e !== 'none' } function jc (t, e) { if (e.fillOpacity != null && e.fillOpacity !== 1) { const n = t.globalAlpha; t.globalAlpha = e.fillOpacity * e.opacity, t.fill(), t.globalAlpha = n } else t.fill() } function qc (t, e) { if (e.strokeOpacity != null && e.strokeOpacity !== 1) { const n = t.globalAlpha; t.globalAlpha = e.strokeOpacity * e.opacity, t.stroke(), t.globalAlpha = n } else t.stroke() } function Kc (t, e, n) { const i = yo(e.image, e.__image, n); if (mo(i)) { const r = t.createPattern(i, e.repeat || 'repeat'); if (typeof DOMMatrix === 'function' && r && r.setTransform) { const o = new DOMMatrix(); o.translateSelf(e.x || 0, e.y || 0), o.rotateSelf(0, 0, (e.rotation || 0) * xM), o.scaleSelf(e.scaleX || 1, e.scaleY || 1), r.setTransform(o) } return r } } function $c (t, e, n, i) { let r; let o = Yc(n); let a = Zc(n); const s = n.strokePercent; const l = s < 1; const u = !e.path; e.silent && !l || !u || e.createPathProxy(); const h = e.path || NP; const c = e.__dirty; if (!i) { const p = n.fill; const d = n.stroke; const f = a && !!p.colorStops; const g = o && !!d.colorStops; const y = a && !!p.image; const v = o && !!d.image; let m = void 0; let _ = void 0; let x = void 0; let w = void 0; let b = void 0; (f || g) && (b = e.getBoundingRect()), f && (m = c ? Vc(t, p, b) : e.__canvasFillGradient, e.__canvasFillGradient = m), g && (_ = c ? Vc(t, d, b) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = _), y && (x = c || !e.__canvasFillPattern ? Kc(t, p, e) : e.__canvasFillPattern, e.__canvasFillPattern = x), v && (w = c || !e.__canvasStrokePattern ? Kc(t, d, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = x), f ? t.fillStyle = m : y && (x ? t.fillStyle = x : a = !1), g ? t.strokeStyle = _ : v && (w ? t.strokeStyle = w : o = !1) } const S = e.getGlobalScale(); h.setScale(S[0], S[1], e.segmentIgnoreThreshold); let M, T; t.setLineDash && n.lineDash && (r = Xc(e), M = r[0], T = r[1]); let I = !0; (u || c & uT) && (h.setDPR(t.dpr), l ? h.setContext(null) : (h.setContext(t), I = !1), h.reset(), e.buildPath(h, e.shape, i), h.toStatic(), e.pathUpdated()), I && h.rebuildPath(t, l ? s : 1), M && (t.setLineDash(M), t.lineDashOffset = T), i || (n.strokeFirst ? (o && qc(t, n), a && jc(t, n)) : (a && jc(t, n), o && qc(t, n))), M && t.setLineDash([]) } function Qc (t, e, n) { const i = e.__image = yo(n.image, e.__image, e, e.onload); if (i && mo(i)) { const r = n.x || 0; const o = n.y || 0; let a = e.getWidth(); let s = e.getHeight(); const l = i.width / i.height; if (a == null && s != null ? a = s * l : s == null && a != null ? s = a / l : a == null && s == null && (a = i.width, s = i.height), n.sWidth && n.sHeight) { var u = n.sx || 0; var h = n.sy || 0; t.drawImage(i, u, h, n.sWidth, n.sHeight, r, o, a, s) } else if (n.sx && n.sy) { var u = n.sx; var h = n.sy; const c = a - u; const p = s - h; t.drawImage(i, u, h, c, p, r, o, a, s) } else t.drawImage(i, r, o, a, s) } } function Jc (t, e, n) { let i; let r = n.text; if (r != null && (r += ''), r) { t.font = n.font || KS, t.textAlign = n.textAlign, t.textBaseline = n.textBaseline; let o = void 0; let a = void 0; t.setLineDash && n.lineDash && (i = Xc(e), o = i[0], a = i[1]), o && (t.setLineDash(o), t.lineDashOffset = a), n.strokeFirst ? (Yc(n) && t.strokeText(r, n.x, n.y), Zc(n) && t.fillText(r, n.x, n.y)) : (Zc(n) && t.fillText(r, n.x, n.y), Yc(n) && t.strokeText(r, n.x, n.y)), o && t.setLineDash([]) } } function tp (t, e, n, i, r) { let o = !1; if (!i && (n = n || {}, e === n)) return !1; if (i || e.opacity !== n.opacity) { sp(t, r), o = !0; const a = Math.max(Math.min(e.opacity, 1), 0); t.globalAlpha = isNaN(a) ? iC.opacity : a }(i || e.blend !== n.blend) && (o || (sp(t, r), o = !0), t.globalCompositeOperation = e.blend || iC.blend); for (let s = 0; s < zP.length; s++) { const l = zP[s]; (i || e[l] !== n[l]) && (o || (sp(t, r), o = !0), t[l] = t.dpr * (e[l] || 0)) } return (i || e.shadowColor !== n.shadowColor) && (o || (sp(t, r), o = !0), t.shadowColor = e.shadowColor || iC.shadowColor), o } function ep (t, e, n, i, r) { const o = lp(e, r.inHover); const a = i ? null : n && lp(n, r.inHover) || {}; if (o === a) return !1; let s = tp(t, o, a, i, r); if ((i || o.fill !== a.fill) && (s || (sp(t, r), s = !0), Uc(o.fill) && (t.fillStyle = o.fill)), (i || o.stroke !== a.stroke) && (s || (sp(t, r), s = !0), Uc(o.stroke) && (t.strokeStyle = o.stroke)), (i || o.opacity !== a.opacity) && (s || (sp(t, r), s = !0), t.globalAlpha = o.opacity == null ? 1 : o.opacity), e.hasStroke()) { const l = o.lineWidth; const u = l / (o.strokeNoScale && e.getLineScale ? e.getLineScale() : 1); t.lineWidth !== u && (s || (sp(t, r), s = !0), t.lineWidth = u) } for (let h = 0; h < BP.length; h++) { const c = BP[h]; const p = c[0]; (i || o[p] !== a[p]) && (s || (sp(t, r), s = !0), t[p] = o[p] || c[1]) } return s } function np (t, e, n, i, r) { return tp(t, lp(e, r.inHover), n && lp(n, r.inHover), i, r) } function ip (t, e) { const n = e.transform; const i = t.dpr || 1; n ? t.setTransform(i * n[0], i * n[1], i * n[2], i * n[3], i * n[4], i * n[5]) : t.setTransform(i, 0, 0, i, 0, 0) } function rp (t, e, n) { for (var i = !1, r = 0; r < t.length; r++) { const o = t[r]; i = i || o.isZeroArea(), ip(e, o), e.beginPath(), o.buildPath(e, o.shape), e.clip() }n.allClipped = i } function op (t, e) { return t && e ? t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || t[4] !== e[4] || t[5] !== e[5] : t || e ? !0 : !1 } function ap (t) { const e = Zc(t); const n = Yc(t); return !(t.lineDash || !(+e ^ +n) || e && typeof t.fill !== 'string' || n && typeof t.stroke !== 'string' || t.strokePercent < 1 || t.strokeOpacity < 1 || t.fillOpacity < 1) } function sp (t, e) { e.batchFill && t.fill(), e.batchStroke && t.stroke(), e.batchFill = '', e.batchStroke = '' } function lp (t, e) { return e ? t.__hoverStyle || t.style : t.style } function up (t, e) { hp(t, e, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0) } function hp (t, e, n, i) { const r = e.transform; if (!e.shouldBePainted(n.viewWidth, n.viewHeight, !1, !1)) return e.__dirty &= ~sT, void (e.__isRendered = !1); const o = e.__clipPaths; const a = n.prevElClipPaths; let s = !1; let l = !1; if ((!a || Fc(o, a)) && (a && a.length && (sp(t, n), t.restore(), l = s = !0, n.prevElClipPaths = null, n.allClipped = !1, n.prevEl = null), o && o.length && (sp(t, n), t.save(), rp(o, t, n), s = !0), n.prevElClipPaths = o), n.allClipped) return void (e.__isRendered = !1); e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush(); const u = n.prevEl; u || (l = s = !0); const h = e instanceof ZC && e.autoBatch && ap(e.style); s || op(r, u.transform) ? (sp(t, n), ip(t, e)) : h || sp(t, n); const c = lp(e, n.inHover); e instanceof ZC ? (n.lastDrawType !== EP && (l = !0, n.lastDrawType = EP), ep(t, e, u, l, n), h && (n.batchFill || n.batchStroke) || t.beginPath(), $c(t, e, c, h), h && (n.batchFill = c.fill || '', n.batchStroke = c.stroke || '')) : e instanceof qC ? (n.lastDrawType !== FP && (l = !0, n.lastDrawType = FP), ep(t, e, u, l, n), Jc(t, e, c)) : e instanceof QC ? (n.lastDrawType !== VP && (l = !0, n.lastDrawType = VP), np(t, e, u, l, n), Qc(t, e, c)) : e.getTemporalDisplayables && (n.lastDrawType !== HP && (l = !0, n.lastDrawType = HP), cp(t, e, n)), h && i && sp(t, n), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), n.prevEl = e, e.__dirty = 0, e.__isRendered = !0 } function cp (t, e, n) { const i = e.getDisplayables(); const r = e.getTemporalDisplayables(); t.save(); let o; let a; const s = { prevElClipPaths: null, prevEl: null, allClipped: !1, viewWidth: n.viewWidth, viewHeight: n.viewHeight, inHover: n.inHover }; for (o = e.getCursor(), a = i.length; a > o; o++) { var l = i[o]; l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), hp(t, l, s, o === a - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), s.prevEl = l } for (let u = 0, h = r.length; h > u; u++) { var l = r[u]; l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), hp(t, l, s, u === h - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), s.prevEl = l }e.clearTemporalDisplayables(), e.notClear = !0, t.restore() } function pp (t, e) { function n (t) { function e () { for (var t = 1, e = 0, n = v.length; n > e; ++e)t = Ir(t, v[e]); for (var i = 1, e = 0, n = y.length; n > e; ++e)i = Ir(i, y[e].length); t *= i; const r = m * v.length * y.length; return { width: Math.max(1, Math.min(t, s.maxTileWidth)), height: Math.max(1, Math.min(r, s.maxTileHeight)) } } function n () { function t (t, e, n, a, l) { const u = o ? 1 : i; const h = Oc(l, t * u, e * u, n * u, a * u, s.color, s.symbolKeepAspect); if (o) { const c = r.painter.renderOneToVNode(h); c && x.children.push(c) } else up(d, h) }d && (d.clearRect(0, 0, _.width, _.height), s.backgroundColor && (d.fillStyle = s.backgroundColor, d.fillRect(0, 0, _.width, _.height))); for (var e = 0, n = 0; n < g.length; ++n)e += g[n]; if (!(e <= 0)) for (let a = -m, l = 0, u = 0, h = 0; a < w.height;) { if (l % 2 === 0) { for (let c = u / 2 % y.length, p = 0, v = 0, b = 0; p < 2 * w.width;) { for (var S = 0, n = 0; n < f[h].length; ++n)S += f[h][n]; if (S <= 0) break; if (v % 2 === 0) { const M = 0.5 * (1 - s.symbolSize); const T = p + f[h][v] * M; const I = a + g[l] * M; const C = f[h][v] * s.symbolSize; const D = g[l] * s.symbolSize; const k = b / 2 % y[c].length; t(T, I, C, D, y[c][k]) }p += f[h][v], ++b, ++v, v === f[h].length && (v = 0) }++h, h === f.length && (h = 0) }a += g[l], ++u, ++l, l === g.length && (l = 0) } } for (var a = [i], l = !0, u = 0; u < XP.length; ++u) { const h = s[XP[u]]; if (h != null && !M(h) && !I(h) && !D(h) && typeof h !== 'boolean') { l = !1; break }a.push(h) } let c; if (l) { c = a.join(',') + (o ? '-svg' : ''); const p = GP.get(c); p && (o ? t.svgElement = p : t.image = p) } let d; var f = fp(s.dashArrayX); var g = gp(s.dashArrayY); var y = dp(s.symbol); var v = yp(f); var m = vp(g); var _ = !o && eM.createCanvas(); var x = o && { tag: 'g', attrs: {}, key: 'dcl', children: [] }; var w = e(); _ && (_.width = w.width * i, _.height = w.height * i, d = _.getContext('2d')), n(), l && GP.put(c, _ || x), t.image = _, t.svgElement = x, t.svgWidth = w.width, t.svgHeight = w.height } if (t === 'none') return null; var i = e.getDevicePixelRatio(); var r = e.getZr(); var o = r.painter.type === 'svg'; t.dirty && WP.delete(t); const a = WP.get(t); if (a) return a; var s = c(t, { symbol: 'rect', symbolSize: 1, symbolKeepAspect: !0, color: 'rgba(0, 0, 0, 0.2)', backgroundColor: null, dashArrayX: 5, dashArrayY: 5, rotation: 0, maxTileWidth: 512, maxTileHeight: 512 }); s.backgroundColor === 'none' && (s.backgroundColor = null); const l = { repeat: 'repeat' }; return n(l), l.rotation = s.rotation, l.scaleX = l.scaleY = o ? 1 : 1 / i, WP.set(t, l), t.dirty = !1, l } function dp (t) { if (!t || t.length === 0) return [['rect']]; if (I(t)) return [[t]]; for (var e = !0, n = 0; n < t.length; ++n) if (!I(t[n])) { e = !1; break } if (e) return dp([t]); for (var i = [], n = 0; n < t.length; ++n)i.push(I(t[n]) ? [t[n]] : t[n]); return i } function fp (t) { if (!t || t.length === 0) return [[0, 0]]; if (D(t)) { var e = Math.ceil(t); return [[e, e]] } for (var n = !0, i = 0; i < t.length; ++i) if (!D(t[i])) { n = !1; break } if (n) return fp([t]); for (var r = [], i = 0; i < t.length; ++i) if (D(t[i])) { var e = Math.ceil(t[i]); r.push([e, e]) } else { var e = v(t[i], function (t) { return Math.ceil(t) }); r.push(e.length % 2 === 1 ? e.concat(e) : e) } return r } function gp (t) { if (!t || typeof t === 'object' && t.length === 0) return [0, 0]; if (D(t)) { const e = Math.ceil(t); return [e, e] } const n = v(t, function (t) { return Math.ceil(t) }); return t.length % 2 ? n.concat(n) : n } function yp (t) { return v(t, function (t) { return vp(t) }) } function vp (t) { for (var e = 0, n = 0; n < t.length; ++n)e += t[n]; return t.length % 2 === 1 ? 2 * e : e } function mp (t, e) { t.eachRawSeries(function (n) { if (!t.isSeriesFiltered(n)) { const i = n.getData(); i.hasItemVisual() && i.each(function (t) { const n = i.getItemVisual(t, 'decal'); if (n) { const r = i.ensureUniqueItemVisual(t, 'style'); r.decal = pp(n, e) } }); const r = i.getVisual('decal'); if (r) { const o = i.getVisual('style'); o.decal = pp(r, e) } } }) } function _p (t, e) { UP[t] = e } function xp (t) { return UP[t] } function wp (t) { return function () { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; return this.isDisposed() ? void 0 : Sp(this, t, e) } } function bp (t) { return function () { for (var e = [], n = 0; n < arguments.length; n++)e[n] = arguments[n]; return Sp(this, t, e) } } function Sp (t, e, n) { return n[0] = n[0] && n[0].toLowerCase(), kM.prototype[e].apply(t, n) } function Mp (t, e, n) { const i = !(n && n.ssr); if (i) { const r = Dp(t); if (r) return r } const o = new FO(t, e, n); return o.id = 'ec_' + QO++, KO[o.id] = o, i && Jr(t, tR, o.id), BO(o), YP.trigger('afterinit', o), o } function Tp (t) { if (M(t)) { const e = t; t = null, y(e, function (e) { e.group != null && (t = e.group) }), t = t || 'g_' + JO++, y(e, function (e) { e.group = t }) } return $O[t] = !0, t } function Ip (t) { $O[t] = !1 } function Cp (t) { I(t) ? t = KO[t] : t instanceof FO || (t = Dp(t)), t instanceof FO && !t.isDisposed() && t.dispose() } function Dp (t) { return KO[to(t, tR)] } function kp (t) { return KO[t] } function Ap (t, e) { jO[t] = e } function Lp (t) { p(UO, t) < 0 && UO.push(t) } function Pp (t, e) { Hp(YO, t, e, JP) } function Op (t) { Np('afterinit', t) } function Rp (t) { Np('afterupdate', t) } function Np (t, e) { YP.on(t, e) } function zp (t, e, n) { T(e) && (n = e, e = ''); const i = k(t) ? t.type : [t, t = { event: e }][0]; t.event = (t.event || i).toLowerCase(), e = t.event, XO[e] || (W(gO.test(i) && gO.test(e)), GO[i] || (GO[i] = { action: n, actionInfo: t }), XO[e] = i) } function Bp (t, e) { oL.register(t, e) } function Ep (t) { const e = oL.get(t); return e ? e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice() : void 0 } function Vp (t, e) { Hp(ZO, t, e, eO, 'layout') } function Fp (t, e) { Hp(ZO, t, e, rO, 'visual') } function Hp (t, e, n, i, r) { if ((T(e) || k(e)) && (n = e, e = i), !(p(nR, n) >= 0)) { nR.push(n); const o = lP.wrapStageHandler(n, r); o.__prio = e, o.__raw = n, t.push(o) } } function Wp (t, e) { qO[t] = e } function Gp (t) { r({ createCanvas: t }) } function Xp (t, e, n) { const i = xp('registerMap'); i && i(t, e, n) } function Yp (t) { const e = xp('getMap'); return e && e(t) } function Up (t) { return t == null ? 0 : t.length || 1 } function Zp (t) { return t } function jp (t, e) {
    const n = {}; const i = n.encode = {}; const r = Z(); let o = []; let a = []; const s = {}; y(t.dimensions, function (e) {
      const n = t.getDimensionInfo(e); const l = n.coordDim
      if (l) { const u = n.coordDimIndex; qp(i, l)[u] = e, n.isExtraCoord || (r.set(l, 1), $p(n.type) && (o[0] = e), qp(s, l)[u] = t.getDimensionIndex(n.name)), n.defaultTooltip && a.push(e) }OA.each(function (t, e) { const r = qp(i, e); const o = n.otherDims[e]; o != null && o !== !1 && (r[o] = n.name) })
    }); let l = []; const u = {}; r.each(function (t, e) { const n = i[e]; u[e] = n[0], l = l.concat(n) }), n.dataDimsOnCoord = l, n.dataDimIndicesOnCoord = v(l, function (e) { return t.getDimensionInfo(e).storeDimIndex }), n.encodeFirstDimNotExtra = u; const h = i.label; h && h.length && (o = h.slice()); const c = i.tooltip; return c && c.length ? a = c.slice() : a.length || (a = o.slice()), i.defaultedLabel = o, i.defaultedTooltip = a, n.userOutput = new dR(s, e), n
  } function qp (t, e) { return t.hasOwnProperty(e) || (t[e] = []), t[e] } function Kp (t) { return t === 'category' ? 'ordinal' : t === 'time' ? 'time' : 'float' } function $p (t) { return !(t === 'ordinal' || t === 'time') } function Qp (t) { return t instanceof vR } function Jp (t) { for (var e = Z(), n = 0; n < (t || []).length; n++) { const i = t[n]; const r = k(i) ? i.name : i; r != null && e.get(r) == null && e.set(r, n) } return e } function td (t) { const e = gR(t); return e.dimNameMap || (e.dimNameMap = Jp(t.dimensionsDefine)) } function ed (t) { return t > 30 } function nd (t, e) { return id(t, e).dimensions } function id (t, e) { function n (t) { const e = m[t]; if (e < 0) { const n = a[t]; const i = k(n) ? n : { name: n }; const r = new fR(); const o = i.name; o != null && f.get(o) != null && (r.name = r.displayName = o), i.type != null && (r.type = i.type), i.displayName != null && (r.displayName = i.displayName); const s = l.length; return m[t] = s, r.storeDimIndex = t, l.push(r), r } return l[e] } function i (t, e, n) { OA.get(e) != null ? t.otherDims[e] = n : (t.coordDim = e, t.coordDimIndex = n, s.set(e, !0)) } function r (t) { t.name == null && (t.name = t.coordDim) }Qu(t) || (t = th(t)), e = e || {}; const o = e.coordDimensions || []; var a = e.dimensionsDefine || t.dimensionsDefine || []; var s = Z(); var l = []; const u = od(t, o, a, e.dimensionsCount); const p = e.canOmitUnusedDimensions && ed(u); const d = a === t.dimensionsDefine; var f = d ? td(t) : Jp(a); let g = e.encodeDefine; !g && e.encodeDefaulter && (g = e.encodeDefaulter(t, u)); for (var v = Z(g), m = new OL(u), _ = 0; _ < m.length; _++)m[_] = -1; if (!p) for (var _ = 0; u > _; _++)n(_); v.each(function (t, e) { const r = kr(t).slice(); if (r.length === 1 && !I(r[0]) && r[0] < 0) return void v.set(e, !1); const o = v.set(e, []); y(r, function (t, r) { const a = I(t) ? f.get(t) : t; a != null && u > a && (o[r] = a, i(n(a), e, r)) }) }); let x = 0; y(o, function (t) { let e, r, o, a; if (I(t))e = t, a = {}; else { a = t, e = a.name; const s = a.ordinalMeta; a.ordinalMeta = null, a = h({}, a), a.ordinalMeta = s, r = a.dimsDef, o = a.otherDims, a.name = a.coordDim = a.coordDimIndex = a.dimsDef = a.otherDims = null } let l = v.get(e); if (l !== !1) { if (l = kr(l), !l.length) for (let p = 0; p < (r && r.length || 1); p++) { for (;u > x && n(x).coordDim != null;)x++; u > x && l.push(x++) }y(l, function (t, s) { const l = n(t); if (d && a.type != null && (l.type = a.type), i(c(l, a), e, s), l.name == null && r) { let u = r[s]; !k(u) && (u = { name: u }), l.name = l.displayName = u.name, l.defaultTooltip = u.defaultTooltip }o && c(l.otherDims, o) }) } }); const w = e.generateCoord; let b = e.generateCoordCount; const S = b != null; b = w ? b || 1 : 0; const M = w || 'value'; if (p)y(l, function (t) { r(t) }), l.sort(function (t, e) { return t.storeDimIndex - e.storeDimIndex }); else for (let T = 0; u > T; T++) { const C = n(T); const D = C.coordDim; D == null && (C.coordDim = ad(M, s, S), C.coordDimIndex = 0, (!w || b <= 0) && (C.isExtraCoord = !0), b--), r(C), C.type != null || yu(t, T) !== WA.Must && (!C.isExtraCoord || C.otherDims.itemName == null && C.otherDims.seriesName == null) || (C.type = 'ordinal') } return rd(l), new vR({ source: t, dimensions: l, fullDimensionCount: u, dimensionOmitted: p }) } function rd (t) { for (let e = Z(), n = 0; n < t.length; n++) { const i = t[n]; const r = i.name; let o = e.get(r) || 0; o > 0 && (i.name = r + (o - 1)), o++, e.set(r, o) } } function od (t, e, n, i) { let r = Math.max(t.dimensionsDetectedCount || 1, e.length, n.length, i || 0); return y(e, function (t) { let e; k(t) && (e = t.dimsDef) && (r = Math.max(r, e.length)) }), r } function ad (t, e, n) { if (n || e.hasKey(t)) { for (var i = 0; e.hasKey(t + i);)i++; t += i } return e.set(t, !0), t } function sd (t) { const e = t.get('coordinateSystem'); const n = new IR(e); const i = CR[e]; return i ? (i(t, n, n.axisMap, n.categoryAxisMap), n) : void 0 } function ld (t) { return t.get('type') === 'category' } function ud (t, e, n) { n = n || {}; let i; let r; let o; let a = n.byIndex; const s = n.stackedCoordDimension; hd(e) ? i = e : (r = e.schema, i = r.dimensions, o = e.store); let l; let u; let h; let c; const p = !(!t || !t.get('stack')); if (y(i, function (t, e) { I(t) && (i[e] = t = { name: t }), p && !t.isExtraCoord && (a || l || !t.ordinalMeta || (l = t), u || t.type === 'ordinal' || t.type === 'time' || s && s !== t.coordDim || (u = t)) }), !u || a || l || (a = !0), u) { h = '__\x00ecstackresult_' + t.id, c = '__\x00ecstackedover_' + t.id, l && (l.createInvertedIndices = !0); const d = u.coordDim; const f = u.type; let g = 0; y(i, function (t) { t.coordDim === d && g++ }); const v = { name: h, coordDim: d, coordDimIndex: g, type: f, isExtraCoord: !0, isCalculationCoord: !0, storeDimIndex: i.length }; const m = { name: c, coordDim: c, coordDimIndex: g + 1, type: f, isExtraCoord: !0, isCalculationCoord: !0, storeDimIndex: i.length + 1 }; r ? (o && (v.storeDimIndex = o.ensureCalculationDimension(c, f), m.storeDimIndex = o.ensureCalculationDimension(h, f)), r.appendCalculationDimension(v), r.appendCalculationDimension(m)) : (i.push(v), i.push(m)) } return { stackedDimension: u && u.name, stackedByDimension: l && l.name, isStackedByIndex: a, stackedOverDimension: c, stackResultDimension: h } } function hd (t) { return !Qp(t.schema) } function cd (t, e) { return !!e && e === t.getCalculationInfo('stackedDimension') } function pd (t, e) { return cd(t, e) ? t.getCalculationInfo('stackResultDimension') : e } function dd (t, e) { let n; const i = t.get('coordinateSystem'); const r = oL.get(i); return e && e.coordSysDims && (n = v(e.coordSysDims, function (t) { const n = { name: t }; const i = e.axisMap.get(t); if (i) { const r = i.get('type'); n.type = Kp(r) } return n })), n || (n = r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || ['x', 'y']), n } function fd (t, e, n) { let i, r; return n && y(t, function (t, o) { const a = t.coordDim; const s = n.categoryAxisMap.get(a); s && (i == null && (i = o), t.ordinalMeta = s.getOrdinalMeta(), e && (t.createInvertedIndices = !0)), t.otherDims.itemName != null && (r = !0) }), r || i == null || (t[i].otherDims.itemName = 0), i } function gd (t, e, n) { n = n || {}; let i; const r = e.getSourceManager(); let o = !1; t ? (o = !0, i = th(t)) : (i = r.getSource(), o = i.sourceFormat === RA); const a = sd(e); const s = dd(e, a); const l = n.useEncodeDefaulter; const u = T(l) ? l : l ? S(du, s, e) : null; const h = { coordDimensions: s, generateCoord: n.generateCoord, encodeDefine: e.getEncode(), encodeDefaulter: u, canOmitUnusedDimensions: !o }; const c = id(i, h); const p = fd(c.dimensions, n.createInvertedIndices, a); const d = o ? null : r.getSharedDataStore(c); const f = ud(e, { schema: c, store: d }); const g = new TR(c, e); g.setCalculationInfo(f); const y = p != null && yd(i) ? function (t, e, n, i) { return i === p ? n : this.defaultDimValueGetter(t, e, n, i) } : null; return g.hasItemOption = !1, g.initData(o ? i : d, null, y), g } function yd (t) { if (t.sourceFormat === RA) { const e = vd(t.data || []); return !M(Lr(e)) } } function vd (t) { for (var e = 0; e < t.length && t[e] == null;)e++; return t[e] } function md (t) { return k(t) && t.value != null ? t.value : t + '' } function _d (t) { return t.type === 'interval' || t.type === 'log' } function xd (t, e, n, i) { const r = {}; const o = t[1] - t[0]; let a = r.interval = _r(o / e, !0); n != null && n > a && (a = r.interval = n), i != null && a > i && (a = r.interval = i); const s = r.intervalPrecision = bd(a); const l = r.niceTickExtent = [ar(Math.ceil(t[0] / a) * a, s), ar(Math.floor(t[1] / a) * a, s)]; return Md(l, t), r } function wd (t) { const e = Math.pow(10, mr(t)); let n = t / e; return n ? n === 2 ? n = 3 : n === 3 ? n = 5 : n *= 2 : n = 1, ar(n * e) } function bd (t) { return lr(t) + 2 } function Sd (t, e, n) { t[e] = Math.max(Math.min(t[e], n[1]), n[0]) } function Md (t, e) { !isFinite(t[0]) && (t[0] = e[0]), !isFinite(t[1]) && (t[1] = e[1]), Sd(t, 0, e), Sd(t, 1, e), t[0] > t[1] && (t[0] = t[1]) } function Td (t, e) { return t >= e[0] && t <= e[1] } function Id (t, e) { return e[1] === e[0] ? 0.5 : (t - e[0]) / (e[1] - e[0]) } function Cd (t, e) { return t * (e[1] - e[0]) + e[0] } function Dd (t) { return M(t) ? RR ? new Float32Array(t) : t : new NR(t) } function kd (t) { return t.get('stack') || zR + t.seriesIndex } function Ad (t) { return t.dim + t.index } function Ld (t) { const e = []; const n = t.axis; const i = 'axis0'; if (n.type === 'category') { for (var r = n.getBandWidth(), o = 0; o < t.count; o++)e.push(c({ bandWidth: r, axisKey: i, stackId: zR + o }, t)); for (var a = Nd(e), s = [], o = 0; o < t.count; o++) { const l = a[i][zR + o]; l.offsetCenter = l.offset + l.width / 2, s.push(l) } return s } } function Pd (t, e) { const n = []; return e.eachSeriesByType(t, function (t) { Bd(t) && n.push(t) }), n } function Od (t) { const e = {}; y(t, function (t) { const n = t.coordinateSystem; const i = n.getBaseAxis(); if (i.type === 'time' || i.type === 'value') for (let r = t.getData(), o = i.dim + '_' + i.index, a = r.getDimensionIndex(r.mapDimension(i.dim)), s = r.getStore(), l = 0, u = s.count(); u > l; ++l) { const h = s.get(a, l); e[o] ? e[o].push(h) : e[o] = [h] } }); const n = {}; for (const i in e) if (e.hasOwnProperty(i)) { const r = e[i]; if (r) { r.sort(function (t, e) { return t - e }); for (var o = null, a = 1; a < r.length; ++a) { const s = r[a] - r[a - 1]; s > 0 && (o = o === null ? s : Math.min(o, s)) }n[i] = o } } return n } function Rd (t) { const e = Od(t); const n = []; return y(t, function (t) { let i; const r = t.coordinateSystem; const o = r.getBaseAxis(); const a = o.getExtent(); if (o.type === 'category')i = o.getBandWidth(); else if (o.type === 'value' || o.type === 'time') { const s = o.dim + '_' + o.index; const l = e[s]; const u = Math.abs(a[1] - a[0]); const h = o.scale.getExtent(); const c = Math.abs(h[1] - h[0]); i = l ? u / c * l : u } else { const p = t.getData(); i = Math.abs(a[1] - a[0]) / p.count() } const d = or(t.get('barWidth'), i); const f = or(t.get('barMaxWidth'), i); const g = or(t.get('barMinWidth') || (Ed(t) ? 0.5 : 1), i); const y = t.get('barGap'); const v = t.get('barCategoryGap'); n.push({ bandWidth: i, barWidth: d, barMaxWidth: f, barMinWidth: g, barGap: y, barCategoryGap: v, axisKey: Ad(o), stackId: kd(t) }) }), Nd(n) } function Nd (t) { const e = {}; y(t, function (t) { const n = t.axisKey; const i = t.bandWidth; const r = e[n] || { bandWidth: i, remainedWidth: i, autoWidthCount: 0, categoryGap: null, gap: '20%', stacks: {} }; const o = r.stacks; e[n] = r; const a = t.stackId; o[a] || r.autoWidthCount++, o[a] = o[a] || { width: 0, maxWidth: 0 }; let s = t.barWidth; s && !o[a].width && (o[a].width = s, s = Math.min(r.remainedWidth, s), r.remainedWidth -= s); const l = t.barMaxWidth; l && (o[a].maxWidth = l); const u = t.barMinWidth; u && (o[a].minWidth = u); const h = t.barGap; h != null && (r.gap = h); const c = t.barCategoryGap; c != null && (r.categoryGap = c) }); const n = {}; return y(e, function (t, e) { n[e] = {}; const i = t.stacks; const r = t.bandWidth; let o = t.categoryGap; if (o == null) { const a = w(i).length; o = Math.max(35 - 4 * a, 15) + '%' } const s = or(o, r); const l = or(t.gap, 1); let u = t.remainedWidth; let h = t.autoWidthCount; let c = (u - s) / (h + (h - 1) * l); c = Math.max(c, 0), y(i, function (t) { const e = t.maxWidth; const n = t.minWidth; if (t.width) { var i = t.width; e && (i = Math.min(i, e)), n && (i = Math.max(i, n)), t.width = i, u -= i + l * i, h-- } else { var i = c; e && i > e && (i = Math.min(e, u)), n && n > i && (i = n), i !== c && (t.width = i, u -= i + l * i, h--) } }), c = (u - s) / (h + (h - 1) * l), c = Math.max(c, 0); let p; let d = 0; y(i, function (t) { t.width || (t.width = c), p = t, d += t.width * (1 + l) }), p && (d -= p.width * l); let f = -d / 2; y(i, function (t, i) { n[e][i] = n[e][i] || { bandWidth: r, offset: f, width: t.width }, f += t.width * (1 + l) }) }), n } function zd (t, e, n) { if (t && e) { const i = t[Ad(e)]; return i != null && n != null ? i[kd(n)] : i } } function Bd (t) { return t.coordinateSystem && t.coordinateSystem.type === 'cartesian2d' } function Ed (t) { return t.pipelineContext && t.pipelineContext.large } function Vd (t, e, n, i) { const r = yr(e); const o = yr(n); const a = function (t) { return Ll(r, t, i) === Ll(o, t, i) }; const s = function () { return a('year') }; const l = function () { return s() && a('month') }; const u = function () { return l() && a('day') }; const h = function () { return u() && a('hour') }; const c = function () { return h() && a('minute') }; const p = function () { return c() && a('second') }; const d = function () { return p() && a('millisecond') }; switch (t) { case 'year':return s(); case 'month':return l(); case 'day':return u(); case 'hour':return h(); case 'minute':return c(); case 'second':return p(); case 'millisecond':return d() } } function Fd (t) { return t /= pA, t > 16 ? 16 : t > 7.5 ? 7 : t > 3.5 ? 4 : t > 1.5 ? 2 : 1 } function Hd (t) { const e = 30 * pA; return t /= e, t > 6 ? 6 : t > 3 ? 3 : t > 2 ? 2 : 1 } function Wd (t) { return t /= cA, t > 12 ? 12 : t > 6 ? 6 : t > 3.5 ? 4 : t > 2 ? 2 : 1 } function Gd (t, e) { return t /= e ? hA : uA, t > 30 ? 30 : t > 20 ? 20 : t > 15 ? 15 : t > 10 ? 10 : t > 5 ? 5 : t > 2 ? 2 : 1 } function Xd (t) { return _r(t, !0) } function Yd (t, e, n) { const i = new Date(t); switch (Tl(e)) { case 'year':case 'month':i[Fl(n)](0); case 'day':i[Hl(n)](1); case 'hour':i[Wl(n)](0); case 'minute':i[Gl(n)](0); case 'second':i[Xl(n)](0), i[Yl(n)](0) } return i.getTime() } function Ud (t, e, n, i) { function r (t, e, n, r, o, a, s) { for (var l = new Date(e), u = e, h = l[r](); n > u && u <= i[1];)s.push({ value: u }), h += t, l[o](h), u = l.getTime(); s.push({ value: u, notAdd: !0 }) } function o (t, o, a) { const s = []; const l = !o.length; if (!Vd(Tl(t), i[0], i[1], n)) { l && (o = [{ value: Yd(new Date(i[0]), t, n) }, { value: i[1] }]); for (var u = 0; u < o.length - 1; u++) { const h = o[u].value; const c = o[u + 1].value; if (h !== c) { let p = void 0; let d = void 0; let f = void 0; let g = !1; switch (t) { case 'year':p = Math.max(1, Math.round(e / pA / 365)), d = Pl(n), f = Vl(n); break; case 'half-year':case 'quarter':case 'month':p = Hd(e), d = Ol(n), f = Fl(n); break; case 'week':case 'half-week':case 'day':p = Fd(e, 31), d = Rl(n), f = Hl(n), g = !0; break; case 'half-day':case 'quarter-day':case 'hour':p = Wd(e), d = Nl(n), f = Wl(n); break; case 'minute':p = Gd(e, !0), d = zl(n), f = Gl(n); break; case 'second':p = Gd(e, !1), d = Bl(n), f = Xl(n); break; case 'millisecond':p = Xd(e), d = El(n), f = Yl(n) }r(p, h, c, d, f, g, s), t === 'year' && a.length > 1 && u === 0 && a.unshift({ value: a[0].value - p }) } } for (var u = 0; u < s.length; u++)a.push(s[u]); return s } } for (var a = 1e4, s = mA, l = 0, u = [], h = [], c = 0, p = 0, d = 0; d < s.length && l++ < a; ++d) { const f = Tl(s[d]); if (Il(s[d])) { o(s[d], u[u.length - 1] || [], h); const g = s[d + 1] ? Tl(s[d + 1]) : null; if (f !== g) { if (h.length) { p = c, h.sort(function (t, e) { return t.value - e.value }); for (var y = [], m = 0; m < h.length; ++m) { const x = h[m].value; (m === 0 || h[m - 1].value !== x) && (y.push(h[m]), x >= i[0] && x <= i[1] && c++) } const w = (i[1] - i[0]) / e; if (c > 1.5 * w && p > w / 1.5) break; if (u.push(y), c > w || t === s[d]) break }h = [] } } } for (var b = _(v(u, function (t) { return _(t, function (t) { return t.value >= i[0] && t.value <= i[1] && !t.notAdd }) }), function (t) { return t.length > 0 }), S = [], M = b.length - 1, d = 0; d < b.length; ++d) for (let T = b[d], I = 0; I < T.length; ++I)S.push({ value: T[I].value, level: M - d }); S.sort(function (t, e) { return t.value - e.value }); for (var C = [], d = 0; d < S.length; ++d)(d === 0 || S[d].value !== S[d - 1].value) && C.push(S[d]); return C } function Zd (t, e) { return WR(t, lr(e)) } function jd (t, e, n) { let i = t.rawExtentInfo; return i || (i = new qR(t, e, n), t.rawExtentInfo = i, i) } function qd (t, e) { return e == null ? null : z(e) ? 0 / 0 : t.parse(e) } function Kd (t, e) { const n = t.type; const i = jd(t, e, t.getExtent()).calculate(); t.setBlank(i.isBlank); let r = i.min; let o = i.max; const a = e.ecModel; if (a && n === 'time') { const s = Pd('bar', a); let l = !1; if (y(s, function (t) { l = l || t.getBaseAxis() === e.axis }), l) { const u = Rd(s); const h = $d(r, o, e, u); r = h.min, o = h.max } } return { extent: [r, o], fixMin: i.minFixed, fixMax: i.maxFixed } } function $d (t, e, n, i) { const r = n.axis.getExtent(); const o = r[1] - r[0]; const a = zd(i, n.axis); if (void 0 === a) return { min: t, max: e }; let s = 1 / 0; y(a, function (t) { s = Math.min(t.offset, s) }); let l = -1 / 0; y(a, function (t) { l = Math.max(t.offset + t.width, l) }), s = Math.abs(s), l = Math.abs(l); const u = s + l; const h = e - t; const c = 1 - (s + l) / o; const p = h / c - h; return e += p * (l / u), t -= p * (s / u), { min: t, max: e } } function Qd (t, e) { const n = e; const i = Kd(t, n); const r = i.extent; const o = n.get('splitNumber'); t instanceof ZR && (t.base = n.get('logBase')); const a = t.type; const s = n.get('interval'); const l = a === 'interval' || a === 'time'; t.setExtent(r[0], r[1]), t.calcNiceExtent({ splitNumber: o, fixMin: i.fixMin, fixMax: i.fixMax, minInterval: l ? n.get('minInterval') : null, maxInterval: l ? n.get('maxInterval') : null }), s != null && t.setInterval && t.setInterval(s) } function Jd (t, e) { if (e = e || t.get('type')) switch (e) { case 'category':return new LR({ ordinalMeta: t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(), extent: [1 / 0, -1 / 0] }); case 'time':return new ER({ locale: t.ecModel.getLocaleModel(), useUTC: t.ecModel.get('useUTC') }); default:return new (DR.getClass(e) || OR)() } } function tf (t) { const e = t.scale.getExtent(); const n = e[0]; const i = e[1]; return !(n > 0 && i > 0 || n < 0 && i < 0) } function ef (t) { const e = t.getLabelModel().get('formatter'); const n = t.type === 'category' ? t.scale.getExtent()[0] : null; return t.scale.type === 'time' ? (function (e) { return function (n, i) { return t.scale.getFormattedLabel(n, i, e) } }(e)) : I(e) ? (function (e) { return function (n) { const i = t.scale.getLabel(n); const r = e.replace('{value}', i != null ? i : ''); return r } }(e)) : T(e) ? (function (e) { return function (i, r) { return n != null && (r = i.value - n), e(nf(t, i), r, i.level != null ? { level: i.level } : null) } }(e)) : function (e) { return t.scale.getLabel(e) } } function nf (t, e) { return t.type === 'category' ? t.scale.getLabel(e) : e.value } function rf (t) { const e = t.model; const n = t.scale; if (e.get(['axisLabel', 'show']) && !n.isBlank()) { let i; let r; const o = n.getExtent(); n instanceof LR ? r = n.count() : (i = n.getTicks(), r = i.length); let a; const s = t.getLabelModel(); const l = ef(t); let u = 1; r > 40 && (u = Math.ceil(r / 40)); for (let h = 0; r > h; h += u) { const c = i ? i[h] : { value: o[0] + h }; const p = l(c, h); const d = s.getTextRect(p); const f = of(d, s.get('rotate') || 0); a ? a.union(f) : a = f } return a } } function of (t, e) { const n = e * Math.PI / 180; const i = t.width; const r = t.height; const o = i * Math.abs(Math.cos(n)) + Math.abs(r * Math.sin(n)); const a = i * Math.abs(Math.sin(n)) + Math.abs(r * Math.cos(n)); const s = new $M(t.x, t.y, o, a); return s } function af (t) { const e = t.get('interval'); return e == null ? 'auto' : e } function sf (t) { return t.type === 'category' && af(t.getLabelModel()) === 0 } function lf (t, e) { const n = {}; return y(t.mapDimensionsAll(e), function (e) { n[pd(t, e)] = !0 }), w(n) } function uf (t, e, n) { e && y(lf(e, n), function (n) { const i = e.getApproximateExtent(n); i[0] < t[0] && (t[0] = i[0]), i[1] > t[1] && (t[1] = i[1]) }) } function hf (t) { return gd(null, t) } function cf (t, e) { let n = e; e instanceof Jk || (n = new Jk(e)); const i = Jd(n); return i.setExtent(t[0], t[1]), Qd(i, n), i } function pf (t) { f(t, QR) } function df (t, e) { return e = e || {}, ul(t, null, null, e.state !== 'normal') } function ff (t) { return M(t) ? void y(t, function (t) { ff(t) }) : void (p(eN, t) >= 0 || (eN.push(t), T(t) && (t = { install: t }), t.install(nN))) } function gf (t, e) { return Math.abs(t - e) < iN } function yf (t, e, n) { let i = 0; let r = t[0]; if (!r) return !1; for (let o = 1; o < t.length; o++) { const a = t[o]; i += Wo(r[0], r[1], a[0], a[1], e, n), r = a } const s = t[0]; return gf(r[0], s[0]) && gf(r[1], s[1]) || (i += Wo(r[0], r[1], s[0], s[1], e, n)), i !== 0 } function vf (t, e) { for (let n = 0; n < t.length; n++)ve(t[n], t[n], e) } function mf (t, e, n, i) { for (let r = 0; r < t.length; r++) { let o = t[r]; i && (o = i.project(o)), o && isFinite(o[0]) && isFinite(o[1]) && (me(e, e, o), _e(n, n, o)) } } function _f (t) { for (var e = 0, n = 0, i = 0, r = t.length, o = t[r - 1][0], a = t[r - 1][1], s = 0; r > s; s++) { const l = t[s][0]; const u = t[s][1]; const h = o * u - l * a; e += h, n += (o + l) * h, i += (a + u) * h, o = l, a = u } return e ? [n / e / 3, i / e / 3, e] : [t[0][0] || 0, t[0][1] || 0] } function xf (t) { if (!t.UTF8Encoding) return t; const e = t; let n = e.UTF8Scale; n == null && (n = 1024); const i = e.features; return y(i, function (t) { const e = t.geometry; const i = e.encodeOffsets; const r = e.coordinates; if (i) switch (e.type) { case 'LineString':e.coordinates = bf(r, i, n); break; case 'Polygon':wf(r, i, n); break; case 'MultiLineString':wf(r, i, n); break; case 'MultiPolygon':y(r, function (t, e) { return wf(t, i[e], n) }) } }), e.UTF8Encoding = !1, e } function wf (t, e, n) { for (let i = 0; i < t.length; i++)t[i] = bf(t[i], e[i], n) } function bf (t, e, n) { for (var i = [], r = e[0], o = e[1], a = 0; a < t.length; a += 2) { let s = t.charCodeAt(a) - 64; let l = t.charCodeAt(a + 1) - 64; s = s >> 1 ^ -(1 & s), l = l >> 1 ^ -(1 & l), s += r, l += o, r = s, o = l, i.push([s / n, l / n]) } return i } function Sf (t, e) { return t = xf(t), v(_(t.features, function (t) { return t.geometry && t.properties && t.geometry.coordinates.length > 0 }), function (t) { const n = t.properties; const i = t.geometry; const r = []; switch (i.type) { case 'Polygon':var o = i.coordinates; r.push(new aN(o[0], o.slice(1))); break; case 'MultiPolygon':y(i.coordinates, function (t) { t[0] && r.push(new aN(t[0], t.slice(1))) }); break; case 'LineString':r.push(new sN([i.coordinates])); break; case 'MultiLineString':r.push(new sN(i.coordinates)) } const a = new lN(n[e || 'name'], r, n.cp); return a.properties = n, a }) } function Mf (t) { return t.type === 'category' ? If(t) : kf(t) } function Tf (t, e) { return t.type === 'category' ? Df(t, e) : { ticks: v(t.scale.getTicks(), function (t) { return t.value }) } } function If (t) { const e = t.getLabelModel(); const n = Cf(t, e); return !e.get('show') || t.scale.isBlank() ? { labels: [], labelCategoryInterval: n.labelCategoryInterval } : n } function Cf (t, e) { const n = Af(t, 'labels'); const i = af(e); const r = Lf(n, i); if (r) return r; let o, a; return T(i) ? o = Bf(t, i) : (a = i === 'auto' ? Of(t) : i, o = zf(t, a)), Pf(n, i, { labels: o, labelCategoryInterval: a }) } function Df (t, e) { const n = Af(t, 'ticks'); const i = af(e); const r = Lf(n, i); if (r) return r; let o, a; if ((!e.get('show') || t.scale.isBlank()) && (o = []), T(i))o = Bf(t, i, !0); else if (i === 'auto') { const s = Cf(t, t.getLabelModel()); a = s.labelCategoryInterval, o = v(s.labels, function (t) { return t.tickValue }) } else a = i, o = zf(t, a, !0); return Pf(n, i, { ticks: o, tickCategoryInterval: a }) } function kf (t) { const e = t.scale.getTicks(); const n = ef(t); return { labels: v(e, function (e, i) { return { level: e.level, formattedLabel: n(e, i), rawLabel: t.scale.getLabel(e), tickValue: e.value } }) } } function Af (t, e) { return fN(t)[e] || (fN(t)[e] = []) } function Lf (t, e) { for (let n = 0; n < t.length; n++) if (t[n].key === e) return t[n].value } function Pf (t, e, n) { return t.push({ key: e, value: n }), n } function Of (t) { const e = fN(t).autoInterval; return e != null ? e : fN(t).autoInterval = t.calculateCategoryInterval() } function Rf (t) { const e = Nf(t); const n = ef(t); const i = (e.axisRotate - e.labelRotate) / 180 * Math.PI; const r = t.scale; const o = r.getExtent(); const a = r.count(); if (o[1] - o[0] < 1) return 0; let s = 1; a > 40 && (s = Math.max(1, Math.floor(a / 40))); for (var l = o[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), h = Math.abs(u * Math.cos(i)), c = Math.abs(u * Math.sin(i)), p = 0, d = 0; l <= o[1]; l += s) { let f = 0; let g = 0; const y = Bi(n({ value: l }), e.font, 'center', 'top'); f = 1.3 * y.width, g = 1.3 * y.height, p = Math.max(p, f, 7), d = Math.max(d, g, 7) } let v = p / h; let m = d / c; isNaN(v) && (v = 1 / 0), isNaN(m) && (m = 1 / 0); let _ = Math.max(0, Math.floor(Math.min(v, m))); const x = fN(t.model); const w = t.getExtent(); const b = x.lastAutoInterval; const S = x.lastTickCount; return b != null && S != null && Math.abs(b - _) <= 1 && Math.abs(S - a) <= 1 && b > _ && x.axisExtent0 === w[0] && x.axisExtent1 === w[1] ? _ = b : (x.lastTickCount = a, x.lastAutoInterval = _, x.axisExtent0 = w[0], x.axisExtent1 = w[1]), _ } function Nf (t) { const e = t.getLabelModel(); return { axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0, labelRotate: e.get('rotate') || 0, font: e.getFont() } } function zf (t, e, n) { function i (t) { const e = { value: t }; l.push(n ? t : { formattedLabel: r(e), rawLabel: o.getLabel(e), tickValue: t }) } var r = ef(t); var o = t.scale; const a = o.getExtent(); const s = t.getLabelModel(); var l = []; const u = Math.max((e || 0) + 1, 1); let h = a[0]; const c = o.count(); h !== 0 && u > 1 && c / u > 2 && (h = Math.round(Math.ceil(h / u) * u)); const p = sf(t); const d = s.get('showMinLabel') || p; const f = s.get('showMaxLabel') || p; d && h !== a[0] && i(a[0]); for (var g = h; g <= a[1]; g += u)i(g); return f && g - u !== a[1] && i(a[1]), l } function Bf (t, e, n) { const i = t.scale; const r = ef(t); const o = []; return y(i.getTicks(), function (t) { const a = i.getLabel(t); const s = t.value; e(t.value, a) && o.push(n ? s : { formattedLabel: r(t), rawLabel: a, tickValue: s }) }), o } function Ef (t, e) { const n = t[1] - t[0]; const i = e; const r = n / i / 2; t[0] += r, t[1] -= r } function Vf (t, e, n, i) { function r (t, e) { return t = ar(t), e = ar(e), p ? t > e : e > t } const o = e.length; if (t.onBand && !n && o) { let a; let s; const l = t.getExtent(); if (o === 1)e[0].coord = l[0], a = e[1] = { coord: l[0] }; else { const u = e[o - 1].tickValue - e[0].tickValue; const h = (e[o - 1].coord - e[0].coord) / u; y(e, function (t) { t.coord -= h / 2 }); const c = t.scale.getExtent(); s = 1 + c[1] - e[o - 1].tickValue, a = { coord: e[o - 1].coord + h * s }, e.push(a) } var p = l[0] > l[1]; r(e[0].coord, l[0]) && (i ? e[0].coord = l[0] : e.shift()), i && r(l[0], e[0].coord) && e.unshift({ coord: l[0] }), r(l[1], a.coord) && (i ? a.coord = l[1] : e.pop()), i && r(a.coord, l[1]) && e.push({ coord: l[1] }) } } function Ff (t) { const e = CA.extend(t); return CA.registerClass(e), e } function Hf (t) { const e = YL.extend(t); return YL.registerClass(e), e } function Wf (t) { const e = XL.extend(t); return XL.registerClass(e), e } function Gf (t) { const e = jL.extend(t); return jL.registerClass(e), e } function Xf (t, e, n, i, r) { const o = n.width; const a = n.height; switch (t) { case 'top':i.set(n.x + o / 2, n.y - e), r.set(0, -1); break; case 'bottom':i.set(n.x + o / 2, n.y + a + e), r.set(0, 1); break; case 'left':i.set(n.x - e, n.y + a / 2), r.set(-1, 0); break; case 'right':i.set(n.x + o + e, n.y + a / 2), r.set(1, 0) } } function Yf (t, e, n, i, r, o, a, s, l) { a -= t, s -= e; const u = Math.sqrt(a * a + s * s); a /= u, s /= u; const h = a * n + t; const c = s * n + e; if (Math.abs(i - r) % vN < 1e-4) return l[0] = h, l[1] = c, u - n; if (o) { const p = i; i = Fo(r), r = Fo(p) } else i = Fo(i), r = Fo(r); i > r && (r += vN); let d = Math.atan2(s, a); if (d < 0 && (d += vN), d >= i && r >= d || d + vN >= i && r >= d + vN) return l[0] = h, l[1] = c, u - n; const f = n * Math.cos(i) + t; const g = n * Math.sin(i) + e; const y = n * Math.cos(r) + t; const v = n * Math.sin(r) + e; const m = (f - a) * (f - a) + (g - s) * (g - s); const _ = (y - a) * (y - a) + (v - s) * (v - s); return _ > m ? (l[0] = f, l[1] = g, Math.sqrt(m)) : (l[0] = y, l[1] = v, Math.sqrt(_)) } function Uf (t, e, n, i, r, o, a, s) { const l = r - t; const u = o - e; let h = n - t; let c = i - e; const p = Math.sqrt(h * h + c * c); h /= p, c /= p; const d = l * h + u * c; let f = d / p; s && (f = Math.min(Math.max(f, 0), 1)), f *= p; const g = a[0] = t + f * h; const y = a[1] = e + f * c; return Math.sqrt((g - r) * (g - r) + (y - o) * (y - o)) } function Zf (t, e, n, i, r, o, a) { n < 0 && (t += n, n = -n), i < 0 && (e += i, i = -i); const s = t + n; const l = e + i; const u = a[0] = Math.min(Math.max(r, t), s); const h = a[1] = Math.min(Math.max(o, e), l); return Math.sqrt((u - r) * (u - r) + (h - o) * (h - o)) } function jf (t, e, n) { const i = Zf(e.x, e.y, e.width, e.height, t.x, t.y, xN); return n.set(xN[0], xN[1]), i } function qf (t, e, n) { for (var i, r, o = 0, a = 0, s = 0, l = 0, u = 1 / 0, h = e.data, c = t.x, p = t.y, d = 0; d < h.length;) { const f = h[d++]; d === 1 && (o = h[d], a = h[d + 1], s = o, l = a); let g = u; switch (f) { case mN.M:s = h[d++], l = h[d++], o = s, a = l; break; case mN.L:g = Uf(o, a, h[d], h[d + 1], c, p, xN, !0), o = h[d++], a = h[d++]; break; case mN.C:g = yn(o, a, h[d++], h[d++], h[d++], h[d++], h[d], h[d + 1], c, p, xN), o = h[d++], a = h[d++]; break; case mN.Q:g = Sn(o, a, h[d++], h[d++], h[d], h[d + 1], c, p, xN), o = h[d++], a = h[d++]; break; case mN.A:var y = h[d++]; var v = h[d++]; var m = h[d++]; var _ = h[d++]; var x = h[d++]; var w = h[d++]; d += 1; var b = !!(1 - h[d++]); i = Math.cos(x) * m + y, r = Math.sin(x) * _ + v, d <= 1 && (s = i, l = r); var S = (c - y) * _ / m + y; g = Yf(y, v, _, x, x + w, b, S, p, xN), o = Math.cos(x + w) * m + y, a = Math.sin(x + w) * _ + v; break; case mN.R:s = o = h[d++], l = a = h[d++]; var M = h[d++]; var T = h[d++]; g = Zf(s, l, M, T, c, p, xN); break; case mN.Z:g = Uf(o, a, s, l, c, p, xN, !0), o = s, a = l }u > g && (u = g, n.set(xN[0], xN[1])) } return u } function Kf (t, e) { if (t) { const n = t.getTextGuideLine(); const i = t.getTextContent(); if (i && n) { const r = t.textGuideLineConfig || {}; const o = [[0, 0], [0, 0], [0, 0]]; const a = r.candidates || _N; const s = i.getBoundingRect().clone(); s.applyTransform(i.getComputedTransform()); let l = 1 / 0; const u = r.anchor; const h = t.getComputedTransform(); const c = h && Ye([], h); const p = e.get('length2') || 0; u && SN.copy(u); for (let d = 0; d < a.length; d++) { const f = a[d]; Xf(f, 0, s, wN, MN), WM.scaleAndAdd(bN, wN, MN, p), bN.transform(c); const g = t.getBoundingRect(); const y = u ? u.distance(bN) : t instanceof ZC ? qf(bN, t.path, SN) : jf(bN, g, SN); l > y && (l = y, bN.transform(h), SN.transform(h), SN.toArray(o[0]), bN.toArray(o[1]), wN.toArray(o[2])) }$f(o, e.get('minTurnAngle')), n.setShape({ points: o }) } } } function $f (t, e) { if (e <= 180 && e > 0) { e = e / 180 * Math.PI, wN.fromArray(t[0]), bN.fromArray(t[1]), SN.fromArray(t[2]), WM.sub(MN, wN, bN), WM.sub(TN, SN, bN); const n = MN.len(); const i = TN.len(); if (!(n < 0.001 || i < 0.001)) { MN.scale(1 / n), TN.scale(1 / i); const r = MN.dot(TN); const o = Math.cos(e); if (r > o) { const a = Uf(bN.x, bN.y, SN.x, SN.y, wN.x, wN.y, IN, !1); CN.fromArray(IN), CN.scaleAndAdd(TN, a / Math.tan(Math.PI - e)); const s = SN.x !== bN.x ? (CN.x - bN.x) / (SN.x - bN.x) : (CN.y - bN.y) / (SN.y - bN.y); if (isNaN(s)) return; s < 0 ? WM.copy(CN, bN) : s > 1 && WM.copy(CN, SN), CN.toArray(t[1]) } } } } function Qf (t, e, n, i) { const r = n === 'normal'; const o = r ? t : t.ensureState(n); o.ignore = e; let a = i.get('smooth'); a && a === !0 && (a = 0.3), o.shape = o.shape || {}, a > 0 && (o.shape.smooth = a); const s = i.getModel('lineStyle').getLineStyle(); r ? t.useStyle(s) : o.style = s } function Jf (t, e) { const n = e.smooth; const i = e.points; if (i) if (t.moveTo(i[0][0], i[0][1]), n > 0 && i.length >= 3) { const r = MM(i[0], i[1]); const o = MM(i[1], i[2]); if (!r || !o) return t.lineTo(i[1][0], i[1][1]), void t.lineTo(i[2][0], i[2][1]); const a = Math.min(r, o) * n; const s = ye([], i[1], i[0], a / r); const l = ye([], i[1], i[2], a / o); const u = ye([], s, l, 0.5); t.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), t.bezierCurveTo(l[0], l[1], l[0], l[1], i[2][0], i[2][1]) } else for (let h = 1; h < i.length; h++)t.lineTo(i[h][0], i[h][1]) } function tg (t, e, n) { let i = t.getTextGuideLine(); const r = t.getTextContent(); if (!r) return void (i && t.removeTextGuideLine()); for (var o = e.normal, a = o.get('show'), s = r.ignore, l = 0; l < xD.length; l++) { const u = xD[l]; const h = e[u]; const p = u === 'normal'; if (h) { const d = h.get('show'); const f = p ? s : E(r.states[u] && r.states[u].ignore, s); if (f || !E(d, a)) { const g = p ? i : i && i.states[u]; g && (g.ignore = !0); continue }i || (i = new hk(), t.setTextGuideLine(i), p || !s && a || Qf(i, !0, 'normal', e.normal), t.stateProxy && (i.stateProxy = t.stateProxy)), Qf(i, !1, u, h) } } if (i) { c(i.style, n), i.style.fill = null; const y = o.get('showAbove'); const v = t.textGuideLineConfig = t.textGuideLineConfig || {}; v.showAbove = y || !1, i.buildPath = Jf } } function eg (t, e) { e = e || 'labelLine'; for (var n = { normal: t.getModel(e) }, i = 0; i < _D.length; i++) { const r = _D[i]; n[r] = t.getModel([r, e]) } return n } function ng (t) { for (var e = [], n = 0; n < t.length; n++) { const i = t[n]; if (!i.defaultAttr.ignore) { const r = i.label; const o = r.getComputedTransform(); const a = r.getBoundingRect(); const s = !o || o[1] < 1e-5 && o[2] < 1e-5; const l = r.style.margin || 0; const u = a.clone(); u.applyTransform(o), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l; const h = s ? new Ck(a, o) : null; e.push({ label: r, labelLine: i.labelLine, rect: u, localRect: a, obb: h, priority: i.priority, defaultAttr: i.defaultAttr, layoutOption: i.computedLayoutOption, axisAligned: s, transform: o }) } } return e } function ig (t, e, n, i, r, o) { function a () { w = S.rect[e] - i, b = r - M.rect[e] - M.rect[n] } function s (t, e, n) { if (t < 0) { const i = Math.min(e, -t); if (i > 0) { l(i * n, 0, c); const r = i + t; r < 0 && u(-r * n, 1) } else u(-t * n, 1) } } function l (n, i, r) { n !== 0 && (f = !0); for (let o = i; r > o; o++) { const a = t[o]; const s = a.rect; s[e] += n, a.label[e] += n } } function u (i, r) { for (var o = [], a = 0, s = 1; c > s; s++) { const u = t[s - 1].rect; const h = Math.max(t[s].rect[e] - u[e] - u[n], 0); o.push(h), a += h } if (a) { const p = Math.min(Math.abs(i) / a, r); if (i > 0) for (var s = 0; c - 1 > s; s++) { var d = o[s] * p; l(d, 0, s + 1) } else for (var s = c - 1; s > 0; s--) { var d = o[s - 1] * p; l(-d, s, c) } } } function h (t) { const e = t < 0 ? -1 : 1; t = Math.abs(t); for (let n = Math.ceil(t / (c - 1)), i = 0; c - 1 > i; i++) if (e > 0 ? l(n, 0, i + 1) : l(-n, c - i - 1, c), t -= n, t <= 0) return } var c = t.length; if (!(c < 2)) { t.sort(function (t, n) { return t.rect[e] - n.rect[e] }); for (var p, d = 0, f = !1, g = [], y = 0, v = 0; c > v; v++) { const m = t[v]; const _ = m.rect; p = _[e] - d, p < 0 && (_[e] -= p, m.label[e] -= p, f = !0); const x = Math.max(-p, 0); g.push(x), y += x, d = _[e] + _[n] }y > 0 && o && l(-y / c, 0, c); var w; var b; var S = t[0]; var M = t[c - 1]; return a(), w < 0 && u(-w, 0.8), b < 0 && u(b, 0.8), a(), s(w, b, 1), s(b, w, -1), a(), w < 0 && h(-w), b < 0 && h(b), f } } function rg (t, e, n, i) { return ig(t, 'x', 'width', e, n, i) } function og (t, e, n, i) { return ig(t, 'y', 'height', e, n, i) } function ag (t) { function e (t) { if (!t.ignore) { const e = t.ensureState('emphasis'); e.ignore == null && (e.ignore = !1) }t.ignore = !0 } const n = []; t.sort(function (t, e) { return e.priority - t.priority }); for (let i = new $M(0, 0, 0, 0), r = 0; r < t.length; r++) { const o = t[r]; const a = o.axisAligned; const s = o.localRect; const l = o.transform; const u = o.label; const h = o.labelLine; i.copy(o.rect), i.width -= 0.1, i.height -= 0.1, i.x += 0.05, i.y += 0.05; for (var c = o.obb, p = !1, d = 0; d < n.length; d++) { const f = n[d]; if (i.intersect(f.rect)) { if (a && f.axisAligned) { p = !0; break } if (f.obb || (f.obb = new Ck(f.localRect, f.transform)), c || (c = new Ck(s, l)), c.intersect(f.obb)) { p = !0; break } } }p ? (e(u), h && e(h)) : (u.attr('ignore', o.defaultAttr.ignore), h && h.attr('ignore', o.defaultAttr.labelGuideIgnore), n.push(o)) } } function sg (t) { if (t) { for (var e = [], n = 0; n < t.length; n++)e.push(t[n].slice()); return e } } function lg (t, e) { const n = t.label; const i = e && e.getTextGuideLine(); return { dataIndex: t.dataIndex, dataType: t.dataType, seriesIndex: t.seriesModel.seriesIndex, text: t.label.style.text, rect: t.hostRect, labelRect: t.rect, align: n.style.align, verticalAlign: n.style.verticalAlign, labelLinePoints: sg(i && i.shape.points) } } function ug (t, e, n) { for (let i = 0; i < n.length; i++) { const r = n[i]; e[r] != null && (t[r] = e[r]) } } function hg (t) { t.registerUpdateLifecycle('series:beforeupdate', function (t, e) { let n = RN(e).labelManager; n || (n = RN(e).labelManager = new ON()), n.clearLabels() }), t.registerUpdateLifecycle('series:layoutlabels', function (t, e, n) { const i = RN(e).labelManager; n.updatedSeries.forEach(function (t) { i.addLabelsOfSeries(e.getViewOfSeriesModel(t)) }), i.updateLayoutConfig(e), i.layout(e), i.processLabelsOverall() }) } function cg (t, e, n) { const i = eM.createCanvas(); const r = e.getWidth(); const o = e.getHeight(); const a = i.style; return a && (a.position = 'absolute', a.left = '0', a.top = '0', a.width = r + 'px', a.height = o + 'px', i.setAttribute('data-zr-dom-id', t)), i.width = r * n, i.height = o * n, i } function pg (t) { return t ? t.__builtin__ ? !0 : typeof t.resize !== 'function' || typeof t.refresh !== 'function' ? !1 : !0 : !1 } function dg (t, e) { const n = document.createElement('div'); return n.style.cssText = ['position:relative', 'width:' + t + 'px', 'height:' + e + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';', n } function fg (t) { t.registerPainter('canvas', FN) } function gg (t) { t.registerComponentModel(HN), t.registerComponentView(WN) } function yg (t, e) { const n = t.mapDimensionsAll('defaultedLabel'); const i = n.length; if (i === 1) { const r = ph(t, e, n[0]); return r != null ? r + '' : null } if (i) { for (var o = [], a = 0; a < n.length; a++)o.push(ph(t, e, n[a])); return o.join(' ') } } function vg (t, e) { this.parent.drift(t, e) } function mg (t, e, n, i) { return !(!e || isNaN(e[0]) || isNaN(e[1]) || i.isIgnore && i.isIgnore(n) || i.clipShape && !i.clipShape.contain(e[0], e[1]) || t.getItemVisual(n, 'symbol') === 'none') } function _g (t) { return t == null || k(t) || (t = { isIgnore: t }), t || {} } function xg (t) { const e = t.hostModel; const n = e.getModel('emphasis'); return { emphasisItemStyle: n.getModel('itemStyle').getItemStyle(), blurItemStyle: e.getModel(['blur', 'itemStyle']).getItemStyle(), selectItemStyle: e.getModel(['select', 'itemStyle']).getItemStyle(), focus: n.get('focus'), blurScope: n.get('blurScope'), emphasisDisabled: n.get('disabled'), hoverScale: n.get('scale'), labelStatesModels: ll(e), cursorStyle: e.get('cursor') } } function wg (t, e) {
    return {
      seriesType: t,
      plan: oc(),
      reset: function (t) {
        const n = t.getData(); const i = t.coordinateSystem; const r = t.pipelineContext; const o = e || r.large; if (i) {
          const a = v(i.dimensions, function (t) { return n.mapDimension(t) }).slice(0, 2); const s = a.length; const l = n.getCalculationInfo('stackResultDimension'); cd(n, a[0]) && (a[0] = l), cd(n, a[1]) && (a[1] = l); const u = n.getStore(); const h = n.getDimensionIndex(a[0]); const c = n.getDimensionIndex(a[1]); return s && {
            progress: function (t, e) {
              for (var n = t.end - t.start, r = o && Dd(n * s), a = [], l = [], p = t.start, d = 0; p < t.end; p++) {
                let f = void 0; if (s === 1) { const g = u.get(h, p); f = i.dataToPoint(g, null, l) } else a[0] = u.get(h, p), a[1] = u.get(c, p), f = i.dataToPoint(a, null, l); o ? (r[d++] = f[0], r[d++] = f[1]) : e.setItemLayout(p, f.slice())
              }o && e.setLayout('points', r)
            }
          }
        }
      }
    }
  } function bg (t, n, i, r) { y(oz, function (o, a) { const s = l(l({}, rz[a], !0), r, !0); const u = (function (t) { function i () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n + 'Axis.' + a, e } return e(i, t), i.prototype.mergeDefaultAndTheme = function (t, e) { const n = su(this); const i = n ? uu(t) : {}; const r = e.getTheme(); l(t, r.get(a + 'Axis')), l(t, this.getDefaultOption()), t.type = Sg(t), n && lu(t, i, n) }, i.prototype.optionUpdated = function () { const t = this.option; t.type === 'category' && (this.__ordinalMeta = AR.createByAxisModel(this)) }, i.prototype.getCategories = function (t) { const e = this.option; return e.type === 'category' ? t ? e.data : this.__ordinalMeta.categories : void 0 }, i.prototype.getOrdinalMeta = function () { return this.__ordinalMeta }, i.type = n + 'Axis.' + a, i.defaultOption = s, i }(i)); t.registerComponentModel(u) }), t.registerSubTypeDefaulter(n + 'Axis', Sg) } function Sg (t) { return t.type || (t.data ? 'category' : 'value') } function Mg (t) { return t.type === 'interval' || t.type === 'time' } function Tg (t, e, n) { n = n || {}; const i = t.coordinateSystem; const r = e.axis; const o = {}; const a = r.getAxesOnZeroOf()[0]; const s = r.position; const l = a ? 'onZero' : s; const u = r.dim; const h = i.getRect(); const c = [h.x, h.x + h.width, h.y, h.y + h.height]; const p = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 }; const d = e.get('offset') || 0; const f = u === 'x' ? [c[2] - d, c[3] + d] : [c[0] - d, c[1] + d]; if (a) { const g = a.toGlobalCoord(a.dataToCoord(0)); f[p.onZero] = Math.max(Math.min(g, f[1]), f[0]) }o.position = [u === 'y' ? f[p[l]] : c[0], u === 'x' ? f[p[l]] : c[3]], o.rotation = Math.PI / 2 * (u === 'x' ? 0 : 1); const y = { top: -1, bottom: 1, left: -1, right: 1 }; o.labelDirection = o.tickDirection = o.nameDirection = y[s], o.labelOffset = a ? f[p[s]] - f[p.onZero] : 0, e.get(['axisTick', 'inside']) && (o.tickDirection = -o.tickDirection), B(n.labelInside, e.get(['axisLabel', 'inside'])) && (o.labelDirection = -o.labelDirection); const v = e.get(['axisLabel', 'rotate']); return o.labelRotate = l === 'top' ? -v : v, o.z2 = 1, o } function Ig (t) { return t.get('coordinateSystem') === 'cartesian2d' } function Cg (t) { const e = { xAxisModel: null, yAxisModel: null }; return y(e, function (n, i) { const r = i.replace(/Model$/, ''); const o = t.getReferringComponents(r, HI).models[0]; e[i] = o }), e } function Dg (t, e, n) { const i = OR.prototype; const r = i.getTicks.call(n); const o = i.getTicks.call(n, !0); const a = r.length - 1; const s = i.getInterval.call(n); const l = Kd(t, e); let u = l.extent; const h = l.fixMin; const c = l.fixMax; if (t.type === 'log') { const p = hz(t.base); u = [hz(u[0]) / p, hz(u[1]) / p] }t.setExtent(u[0], u[1]), t.calcNiceExtent({ splitNumber: a, fixMin: h, fixMax: c }); const d = i.getExtent.call(t); h && (u[0] = d[0]), c && (u[1] = d[1]); let f = i.getInterval.call(t); let g = u[0]; let y = u[1]; if (h && c)f = (y - g) / a; else if (h) for (y = u[0] + f * a; y < u[1] && isFinite(y) && isFinite(u[1]);)f = wd(f), y = u[0] + f * a; else if (c) for (g = u[1] - f * a; g > u[0] && isFinite(g) && isFinite(u[0]);)f = wd(f), g = u[1] - f * a; else { const v = t.getTicks().length - 1; v > a && (f = wd(f)); const m = f * a; y = Math.ceil(u[1] / f) * f, g = ar(y - m), g < 0 && u[0] >= 0 ? (g = 0, y = ar(m)) : y > 0 && u[1] <= 0 && (y = 0, g = -ar(m)) } const _ = (r[0].value - o[0].value) / s; const x = (r[a].value - o[a].value) / s; i.setExtent.call(t, g + f * _, y + f * x), i.setInterval.call(t, f), (_ || x) && i.setNiceExtent.call(t, g + f, y - f) } function kg (t, e) { return t.getCoordSysModel() === e } function Ag (t, e, n, i) { function r (t) { return t.dim + '_' + t.index }n.getAxesOnZeroOf = function () { return o ? [o] : [] }; let o; const a = t[e]; const s = n.model; const l = s.get(['axisLine', 'onZero']); const u = s.get(['axisLine', 'onZeroAxisIndex']); if (l) { if (u != null)Lg(a[u]) && (o = a[u]); else for (const h in a) if (a.hasOwnProperty(h) && Lg(a[h]) && !i[r(a[h])]) { o = a[h]; break }o && (i[r(o)] = !0) } } function Lg (t) { return t && t.type !== 'category' && t.type !== 'time' && tf(t) } function Pg (t, e) { const n = t.getExtent(); const i = n[0] + n[1]; t.toGlobalCoord = t.dim === 'x' ? function (t) { return t + e } : function (t) { return i - t + e }, t.toLocalCoord = t.dim === 'x' ? function (t) { return t - e } : function (t) { return i - t + e } } function Og (t, e, n, i) { let r; let o; const a = fr(n - t); const s = i[0] > i[1]; const l = e === 'start' && !s || e !== 'start' && s; return gr(a - pz / 2) ? (o = l ? 'bottom' : 'top', r = 'center') : gr(a - 1.5 * pz) ? (o = l ? 'top' : 'bottom', r = 'center') : (o = 'middle', r = 1.5 * pz > a && a > pz / 2 ? l ? 'left' : 'right' : l ? 'right' : 'left'), { rotation: a, textAlign: r, textVerticalAlign: o } } function Rg (t, e, n) { if (!sf(t.axis)) { const i = t.get(['axisLabel', 'showMinLabel']); const r = t.get(['axisLabel', 'showMaxLabel']); e = e || [], n = n || []; const o = e[0]; const a = e[1]; const s = e[e.length - 1]; const l = e[e.length - 2]; const u = n[0]; const h = n[1]; const c = n[n.length - 1]; const p = n[n.length - 2]; i === !1 ? (Ng(o), Ng(u)) : zg(o, a) && (i ? (Ng(a), Ng(h)) : (Ng(o), Ng(u))), r === !1 ? (Ng(s), Ng(c)) : zg(l, s) && (r ? (Ng(l), Ng(p)) : (Ng(s), Ng(c))) } } function Ng (t) { t && (t.ignore = !0) } function zg (t, e) { const n = t && t.getBoundingRect().clone(); const i = e && e.getBoundingRect().clone(); if (n && i) { const r = Ve([]); return Ge(r, r, -t.rotation), n.applyTransform(He([], r, t.getLocalTransform())), i.applyTransform(He([], r, e.getLocalTransform())), n.intersect(i) } } function Bg (t) { return t === 'middle' || t === 'center' } function Eg (t, e, n, i, r) { for (var o = [], a = [], s = [], l = 0; l < t.length; l++) { const u = t[l].coord; a[0] = u, a[1] = 0, s[0] = u, s[1] = n, e && (ve(a, a, e), ve(s, s, e)); const h = new dk({ shape: { x1: a[0], y1: a[1], x2: s[0], y2: s[1] }, style: i, z2: 2, autoBatch: !0, silent: !0 }); Hs(h.shape, h.style.lineWidth), h.anid = r + '_' + t[l].tickValue, o.push(h) } return o } function Vg (t, e, n, i) { const r = n.axis; const o = n.getModel('axisTick'); let a = o.get('show'); if (a === 'auto' && i.handleAutoShown && (a = i.handleAutoShown('axisTick')), a && !r.scale.isBlank()) { for (var s = o.getModel('lineStyle'), l = i.tickDirection * o.get('length'), u = r.getTicksCoords(), h = Eg(u, e.transform, l, c(s.getLineStyle(), { stroke: n.get(['axisLine', 'lineStyle', 'color']) }), 'ticks'), p = 0; p < h.length; p++)t.add(h[p]); return h } } function Fg (t, e, n, i) { const r = n.axis; const o = n.getModel('minorTick'); if (o.get('show') && !r.scale.isBlank()) { const a = r.getMinorTicksCoords(); if (a.length) for (let s = o.getModel('lineStyle'), l = i * o.get('length'), u = c(s.getLineStyle(), c(n.getModel('axisTick').getLineStyle(), { stroke: n.get(['axisLine', 'lineStyle', 'color']) })), h = 0; h < a.length; h++) for (let p = Eg(a[h], e.transform, l, u, 'minorticks_' + h), d = 0; d < p.length; d++)t.add(p[d]) } } function Hg (t, e, n, i) { const r = n.axis; const o = B(i.axisLabelShow, n.get(['axisLabel', 'show'])); if (o && !r.scale.isBlank()) { const a = n.getModel('axisLabel'); const s = a.get('margin'); const l = r.getViewLabels(); const u = (B(i.labelRotate, a.get('rotate')) || 0) * pz / 180; const h = dz.innerTextLayout(i.rotation, u, i.labelDirection); const c = n.getCategories && n.getCategories(!0); const p = []; const d = dz.isLabelSilent(n); const f = n.get('triggerEvent'); return y(l, function (o, l) { const u = r.scale.type === 'ordinal' ? r.scale.getRawOrdinalNumber(o.tickValue) : o.tickValue; const g = o.formattedLabel; const y = o.rawLabel; let v = a; if (c && c[u]) { const m = c[u]; k(m) && m.textStyle && (v = new Jk(m.textStyle, a, n.ecModel)) } const _ = v.getTextColor() || n.get(['axisLine', 'lineStyle', 'color']); const x = r.dataToCoord(u); const w = new aD({ x, y: i.labelOffset + i.labelDirection * s, rotation: h.rotation, silent: d, z2: 10 + (o.level || 0), style: ul(v, { text: g, align: v.getShallow('align', !0) || h.textAlign, verticalAlign: v.getShallow('verticalAlign', !0) || v.getShallow('baseline', !0) || h.textVerticalAlign, fill: T(_) ? _(r.type === 'category' ? y : r.type === 'value' ? u + '' : u, l) : _ }) }); if (w.anid = 'label_' + u, f) { const b = dz.makeAxisEventDataBase(n); b.targetType = 'axisLabel', b.value = y, b.tickIndex = l, r.type === 'category' && (b.dataIndex = u), hD(w).eventData = b }e.add(w), w.updateTransform(), p.push(w), t.add(w), w.decomposeTransform() }), p } } function Wg (t, e) { const n = { axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {} }; return Gg(n, t, e), n.seriesInvolved && Yg(n, t), n } function Gg (t, e, n) { const i = e.getComponent('tooltip'); const r = e.getComponent('axisPointer'); const o = r.get('link', !0) || []; const a = []; y(n.getCoordinateSystems(), function (n) { function s (i, s, l) { let h = l.model.getModel('axisPointer', r); const p = h.get('show'); if (p && (p !== 'auto' || i || $g(h))) { s == null && (s = h.get('triggerTooltip')), h = i ? Xg(l, c, r, e, i, s) : h; const d = h.get('snap'); const f = Qg(l.model); const g = s || d || l.type === 'category'; const y = t.axesInfo[f] = { key: f, axis: l, coordSys: n, axisPointerModel: h, triggerTooltip: s, involveSeries: g, snap: d, useHandle: $g(h), seriesModels: [], linkGroup: null }; u[f] = y, t.seriesInvolved = t.seriesInvolved || g; const v = Ug(o, l); if (v != null) { const m = a[v] || (a[v] = { axesInfo: {} }); m.axesInfo[f] = y, m.mapper = o[v].mapper, y.linkGroup = m } } } if (n.axisPointerEnabled) { const l = Qg(n.model); var u = t.coordSysAxesInfo[l] = {}; t.coordSysMap[l] = n; const h = n.model; var c = h.getModel('tooltip', i); if (y(n.getAxes(), S(s, !1, null)), n.getTooltipAxes && i && c.get('show')) { const p = c.get('trigger') === 'axis'; const d = c.get(['axisPointer', 'type']) === 'cross'; const f = n.getTooltipAxes(c.get(['axisPointer', 'axis'])); (p || d) && y(f.baseAxes, S(s, d ? 'cross' : !0, p)), d && y(f.otherAxes, S(s, 'cross', !1)) } } }) } function Xg (t, e, n, i, r, o) { const a = e.getModel('axisPointer'); const l = ['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z']; const u = {}; y(l, function (t) { u[t] = s(a.get(t)) }), u.snap = t.type !== 'category' && !!o, a.get('type') === 'cross' && (u.type = 'line'); const h = u.label || (u.label = {}); if (h.show == null && (h.show = !1), r === 'cross') { const p = a.get(['label', 'show']); if (h.show = p != null ? p : !0, !o) { const d = u.lineStyle = a.get('crossStyle'); d && c(h, d.textStyle) } } return t.model.getModel('axisPointer', new Jk(u, n, i)) } function Yg (t, e) { e.eachSeries(function (e) { const n = e.coordinateSystem; const i = e.get(['tooltip', 'trigger'], !0); const r = e.get(['tooltip', 'show'], !0); n && i !== 'none' && i !== !1 && i !== 'item' && r !== !1 && e.get(['axisPointer', 'show'], !0) !== !1 && y(t.coordSysAxesInfo[Qg(n.model)], function (t) { const i = t.axis; n.getAxis(i.dim) === i && (t.seriesModels.push(e), t.seriesDataCount == null && (t.seriesDataCount = 0), t.seriesDataCount += e.getData().count()) }) }) } function Ug (t, e) { for (let n = e.model, i = e.dim, r = 0; r < t.length; r++) { const o = t[r] || {}; if (Zg(o[i + 'AxisId'], n.id) || Zg(o[i + 'AxisIndex'], n.componentIndex) || Zg(o[i + 'AxisName'], n.name)) return r } } function Zg (t, e) { return t === 'all' || M(t) && p(t, e) >= 0 || t === e } function jg (t) { const e = qg(t); if (e) { const n = e.axisPointerModel; const i = e.axis.scale; const r = n.option; const o = n.get('status'); let a = n.get('value'); a != null && (a = i.parse(a)); const s = $g(n); o == null && (r.status = s ? 'show' : 'hide'); const l = i.getExtent().slice(); l[0] > l[1] && l.reverse(), (a == null || a > l[1]) && (a = l[1]), a < l[0] && (a = l[0]), r.value = a, s && (r.status = e.axis.scale.isBlank() ? 'hide' : 'show') } } function qg (t) { const e = (t.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo; return e && e.axesInfo[Qg(t)] } function Kg (t) { const e = qg(t); return e && e.axisPointerModel } function $g (t) { return !!t.get(['handle', 'show']) } function Qg (t) { return t.type + '||' + t.id } function Jg (t, e, n, i) { const r = n.axis; if (!r.scale.isBlank()) { const o = n.getModel('splitArea'); const a = o.getModel('areaStyle'); let s = a.get('color'); const l = i.coordinateSystem.getRect(); const u = r.getTicksCoords({ tickModel: o, clamp: !0 }); if (u.length) { const h = s.length; const p = vz(t).splitAreaColors; const d = Z(); let f = 0; if (p) for (var g = 0; g < u.length; g++) { const y = p.get(u[g].tickValue); if (y != null) { f = (y + (h - 1) * g) % h; break } } let v = r.toGlobalCoord(u[0].coord); const m = a.getAreaStyle(); s = M(s) ? s : [s]; for (var g = 1; g < u.length; g++) { const _ = r.toGlobalCoord(u[g].coord); let x = void 0; let w = void 0; let b = void 0; let S = void 0; r.isHorizontal() ? (x = v, w = l.y, b = _ - x, S = l.height, v = x + b) : (x = l.x, w = v, b = l.width, S = _ - w, v = w + S); const T = u[g - 1].tickValue; T != null && d.set(T, f), e.add(new nD({ anid: T != null ? 'area_' + T : null, shape: { x, y: w, width: b, height: S }, style: c({ fill: s[f] }, m), autoBatch: !0, silent: !0 })), f = (f + 1) % h }vz(t).splitAreaColors = d } } } function ty (t) { vz(t).splitAreaColors = null } function ey (t) { t.registerComponentView(Mz), t.registerComponentModel($N), t.registerCoordinateSystem('cartesian2d', cz), bg(t, 'x', QN, Tz), bg(t, 'y', QN, Tz), t.registerComponentView(bz), t.registerComponentView(Sz), t.registerPreprocessor(function (t) { t.xAxis && t.yAxis && !t.grid && (t.grid = {}) }) } function ny (t) { ff(ey), t.registerSeriesModel(GN), t.registerChartView(KN), t.registerLayout(wg('scatter')) } function iy (t) { const e = t; e.hierNode = { defaultAncestor: null, ancestor: e, prelim: 0, modifier: 0, change: 0, shift: 0, i: 0, thread: null }; for (var n, i, r = [e]; n = r.pop();) if (i = n.children, n.isExpand && i.length) for (let o = i.length, a = o - 1; a >= 0; a--) { const s = i[a]; s.hierNode = { defaultAncestor: null, ancestor: s, prelim: 0, modifier: 0, change: 0, shift: 0, i: a, thread: null }, r.push(s) } } function ry (t, e) { const n = t.isExpand ? t.children : []; const i = t.parentNode.children; const r = t.hierNode.i ? i[t.hierNode.i - 1] : null; if (n.length) { uy(t); const o = (n[0].hierNode.prelim + n[n.length - 1].hierNode.prelim) / 2; r ? (t.hierNode.prelim = r.hierNode.prelim + e(t, r), t.hierNode.modifier = t.hierNode.prelim - o) : t.hierNode.prelim = o } else r && (t.hierNode.prelim = r.hierNode.prelim + e(t, r)); t.parentNode.hierNode.defaultAncestor = hy(t, r, t.parentNode.hierNode.defaultAncestor || i[0], e) } function oy (t) { const e = t.hierNode.prelim + t.parentNode.hierNode.modifier; t.setLayout({ x: e }, !0), t.hierNode.modifier += t.parentNode.hierNode.modifier } function ay (t) { return arguments.length ? t : gy } function sy (t, e) { return t -= Math.PI / 2, { x: e * Math.cos(t), y: e * Math.sin(t) } } function ly (t, e) { return ru(t.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }) } function uy (t) { for (let e = t.children, n = e.length, i = 0, r = 0; --n >= 0;) { const o = e[n]; o.hierNode.prelim += i, o.hierNode.modifier += i, r += o.hierNode.change, i += o.hierNode.shift + r } } function hy (t, e, n, i) { if (e) { for (var r = t, o = t, a = o.parentNode.children[0], s = e, l = r.hierNode.modifier, u = o.hierNode.modifier, h = a.hierNode.modifier, c = s.hierNode.modifier; s = cy(s), o = py(o), s && o;) { r = cy(r), a = py(a), r.hierNode.ancestor = t; const p = s.hierNode.prelim + c - o.hierNode.prelim - u + i(s, o); p > 0 && (fy(dy(s, t, n), t, p), u += p, l += p), c += s.hierNode.modifier, u += o.hierNode.modifier, l += r.hierNode.modifier, h += a.hierNode.modifier }s && !cy(r) && (r.hierNode.thread = s, r.hierNode.modifier += c - l), o && !py(a) && (a.hierNode.thread = o, a.hierNode.modifier += u - h, n = t) } return n } function cy (t) { const e = t.children; return e.length && t.isExpand ? e[e.length - 1] : t.hierNode.thread } function py (t) { const e = t.children; return e.length && t.isExpand ? e[0] : t.hierNode.thread } function dy (t, e, n) { return t.hierNode.ancestor.parentNode === e.parentNode ? t.hierNode.ancestor : n } function fy (t, e, n) { const i = n / (e.hierNode.i - t.hierNode.i); e.hierNode.change -= i, e.hierNode.shift += n, e.hierNode.modifier += n, e.hierNode.prelim += n, t.hierNode.change += i } function gy (t, e) { return t.parentNode === e.parentNode ? 1 : 2 } function yy (t) { const e = t.seriesModel; return e ? e.coordinateSystem : null } function vy (t, e, n) { const i = t.target; i.x += e, i.y += n, i.dirty() } function my (t, e, n, i) { const r = t.target; const o = t.zoomLimit; let a = t.zoom = t.zoom || 1; if (a *= e, o) { const s = o.min || 0; const l = o.max || 1 / 0; a = Math.max(Math.min(l, a), s) } const u = a / t.zoom; t.zoom = a, r.x -= (n - r.x) * (u - 1), r.y -= (i - r.y) * (u - 1), r.scaleX *= u, r.scaleY *= u, r.dirty() } function _y (t, e, n) { const i = by(t); i[e] = n } function xy (t, e, n) { const i = by(t); const r = i[e]; r === n && (i[e] = null) } function wy (t, e) { return !!by(t)[e] } function by (t) { return t[Dz] || (t[Dz] = {}) } function Sy (t, e, n, i, r) { t.pointerChecker && t.pointerChecker(i, r.originX, r.originY) && (EM(i.event), My(t, e, n, i, r)) } function My (t, e, n, i, r) { r.isAvailableBehavior = gM(Ty, null, n, i), t.trigger(e, r) } function Ty (t, e, n) { const i = n[t]; return !t || i && (!I(i) || e.event[i + 'Key']) } function Iy (t, e, n) { const i = e.getComponentByElement(t.topTarget); const r = i && i.coordinateSystem; return i && i !== n && !Az.hasOwnProperty(i.mainType) && r && r.model !== n } function Cy (t, e) { const n = t.getItemLayout(e); return n && !isNaN(n.x) && !isNaN(n.y) } function Dy (t, e, n, i, r) { const o = !n; const a = t.tree.getNodeByDataIndex(e); const s = a.getModel(); const l = a.getVisual('style').fill; const u = a.isExpand === !1 && a.children.length !== 0 ? l : '#fff'; const h = t.tree.root; const c = a.parentNode === h ? a : a.parentNode || a; const p = t.getItemGraphicEl(c.dataIndex); const d = c.getLayout(); const f = p ? { x: p.__oldX, y: p.__oldY, rawX: p.__radialOldRawX, rawY: p.__radialOldRawY } : d; const g = a.getLayout(); o ? (n = new XN(t, e, null, { symbolInnerColor: u, useNameLabel: !0 }), n.x = f.x, n.y = f.y) : n.updateData(t, e, null, { symbolInnerColor: u, useNameLabel: !0 }), n.__radialOldRawX = n.__radialRawX, n.__radialOldRawY = n.__radialRawY, n.__radialRawX = g.rawX, n.__radialRawY = g.rawY, i.add(n), t.setItemGraphicEl(e, n), n.__oldX = n.x, n.__oldY = n.y, Is(n, { x: g.x, y: g.y }, r); const y = n.getSymbolPath(); if (r.get('layout') === 'radial') { const v = h.children[0]; const m = v.getLayout(); const _ = v.children.length; let x = void 0; let w = void 0; if (g.x === m.x && a.isExpand === !0 && v.children.length) { const b = { x: (v.children[0].getLayout().x + v.children[_ - 1].getLayout().x) / 2, y: (v.children[0].getLayout().y + v.children[_ - 1].getLayout().y) / 2 }; x = Math.atan2(b.y - m.y, b.x - m.x), x < 0 && (x = 2 * Math.PI + x), w = b.x < m.x, w && (x -= Math.PI) } else x = Math.atan2(g.y - m.y, g.x - m.x), x < 0 && (x = 2 * Math.PI + x), a.children.length === 0 || a.children.length !== 0 && a.isExpand === !1 ? (w = g.x < m.x, w && (x -= Math.PI)) : (w = g.x > m.x, w || (x -= Math.PI)); const S = w ? 'left' : 'right'; const M = s.getModel('label'); const T = M.get('rotate'); const I = T * (Math.PI / 180); const C = y.getTextContent(); C && (y.setTextConfig({ position: M.get('position') || S, rotation: T == null ? -x : I, origin: 'center' }), C.setStyle('verticalAlign', 'middle')) } const D = s.get(['emphasis', 'focus']); const k = D === 'relative' ? j(a.getAncestorsIndices(), a.getDescendantIndices()) : D === 'ancestor' ? a.getAncestorsIndices() : D === 'descendant' ? a.getDescendantIndices() : null; k && (hD(n).focus = k), ky(r, a, h, n, f, d, g, i), n.__edge && (n.onHoverStateChange = function (e) { if (e !== 'blur') { const i = a.parentNode && t.getItemGraphicEl(a.parentNode.dataIndex); i && i.hoverState === vD || Sa(n.__edge, e) } }) } function ky (t, e, n, i, r, o, a, s) { const l = e.getModel(); const u = t.get('edgeShape'); const h = t.get('layout'); const p = t.getOrient(); const d = t.get(['lineStyle', 'curveness']); const f = t.get('edgeForkPosition'); const g = l.getModel('lineStyle').getLineStyle(); let y = i.__edge; if (u === 'curve')e.parentNode && e.parentNode !== n && (y || (y = i.__edge = new yk({ shape: Oy(h, p, d, r, r) })), Is(y, { shape: Oy(h, p, d, o, a) }, t)); else if (u === 'polyline' && h === 'orthogonal' && e !== n && e.children && e.children.length !== 0 && e.isExpand === !0) { for (var v = e.children, m = [], _ = 0; _ < v.length; _++) { const x = v[_].getLayout(); m.push([x.x, x.y]) }y || (y = i.__edge = new Pz({ shape: { parentPoint: [a.x, a.y], childPoints: [[a.x, a.y]], orient: p, forkPosition: f } })), Is(y, { shape: { parentPoint: [a.x, a.y], childPoints: m } }, t) }y && (u !== 'polyline' || e.isExpand) && (y.useStyle(c({ strokeNoScale: !0, fill: null }, g)), Ja(y, l, 'lineStyle'), ka(y), s.add(y)) } function Ay (t, e, n, i, r) { const o = e.tree.root; const a = Ly(o, t); const s = a.source; const l = a.sourceLayout; const u = e.getItemGraphicEl(t.dataIndex); if (u) { const h = e.getItemGraphicEl(s.dataIndex); const c = h.__edge; const p = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? c : void 0); const d = i.get('edgeShape'); const f = i.get('layout'); const g = i.get('orient'); const y = i.get(['lineStyle', 'curveness']); p && (d === 'curve' ? ks(p, { shape: Oy(f, g, y, l, l), style: { opacity: 0 } }, i, { cb: function () { n.remove(p) }, removeOpt: r }) : d === 'polyline' && i.get('layout') === 'orthogonal' && ks(p, { shape: { parentPoint: [l.x, l.y], childPoints: [[l.x, l.y]] }, style: { opacity: 0 } }, i, { cb: function () { n.remove(p) }, removeOpt: r })) } } function Ly (t, e) { for (var n, i = e.parentNode === t ? e : e.parentNode || e; n = i.getLayout(), n == null;)i = i.parentNode === t ? i : i.parentNode || i; return { source: i, sourceLayout: n } } function Py (t, e, n, i, r) { const o = t.tree.getNodeByDataIndex(e); const a = t.tree.root; const s = Ly(a, o).sourceLayout; const l = { duration: r.get('animationDurationUpdate'), easing: r.get('animationEasingUpdate') }; ks(n, { x: s.x + 1, y: s.y + 1 }, r, { cb: function () { i.remove(n), t.setItemGraphicEl(e, null) }, removeOpt: l }), n.fadeOut(null, t.hostModel, { fadeLabel: !0, animation: l }), o.children.forEach(function (e) { Ay(e, t, i, r, l) }), Ay(o, t, i, r, l) } function Oy (t, e, n, i, r) { let o, a, s, l, u, h, c, p; if (t === 'radial') { u = i.rawX, c = i.rawY, h = r.rawX, p = r.rawY; const d = sy(u, c); const f = sy(u, c + (p - c) * n); const g = sy(h, p + (c - p) * n); const y = sy(h, p); return { x1: d.x || 0, y1: d.y || 0, x2: y.x || 0, y2: y.y || 0, cpx1: f.x || 0, cpy1: f.y || 0, cpx2: g.x || 0, cpy2: g.y || 0 } } return u = i.x, c = i.y, h = r.x, p = r.y, (e === 'LR' || e === 'RL') && (o = u + (h - u) * n, a = c, s = h + (u - h) * n, l = p), (e === 'TB' || e === 'BT') && (o = u, a = c + (p - c) * n, s = h, l = p + (c - p) * n), { x1: u, y1: c, x2: h, y2: p, cpx1: o, cpy1: a, cpx2: s, cpy2: l } } function Ry (t) { const e = t.mainData; let n = t.datas; n || (n = { main: e }, t.datasAttr = { main: 'data' }), t.datas = t.mainData = null, Hy(e, n, t), y(n, function (n) { y(e.TRANSFERABLE_METHODS, function (e) { n.wrapMethod(e, S(Ny, t)) }) }), e.wrapMethod('cloneShallow', S(By, t)), y(e.CHANGABLE_METHODS, function (n) { e.wrapMethod(n, S(zy, t)) }), W(n[e.dataType] === e) } function Ny (t, e) { if (Fy(this)) { const n = h({}, Rz(this).datas); n[this.dataType] = e, Hy(e, n, t) } else Wy(e, this.dataType, Rz(this).mainData, t); return e } function zy (t, e) { return t.struct && t.struct.update(), e } function By (t, e) { return y(Rz(e).datas, function (n, i) { n !== e && Wy(n.cloneShallow(), i, e, t) }), e } function Ey (t) { const e = Rz(this).mainData; return t == null || e == null ? e : Rz(e).datas[t] } function Vy () { const t = Rz(this).mainData; return t == null ? [{ data: t }] : v(w(Rz(t).datas), function (e) { return { type: e, data: Rz(t).datas[e] } }) } function Fy (t) { return Rz(t).mainData === t } function Hy (t, e, n) { Rz(t).datas = {}, y(e, function (e, i) { Wy(e, i, t, n) }) } function Wy (t, e, n, i) { Rz(n).datas[e] = t, Rz(t).mainData = n, t.dataType = e, i.struct && (t[i.structAttr] = i.struct, i.struct[i.datasAttr[e]] = t), t.getLinkedData = Ey, t.getLinkedDataAll = Vy } function Gy (t, e) { const n = e.children; t.parentNode !== e && (n.push(t), t.parentNode = e) } function Xy (t, e) { for (var n = []; t;) { const i = t.dataIndex; n.push({ name: t.name, dataIndex: i, value: e.getRawValue(i) }), t = t.parentNode } return n.reverse(), n } function Yy (t, e, n) { for (var i, r = [t], o = []; i = r.pop();) if (o.push(i), i.isExpand) { const a = i.children; if (a.length) for (let s = 0; s < a.length; s++)r.push(a[s]) } for (;i = o.pop();)e(i, n) } function Uy (t, e) { for (var n, i = [t]; n = i.pop();) if (e(n), n.isExpand) { const r = n.children; if (r.length) for (let o = r.length - 1; o >= 0; o--)i.push(r[o]) } } function Zy (t, e) { t.eachSeriesByType('tree', function (t) { jy(t, e) }) } function jy (t, e) { const n = ly(t, e); t.layoutInfo = n; const i = t.get('layout'); let r = 0; let o = 0; let a = null; i === 'radial' ? (r = 2 * Math.PI, o = Math.min(n.height, n.width) / 2, a = ay(function (t, e) { return (t.parentNode === e.parentNode ? 1 : 2) / t.depth })) : (r = n.width, o = n.height, a = ay()); const s = t.getData().tree.root; const l = s.children[0]; if (l) { iy(s), Yy(l, ry, a), s.hierNode.modifier = -l.hierNode.prelim, Uy(l, oy); let u = l; let h = l; let c = l; Uy(l, function (t) { const e = t.getLayout().x; e < u.getLayout().x && (u = t), e > h.getLayout().x && (h = t), t.depth > c.depth && (c = t) }); const p = u === h ? 1 : a(u, h) / 2; const d = p - u.getLayout().x; let f = 0; let g = 0; let y = 0; let v = 0; if (i === 'radial')f = r / (h.getLayout().x + p + d), g = o / (c.depth - 1 || 1), Uy(l, function (t) { y = (t.getLayout().x + d) * f, v = (t.depth - 1) * g; const e = sy(y, v); t.setLayout({ x: e.x, y: e.y, rawX: y, rawY: v }, !0) }); else { const m = t.getOrient(); m === 'RL' || m === 'LR' ? (g = o / (h.getLayout().x + p + d), f = r / (c.depth - 1 || 1), Uy(l, function (t) { v = (t.getLayout().x + d) * g, y = m === 'LR' ? (t.depth - 1) * f : r - (t.depth - 1) * f, t.setLayout({ x: y, y: v }, !0) })) : (m === 'TB' || m === 'BT') && (f = r / (h.getLayout().x + p + d), g = o / (c.depth - 1 || 1), Uy(l, function (t) { y = (t.getLayout().x + d) * f, v = m === 'TB' ? (t.depth - 1) * g : o - (t.depth - 1) * g, t.setLayout({ x: y, y: v }, !0) })) } } } function qy (t) { t.eachSeriesByType('tree', function (t) { const e = t.getData(); const n = e.tree; n.eachNode(function (t) { const n = t.getModel(); const i = n.getModel('itemStyle').getItemStyle(); const r = e.ensureUniqueItemVisual(t.dataIndex, 'style'); h(r, i) }) }) } function Ky (t, e) { return t.pointToProjected ? t.pointToProjected(e) : t.pointToData(e) } function $y (t, e, n, i) { const r = t.getZoom(); const o = t.getCenter(); let a = e.zoom; const s = t.projectedToPoint ? t.projectedToPoint(o) : t.dataToPoint(o); if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, t.setCenter(Ky(t, s), i)), a != null) { if (n) { const l = n.min || 0; const u = n.max || 1 / 0; a = Math.max(Math.min(r * a, u), l) / r }t.scaleX *= a, t.scaleY *= a; const h = (e.originX - t.x) * (a - 1); const c = (e.originY - t.y) * (a - 1); t.x -= h, t.y -= c, t.updateTransform(), t.setCenter(Ky(t, s), i), t.setZoom(a * r) } return { center: t.getCenter(), zoom: t.getZoom() } } function Qy (t) { t.registerAction({ type: 'treeExpandAndCollapse', event: 'treeExpandAndCollapse', update: 'update' }, function (t, e) { e.eachComponent({ mainType: 'series', subType: 'tree', query: t }, function (e) { const n = t.dataIndex; const i = e.getData().tree; const r = i.getNodeByDataIndex(n); r.isExpand = !r.isExpand }) }), t.registerAction({ type: 'treeRoam', event: 'treeRoam', update: 'none' }, function (t, e, n) { e.eachComponent({ mainType: 'series', subType: 'tree', query: t }, function (e) { const i = e.coordinateSystem; const r = $y(i, t, void 0, n); e.setCenter && e.setCenter(r.center), e.setZoom && e.setZoom(r.zoom) }) }) } function Jy (t) { t.registerChartView(Oz), t.registerSeriesModel(Bz), t.registerLayout(Zy), t.registerVisual(qy), Qy(t) } function tv (t) { const e = t.findComponents({ mainType: 'legend' }); e && e.length && t.eachSeriesByType('graph', function (t) { const n = t.getCategoriesData(); const i = t.getGraph(); const r = i.data; const o = n.mapArray(n.getName); r.filterSelf(function (t) { const n = r.getItemModel(t); let i = n.getShallow('category'); if (i != null) { D(i) && (i = o[i]); for (let a = 0; a < e.length; a++) if (!e[a].isSelected(i)) return !1 } return !0 }) }) } function ev (t) { const e = {}; t.eachSeriesByType('graph', function (t) { const n = t.getCategoriesData(); const i = t.getData(); const r = {}; n.each(function (i) { const o = n.getName(i); r['ec-' + o] = i; const a = n.getItemModel(i); const s = a.getModel('itemStyle').getItemStyle(); s.fill || (s.fill = t.getColorFromPalette(o, e)), n.setItemVisual(i, 'style', s); for (let l = ['symbol', 'symbolSize', 'symbolKeepAspect'], u = 0; u < l.length; u++) { const h = a.getShallow(l[u], !0); h != null && n.setItemVisual(i, l[u], h) } }), n.count() && i.each(function (t) { const e = i.getItemModel(t); let o = e.getShallow('category'); if (o != null) { I(o) && (o = r['ec-' + o]); const a = n.getItemVisual(o, 'style'); const s = i.ensureUniqueItemVisual(t, 'style'); h(s, a); for (let l = ['symbol', 'symbolSize', 'symbolKeepAspect'], u = 0; u < l.length; u++)i.setItemVisual(t, l[u], n.getItemVisual(o, l[u])) } }) }) } function nv (t) { return t instanceof Array || (t = [t, t]), t } function iv (t) { t.eachSeriesByType('graph', function (t) { const e = t.getGraph(); const n = t.getEdgeData(); const i = nv(t.get('edgeSymbol')); const r = nv(t.get('edgeSymbolSize')); n.setVisual('fromSymbol', i && i[0]), n.setVisual('toSymbol', i && i[1]), n.setVisual('fromSymbolSize', r && r[0]), n.setVisual('toSymbolSize', r && r[1]), n.setVisual('style', t.getModel('lineStyle').getLineStyle()), n.each(function (t) { const i = n.getItemModel(t); const r = e.getEdgeByIndex(t); const o = nv(i.getShallow('symbol', !0)); const a = nv(i.getShallow('symbolSize', !0)); const s = i.getModel('lineStyle').getLineStyle(); const l = n.ensureUniqueItemVisual(t, 'style'); switch (h(l, s), l.stroke) { case 'source':var u = r.node1.getVisual('style'); l.stroke = u && u.fill; break; case 'target':var u = r.node2.getVisual('style'); l.stroke = u && u.fill }o[0] && r.setVisual('fromSymbol', o[0]), o[1] && r.setVisual('toSymbol', o[1]), a[0] && r.setVisual('fromSymbolSize', a[0]), a[1] && r.setVisual('toSymbolSize', a[1]) }) }) } function rv (t) { Vz(t) && (t.__curvenessList = [], t.__edgeMap = {}, Fz(t)) } function ov (t, e, n, i) { if (Vz(n)) { const r = Hz(t, e, n); const o = n.__edgeMap; const a = o[Wz(r)]; o[r] && !a ? o[r].isForward = !0 : a && o[r] && (a.isForward = !0, o[r].isForward = !1), o[r] = o[r] || [], o[r].push(i) } } function av (t, e, n, i) { const r = Vz(e); const o = M(r); if (!r) return null; const a = Gz(t, e); if (!a) return null; for (var s = -1, l = 0; l < a.length; l++) if (a[l] === n) { s = l; break } const u = Xz(t, e); Fz(e, u), t.lineStyle = t.lineStyle || {}; const h = Hz(t.node1, t.node2, e); const c = e.__curvenessList; const p = o ? 0 : u % 2 ? 0 : 1; if (a.isForward) return c[p + s]; const d = Wz(h); const f = Yz(d, e); const g = c[s + f + p]; return i ? o ? r && r[0] === 0 ? (f + p) % 2 ? g : -g : ((f % 2 ? 0 : 1) + p) % 2 ? g : -g : (f + p) % 2 ? g : -g : c[s + f + p] } function sv (t) { const e = t.coordinateSystem; if (!e || e.type === 'view') { const n = t.getGraph(); n.eachNode(function (t) { const e = t.getModel(); t.setLayout([+e.get('x'), +e.get('y')]) }), lv(n, t) } } function lv (t, e) { t.eachEdge(function (t, n) { const i = V(t.getModel().get(['lineStyle', 'curveness']), -av(t, e, n, !0), 0); const r = ee(t.node1.getLayout()); const o = ee(t.node2.getLayout()); const a = [r, o]; +i && a.push([(r[0] + o[0]) / 2 - (r[1] - o[1]) * i, (r[1] + o[1]) / 2 - (o[0] - r[0]) * i]), t.setLayout(a) }) } function uv (t) { t.eachSeriesByType('graph', function (t) { const e = t.get('layout'); const n = t.coordinateSystem; if (n && n.type !== 'view') { const i = t.getData(); let r = []; y(n.dimensions, function (t) { r = r.concat(i.mapDimensionsAll(t)) }); for (let o = 0; o < i.count(); o++) { for (var a = [], s = !1, l = 0; l < r.length; l++) { const u = i.get(r[l], o); isNaN(u) || (s = !0), a.push(u) }s ? i.setItemLayout(o, n.dataToPoint(a)) : i.setItemLayout(o, [0 / 0, 0 / 0]) }lv(i.graph, t) } else e && e !== 'none' || sv(t) }) } function hv (t) { const e = t.coordinateSystem; if (e.type !== 'view') return 1; const n = t.option.nodeScaleRatio; const i = e.scaleX; const r = e.getZoom(); const o = (r - 1) * n + 1; return o / i } function cv (t) { let e = t.getVisual('symbolSize'); return e instanceof Array && (e = (e[0] + e[1]) / 2), +e } function pv (t, e, n, i) { const r = t.coordinateSystem; if (!r || r.type === 'view') { const o = r.getBoundingRect(); const a = t.getData(); const s = a.graph; const l = o.width / 2 + o.x; const u = o.height / 2 + o.y; const h = Math.min(o.width, o.height) / 2; const c = a.count(); if (a.setLayout({ cx: l, cy: u }), c) { if (n) { const p = r.pointToData(i); const d = p[0]; const f = p[1]; const g = [d - l, f - u]; pe(g, g), ce(g, g, h), n.setLayout([l + g[0], u + g[1]], !0); const y = t.get(['circular', 'rotateLabel']); dv(n, y, l, u) }jz[e](t, s, a, h, l, u, c), s.eachEdge(function (e, n) { let i; let r = V(e.getModel().get(['lineStyle', 'curveness']), av(e, t, n), 0); const o = ee(e.node1.getLayout()); const a = ee(e.node2.getLayout()); const s = (o[0] + a[0]) / 2; const h = (o[1] + a[1]) / 2; +r && (r *= 3, i = [l * r + s * (1 - r), u * r + h * (1 - r)]), e.setLayout([o, a, i]) }) } } } function dv (t, e, n, i) { const r = t.getGraphicEl(); if (r) { const o = t.getModel(); let a = o.get(['label', 'rotate']) || 0; const s = r.getSymbolPath(); if (e) { const l = t.getLayout(); let u = Math.atan2(l[1] - i, l[0] - n); u < 0 && (u = 2 * Math.PI + u); const c = l[0] < n; c && (u -= Math.PI); const p = c ? 'left' : 'right'; s.setTextConfig({ rotation: -u, position: p, origin: 'center' }); const d = s.ensureState('emphasis'); h(d.textConfig || (d.textConfig = {}), { position: p }) } else s.setTextConfig({ rotation: a *= Math.PI / 180 }) } } function fv (t) { t.eachSeriesByType('graph', function (t) { t.get('layout') === 'circular' && pv(t, 'symbolSize') }) } function gv (t, e, n) { for (var i = t, r = e, o = n.rect, a = o.width, s = o.height, l = [o.x + a / 2, o.y + s / 2], u = n.gravity == null ? 0.1 : n.gravity, h = 0; h < i.length; h++) { const c = i[h]; c.p || (c.p = J(a * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), c.pp = ee(c.p), c.edges = null } let p; let d; const f = n.friction == null ? 0.6 : n.friction; let g = f; return { warmUp: function () { g = 0.8 * f }, setFixed: function (t) { i[t].fixed = !0 }, setUnfixed: function (t) { i[t].fixed = !1 }, beforeStep: function (t) { p = t }, afterStep: function (t) { d = t }, step: function (t) { p && p(i, r); for (var e = [], n = i.length, o = 0; o < r.length; o++) { const a = r[o]; if (!a.ignoreForceLayout) { var s = a.n1; var h = a.n2; oe(e, h.p, s.p); var c = ae(e) - a.d; let f = h.w / (s.w + h.w); isNaN(f) && (f = 0), pe(e, e), !s.fixed && qz(s.p, s.p, e, f * c * g), !h.fixed && qz(h.p, h.p, e, -(1 - f) * c * g) } } for (var o = 0; n > o; o++) { var y = i[o]; y.fixed || (oe(e, l, y.p), qz(y.p, y.p, e, u * g)) } for (var o = 0; n > o; o++) for (var s = i[o], v = o + 1; n > v; v++) { var h = i[v]; oe(e, h.p, s.p); var c = ae(e); c === 0 && (ne(e, Math.random() - 0.5, Math.random() - 0.5), c = 1); const m = (s.rep + h.rep) / c / c; !s.fixed && qz(s.pp, s.pp, e, m), !h.fixed && qz(h.pp, h.pp, e, -m) } for (var _ = [], o = 0; n > o; o++) { var y = i[o]; y.fixed || (oe(_, y.p, y.pp), qz(y.p, y.p, _, g), te(y.pp, y.p)) }g = 0.992 * g; const x = g < 0.01; d && d(i, r, x), t && t(x) } } } function yv (t) { t.eachSeriesByType('graph', function (t) { const e = t.coordinateSystem; if (!e || e.type === 'view') if (t.get('layout') === 'force') { const n = t.preservedPoints || {}; const i = t.getGraph(); const r = i.data; const o = i.edgeData; const a = t.getModel('force'); const s = a.get('initLayout'); t.preservedPoints ? r.each(function (t) { const e = r.getId(t); r.setItemLayout(t, n[e] || [0 / 0, 0 / 0]) }) : s && s !== 'none' ? s === 'circular' && pv(t, 'value') : sv(t); const l = r.getDataExtent('value'); const u = o.getDataExtent('value'); const h = a.get('repulsion'); const c = a.get('edgeLength'); const p = M(h) ? h : [h, h]; let d = M(c) ? c : [c, c]; d = [d[1], d[0]]; const f = r.mapArray('value', function (t, e) { const n = r.getItemLayout(e); let i = rr(t, l, p); return isNaN(i) && (i = (p[0] + p[1]) / 2), { w: i, rep: i, fixed: r.getItemModel(e).get('fixed'), p: !n || isNaN(n[0]) || isNaN(n[1]) ? null : n } }); const g = o.mapArray('value', function (e, n) { const r = i.getEdgeByIndex(n); let o = rr(e, u, d); isNaN(o) && (o = (d[0] + d[1]) / 2); const a = r.getModel(); const s = V(r.getModel().get(['lineStyle', 'curveness']), -av(r, t, n, !0), 0); return { n1: f[r.node1.dataIndex], n2: f[r.node2.dataIndex], d: o, curveness: s, ignoreForceLayout: a.get('ignoreForceLayout') } }); const y = e.getBoundingRect(); const v = gv(f, g, { rect: y, gravity: a.get('gravity'), friction: a.get('friction') }); v.beforeStep(function (t) { for (let e = 0, n = t.length; n > e; e++)t[e].fixed && te(t[e].p, i.getNodeByIndex(e).getLayout()) }), v.afterStep(function (t, e) { for (var o = 0, a = t.length; a > o; o++)t[o].fixed || i.getNodeByIndex(o).setLayout(t[o].p), n[r.getId(o)] = t[o].p; for (var o = 0, a = e.length; a > o; o++) { const s = e[o]; const l = i.getEdgeByIndex(o); const u = s.n1.p; const h = s.n2.p; let c = l.getLayout(); c = c ? c.slice() : [], c[0] = c[0] || [], c[1] = c[1] || [], te(c[0], u), te(c[1], h), +s.curveness && (c[2] = [(u[0] + h[0]) / 2 - (u[1] - h[1]) * s.curveness, (u[1] + h[1]) / 2 - (h[0] - u[0]) * s.curveness]), l.setLayout(c) } }), t.forceLayout = v, t.preservedPoints = n, v.step() } else t.forceLayout = null }) } function vv (t, e, n) { const i = h(t.getBoxLayoutParams(), { aspect: n }); return ru(i, { width: e.getWidth(), height: e.getHeight() }) } function mv (t, e) { const n = []; return t.eachSeriesByType('graph', function (t) { const i = t.get('coordinateSystem'); if (!i || i === 'view') { const r = t.getData(); const o = r.mapArray(function (t) { const e = r.getItemModel(t); return [+e.get('x'), +e.get('y')] }); let a = []; let s = []; Ao(o, a, s), s[0] - a[0] === 0 && (s[0] += 1, a[0] -= 1), s[1] - a[1] === 0 && (s[1] += 1, a[1] -= 1); const l = (s[0] - a[0]) / (s[1] - a[1]); const u = vv(t, e, l); isNaN(l) && (a = [u.x, u.y], s = [u.x + u.width, u.y + u.height]); const h = s[0] - a[0]; const c = s[1] - a[1]; const p = u.width; const d = u.height; const f = t.coordinateSystem = new Cz(); f.zoomLimit = t.get('scaleLimit'), f.setBoundingRect(a[0], a[1], h, c), f.setViewRect(u.x, u.y, p, d), f.setCenter(t.get('center'), e), f.setZoom(t.get('zoom')), n.push(f) } }), n } function _v (t) { return isNaN(+t.cpx1) || isNaN(+t.cpy1) } function xv (t) { return '_' + t + 'Type' } function wv (t, e, n) { const i = e.getItemVisual(n, t); if (i && i !== 'none') { const r = e.getItemVisual(n, t + 'Size'); const o = e.getItemVisual(n, t + 'Rotate'); const a = e.getItemVisual(n, t + 'Offset'); const s = e.getItemVisual(n, t + 'KeepAspect'); const l = Rc(r); const u = Nc(a || 0, l); const h = Oc(i, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s); return h.__specifiedRotation = o == null || isNaN(o) ? void 0 : +o * Math.PI / 180 || 0, h.name = t, h } } function bv (t) { const e = new Jz({ name: 'line', subPixelOptimize: !0 }); return Sv(e.shape, t), e } function Sv (t, e) {
    t.x1 = e[0][0], t.y1 = e[0][1], t.x2 = e[1][0], t.y2 = e[1][1], t.percent = 1
    const n = e[2]; n ? (t.cpx1 = n[0], t.cpy1 = n[1]) : (t.cpx1 = 0 / 0, t.cpy1 = 0 / 0)
  } function Mv (t) { return t.animators && t.animators.length > 0 } function Tv (t) { const e = t.hostModel; const n = e.getModel('emphasis'); return { lineStyle: e.getModel('lineStyle').getLineStyle(), emphasisLineStyle: n.getModel(['lineStyle']).getLineStyle(), blurLineStyle: e.getModel(['blur', 'lineStyle']).getLineStyle(), selectLineStyle: e.getModel(['select', 'lineStyle']).getLineStyle(), emphasisDisabled: n.get('disabled'), blurScope: n.get('blurScope'), focus: n.get('focus'), labelStatesModels: ll(e) } } function Iv (t) { return isNaN(t[0]) || isNaN(t[1]) } function Cv (t) { return t && !Iv(t[0]) && !Iv(t[1]) } function Dv (t, e, n) { for (var i, r = t[0], o = t[1], a = t[2], s = 1 / 0, l = n * n, u = 0.1, h = 0.1; h <= 0.9; h += 0.1) { iB[0] = aB(r[0], o[0], a[0], h), iB[1] = aB(r[1], o[1], a[1], h); var c = lB(sB(iB, e) - l); s > c && (s = c, i = h) } for (let p = 0; p < 32; p++) { const d = i + u; rB[0] = aB(r[0], o[0], a[0], i), rB[1] = aB(r[1], o[1], a[1], i), oB[0] = aB(r[0], o[0], a[0], d), oB[1] = aB(r[1], o[1], a[1], d); var c = sB(rB, e) - l; if (lB(c) < 0.01) break; const f = sB(oB, e) - l; u /= 2, c < 0 ? f >= 0 ? i += u : i -= u : f >= 0 ? i -= u : i += u } return i } function kv (t, e) { const n = []; const i = bn; const r = [[], [], []]; const o = [[], []]; const a = []; e /= 2, t.eachEdge(function (t) { const s = t.getLayout(); const l = t.getVisual('fromSymbol'); const u = t.getVisual('toSymbol'); s.__original || (s.__original = [ee(s[0]), ee(s[1])], s[2] && s.__original.push(ee(s[2]))); const h = s.__original; if (s[2] != null) { if (te(r[0], h[0]), te(r[1], h[2]), te(r[2], h[1]), l && l !== 'none') { var c = cv(t.node1); var p = Dv(r, h[0], c * e); i(r[0][0], r[1][0], r[2][0], p, n), r[0][0] = n[3], r[1][0] = n[4], i(r[0][1], r[1][1], r[2][1], p, n), r[0][1] = n[3], r[1][1] = n[4] } if (u && u !== 'none') { var c = cv(t.node2); var p = Dv(r, h[1], c * e); i(r[0][0], r[1][0], r[2][0], p, n), r[1][0] = n[1], r[2][0] = n[2], i(r[0][1], r[1][1], r[2][1], p, n), r[1][1] = n[1], r[2][1] = n[2] }te(s[0], r[0]), te(s[1], r[2]), te(s[2], r[1]) } else { if (te(o[0], h[0]), te(o[1], h[1]), oe(a, o[1], o[0]), pe(a, a), l && l !== 'none') { var c = cv(t.node1); re(o[0], o[0], a, c * e) } if (u && u !== 'none') { var c = cv(t.node2); re(o[1], o[1], a, -c * e) }te(s[0], o[0]), te(s[1], o[1]) } }) } function Av (t) { return t.type === 'view' } function Lv (t) { return '_EC_' + t } function Pv (t, e) { return { getValue: function (n) { const i = this[t][e]; return i.getStore().get(i.getDimensionIndex(n || 'value'), this.dataIndex) }, setVisual: function (n, i) { this.dataIndex >= 0 && this[t][e].setItemVisual(this.dataIndex, n, i) }, getVisual: function (n) { return this[t][e].getItemVisual(this.dataIndex, n) }, setLayout: function (n, i) { this.dataIndex >= 0 && this[t][e].setItemLayout(this.dataIndex, n, i) }, getLayout: function () { return this[t][e].getItemLayout(this.dataIndex) }, getGraphicEl: function () { return this[t][e].getItemGraphicEl(this.dataIndex) }, getRawIndex: function () { return this[t][e].getRawIndex(this.dataIndex) } } } function Ov (t, e, n, i, r) { for (var o = new hB(i), a = 0; a < t.length; a++)o.addNode(B(t[a].id, t[a].name, a), a); for (var s = [], l = [], u = 0, a = 0; a < e.length; a++) { const h = e[a]; const c = h.source; const d = h.target; o.addEdge(c, d, u) && (l.push(h), s.push(B(Wr(h.id, null), c + ' > ' + d)), u++) } let f; const g = n.get('coordinateSystem'); if (g === 'cartesian2d' || g === 'polar')f = gd(t, n); else { const y = oL.get(g); const v = y ? y.dimensions || [] : []; p(v, 'value') < 0 && v.concat(['value']); const m = id(t, { coordDimensions: v, encodeDefine: n.getEncode() }).dimensions; f = new TR(m, n), f.initData(t) } const _ = new TR(['value'], n); return _.initData(l, s), r && r(f, _), Ry({ mainData: f, struct: o, structAttr: 'graph', datas: { node: f, edge: _ }, datasAttr: { node: 'data', edge: 'edgeData' } }), o.update(), o } function Rv (t) { t.registerChartView(uB), t.registerSeriesModel(fB), t.registerProcessor(tv), t.registerVisual(ev), t.registerVisual(iv), t.registerLayout(uv), t.registerLayout(t.PRIORITY.VISUAL.POST_CHART_LAYOUT, fv), t.registerLayout(yv), t.registerCoordinateSystem('graphView', { dimensions: Cz.dimensions, create: mv }), t.registerAction({ type: 'focusNodeAdjacency', event: 'focusNodeAdjacency', update: 'series:focusNodeAdjacency' }, Q), t.registerAction({ type: 'unfocusNodeAdjacency', event: 'unfocusNodeAdjacency', update: 'series:unfocusNodeAdjacency' }, Q), t.registerAction(gB, function (t, e, n) { e.eachComponent({ mainType: 'series', query: t }, function (e) { const i = e.coordinateSystem; const r = $y(i, t, void 0, n); e.setCenter && e.setCenter(r.center), e.setZoom && e.setZoom(r.zoom) }) }) } function Nv (t, e, n, i, r) { const o = t.getArea(); let a = o.x; let s = o.y; let l = o.width; let u = o.height; const h = n.get(['lineStyle', 'width']) || 2; a -= h / 2, s -= h / 2, l += h, u += h, a = Math.floor(a), l = Math.round(l); const c = new nD({ shape: { x: a, y: s, width: l, height: u } }); if (e) { const p = t.getBaseAxis(); const d = p.isHorizontal(); const f = p.inverse; d ? (f && (c.shape.x += l), c.shape.width = 0) : (f || (c.shape.y += u), c.shape.height = 0); const g = T(r) ? function (t) { r(t, c) } : null; Cs(c, { shape: { width: l, height: u, x: a, y: s } }, n, null, i, g) } return c } function zv (t, e, n) { const i = t.getArea(); const r = ar(i.r0, 1); const o = ar(i.r, 1); const a = new rk({ shape: { cx: ar(t.cx, 1), cy: ar(t.cy, 1), r0: r, r: o, startAngle: i.startAngle, endAngle: i.endAngle, clockwise: i.clockwise } }); if (e) { const s = t.getBaseAxis().dim === 'angle'; s ? a.shape.endAngle = i.startAngle : a.shape.r = r, Cs(a, { shape: { endAngle: i.endAngle, r: o } }, n) } return a } function Bv (t, e, n, i, r) { return t ? t.type === 'polar' ? zv(t, e, n) : t.type === 'cartesian2d' ? Nv(t, e, n, i, r) : null : null } function Ev (t, e) { return e = e || [0, 0], v(['x', 'y'], function (n, i) { const r = this.getAxis(n); const o = e[i]; const a = t[i] / 2; return r.type === 'category' ? r.getBandWidth() : Math.abs(r.dataToCoord(o - a) - r.dataToCoord(o + a)) }, this) } function Vv (t) { const e = t.master.getRect(); return { coordSys: { type: 'cartesian2d', x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: function (e) { return t.dataToPoint(e) }, size: gM(Ev, t) } } } function Fv (t, e) { return e = e || [0, 0], v([0, 1], function (n) { const i = e[n]; const r = t[n] / 2; const o = []; const a = []; return o[n] = i - r, a[n] = i + r, o[1 - n] = a[1 - n] = e[1 - n], Math.abs(this.dataToPoint(o)[n] - this.dataToPoint(a)[n]) }, this) } function Hv (t) { const e = t.getBoundingRect(); return { coordSys: { type: 'geo', x: e.x, y: e.y, width: e.width, height: e.height, zoom: t.getZoom() }, api: { coord: function (e) { return t.dataToPoint(e) }, size: gM(Fv, t) } } } function Wv (t, e) { const n = this.getAxis(); const i = e instanceof Array ? e[0] : e; const r = (t instanceof Array ? t[0] : t) / 2; return n.type === 'category' ? n.getBandWidth() : Math.abs(n.dataToCoord(i - r) - n.dataToCoord(i + r)) } function Gv (t) { const e = t.getRect(); return { coordSys: { type: 'singleAxis', x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: function (e) { return t.dataToPoint(e) }, size: gM(Wv, t) } } } function Xv (t, e) { return e = e || [0, 0], v(['Radius', 'Angle'], function (n, i) { const r = 'get' + n + 'Axis'; const o = this[r](); const a = e[i]; const s = t[i] / 2; let l = o.type === 'category' ? o.getBandWidth() : Math.abs(o.dataToCoord(a - s) - o.dataToCoord(a + s)); return n === 'Angle' && (l = l * Math.PI / 180), l }, this) } function Yv (t) { const e = t.getRadiusAxis(); const n = t.getAngleAxis(); const i = e.getExtent(); return i[0] > i[1] && i.reverse(), { coordSys: { type: 'polar', cx: t.cx, cy: t.cy, r: i[1], r0: i[0] }, api: { coord: function (i) { const r = e.dataToRadius(i[0]); const o = n.dataToAngle(i[1]); const a = t.coordToPoint([r, o]); return a.push(r, o * Math.PI / 180), a }, size: gM(Xv, t) } } } function Uv (t) { const e = t.getRect(); const n = t.getRangeInfo(); return { coordSys: { type: 'calendar', x: e.x, y: e.y, width: e.width, height: e.height, cellWidth: t.getCellWidth(), cellHeight: t.getCellHeight(), rangeInfo: { start: n.start, end: n.end, weeks: n.weeks, dayCount: n.allDay } }, api: { coord: function (e, n) { return t.dataToPoint(e, n) } } } } function Zv (t, e, n, i) { return t && (t.legacy || t.legacy !== !1 && !n && !i && e !== 'tspan' && (e === 'text' || $(t, 'text'))) } function jv (t, e, n) { let i; let r; let o; const a = t; if (e === 'text')o = a; else { o = {}, $(a, 'text') && (o.text = a.text), $(a, 'rich') && (o.rich = a.rich), $(a, 'textFill') && (o.fill = a.textFill), $(a, 'textStroke') && (o.stroke = a.textStroke), $(a, 'fontFamily') && (o.fontFamily = a.fontFamily), $(a, 'fontSize') && (o.fontSize = a.fontSize), $(a, 'fontStyle') && (o.fontStyle = a.fontStyle), $(a, 'fontWeight') && (o.fontWeight = a.fontWeight), r = { type: 'text', style: o, silent: !0 }, i = {}; const s = $(a, 'textPosition'); n ? i.position = s ? a.textPosition : 'inside' : s && (i.position = a.textPosition), $(a, 'textPosition') && (i.position = a.textPosition), $(a, 'textOffset') && (i.offset = a.textOffset), $(a, 'textRotation') && (i.rotation = a.textRotation), $(a, 'textDistance') && (i.distance = a.textDistance) } return qv(o, t), y(o.rich, function (t) { qv(t, t) }), { textConfig: i, textContent: r } } function qv (t, e) { e && (e.font = e.textFont || e.font, $(e, 'textStrokeWidth') && (t.lineWidth = e.textStrokeWidth), $(e, 'textAlign') && (t.align = e.textAlign), $(e, 'textVerticalAlign') && (t.verticalAlign = e.textVerticalAlign), $(e, 'textLineHeight') && (t.lineHeight = e.textLineHeight), $(e, 'textWidth') && (t.width = e.textWidth), $(e, 'textHeight') && (t.height = e.textHeight), $(e, 'textBackgroundColor') && (t.backgroundColor = e.textBackgroundColor), $(e, 'textPadding') && (t.padding = e.textPadding), $(e, 'textBorderColor') && (t.borderColor = e.textBorderColor), $(e, 'textBorderWidth') && (t.borderWidth = e.textBorderWidth), $(e, 'textBorderRadius') && (t.borderRadius = e.textBorderRadius), $(e, 'textBoxShadowColor') && (t.shadowColor = e.textBoxShadowColor), $(e, 'textBoxShadowBlur') && (t.shadowBlur = e.textBoxShadowBlur), $(e, 'textBoxShadowOffsetX') && (t.shadowOffsetX = e.textBoxShadowOffsetX), $(e, 'textBoxShadowOffsetY') && (t.shadowOffsetY = e.textBoxShadowOffsetY)) } function Kv (t, e, n) { const i = t; i.textPosition = i.textPosition || n.position || 'inside', n.offset != null && (i.textOffset = n.offset), n.rotation != null && (i.textRotation = n.rotation), n.distance != null && (i.textDistance = n.distance); const r = i.textPosition.indexOf('inside') >= 0; const o = t.fill || '#000'; $v(i, e); const a = i.textFill == null; return r ? a && (i.textFill = n.insideFill || '#fff', !i.textStroke && n.insideStroke && (i.textStroke = n.insideStroke), !i.textStroke && (i.textStroke = o), i.textStrokeWidth == null && (i.textStrokeWidth = 2)) : (a && (i.textFill = t.fill || n.outsideFill || '#000'), !i.textStroke && n.outsideStroke && (i.textStroke = n.outsideStroke)), i.text = e.text, i.rich = e.rich, y(e.rich, function (t) { $v(t, t) }), i } function $v (t, e) { e && ($(e, 'fill') && (t.textFill = e.fill), $(e, 'stroke') && (t.textStroke = e.fill), $(e, 'lineWidth') && (t.textStrokeWidth = e.lineWidth), $(e, 'font') && (t.font = e.font), $(e, 'fontStyle') && (t.fontStyle = e.fontStyle), $(e, 'fontWeight') && (t.fontWeight = e.fontWeight), $(e, 'fontSize') && (t.fontSize = e.fontSize), $(e, 'fontFamily') && (t.fontFamily = e.fontFamily), $(e, 'align') && (t.textAlign = e.align), $(e, 'verticalAlign') && (t.textVerticalAlign = e.verticalAlign), $(e, 'lineHeight') && (t.textLineHeight = e.lineHeight), $(e, 'width') && (t.textWidth = e.width), $(e, 'height') && (t.textHeight = e.height), $(e, 'backgroundColor') && (t.textBackgroundColor = e.backgroundColor), $(e, 'padding') && (t.textPadding = e.padding), $(e, 'borderColor') && (t.textBorderColor = e.borderColor), $(e, 'borderWidth') && (t.textBorderWidth = e.borderWidth), $(e, 'borderRadius') && (t.textBorderRadius = e.borderRadius), $(e, 'shadowColor') && (t.textBoxShadowColor = e.shadowColor), $(e, 'shadowBlur') && (t.textBoxShadowBlur = e.shadowBlur), $(e, 'shadowOffsetX') && (t.textBoxShadowOffsetX = e.shadowOffsetX), $(e, 'shadowOffsetY') && (t.textBoxShadowOffsetY = e.shadowOffsetY), $(e, 'textShadowColor') && (t.textShadowColor = e.textShadowColor), $(e, 'textShadowBlur') && (t.textShadowBlur = e.textShadowBlur), $(e, 'textShadowOffsetX') && (t.textShadowOffsetX = e.textShadowOffsetX), $(e, 'textShadowOffsetY') && (t.textShadowOffsetY = e.textShadowOffsetY)) } function Qv (t, e, n, i, r) { const o = t + 'Animation'; const a = Ms(t, i, r) || {}; const s = SB(e).userDuring; return a.duration > 0 && (a.during = s ? gM(am, { el: e, userDuring: s }) : null, a.setToFinal = !0, a.scope = t), h(a, n[o]), a } function Jv (t, e, n, i) { i = i || {}; const r = i.dataIndex; const o = i.isInit; const a = i.clearStyle; const s = n.isAnimationEnabled(); const l = SB(t); const u = e.style; l.userDuring = e.during; const c = {}; const p = {}; if (hm(t, e, p), lm('shape', e, p), lm('extra', e, p), !o && s && (um(t, e, c), sm('shape', t, e, c), sm('extra', t, e, c), cm(t, e, u, c)), p.style = u, im(t, p, a), om(t, e), s) if (o) { const d = {}; y(bB, function (t) { const n = t ? e[t] : e; n && n.enterFrom && (t && (d[t] = d[t] || {}), h(t ? d[t] : d, n.enterFrom)) }); const f = Qv('enter', t, e, n, r); f.duration > 0 && t.animateFrom(d, f) } else rm(t, e, r || 0, n, c); tm(t, e), u ? t.dirty() : t.markRedraw() } function tm (t, e) { for (let n = SB(t).leaveToProps, i = 0; i < bB.length; i++) { const r = bB[i]; const o = r ? e[r] : e; o && o.leaveTo && (n || (n = SB(t).leaveToProps = {}), r && (n[r] = n[r] || {}), h(r ? n[r] : n, o.leaveTo)) } } function em (t, e, n, i) { if (t) { const r = t.parent; const o = SB(t).leaveToProps; if (o) { const a = Qv('update', t, e, n, 0); a.done = function () { r.remove(t), i && i() }, t.animateTo(o, a) } else r.remove(t), i && i() } } function nm (t) { return t === 'all' } function im (t, e, n) { const i = e.style; if (!t.isGroup && i) { if (n) { t.useStyle({}); for (let r = t.animators, o = 0; o < r.length; o++) { const a = r[o]; a.targetName === 'style' && a.changeTarget(t.style) } }t.setStyle(i) }e && (e.style = null, e && t.attr(e), e.style = i) } function rm (t, e, n, i, r) { if (r) { const o = Qv('update', t, e, i, n); o.duration > 0 && t.animateFrom(r, o) } } function om (t, e) { $(e, 'silent') && (t.silent = e.silent), $(e, 'ignore') && (t.ignore = e.ignore), t instanceof sC && $(e, 'invisible') && (t.invisible = e.invisible), t instanceof ZC && $(e, 'autoBatch') && (t.autoBatch = e.autoBatch) } function am () { const t = this; const e = t.el; if (e) { const n = SB(e).userDuring; const i = t.userDuring; if (n !== i) return void (t.el = t.userDuring = null); MB.el = e, i(TB) } } function sm (t, e, n, i) { const r = n[t]; if (r) { let o; const a = e[t]; if (a) { const s = n.transition; const l = r.transition; if (l) if (!o && (o = i[t] = {}), nm(l))h(o, a); else for (var u = kr(l), c = 0; c < u.length; c++) { var d = u[c]; var f = a[d]; o[d] = f } else if (nm(s) || p(s, t) >= 0) { !o && (o = i[t] = {}); for (var g = w(a), c = 0; c < g.length; c++) { var d = g[c]; var f = a[d]; pm(r[d], f) && (o[d] = f) } } } } } function lm (t, e, n) { const i = e[t]; if (i) for (let r = n[t] = {}, o = w(i), a = 0; a < o.length; a++) { const s = o[a]; r[s] = mi(i[s]) } } function um (t, e, n) { for (let i = e.transition, r = nm(i) ? _I : kr(i || []), o = 0; o < r.length; o++) { const a = r[o]; if (a !== 'style' && a !== 'shape' && a !== 'extra') { const s = t[a]; n[a] = s } } } function hm (t, e, n) { for (var i = 0; i < wB.length; i++) { const r = wB[i]; const o = xB[r]; const a = e[r]; a && (n[o[0]] = a[0], n[o[1]] = a[1]) } for (var i = 0; i < _I.length; i++) { const s = _I[i]; e[s] != null && (n[s] = e[s]) } } function cm (t, e, n, i) { if (n) { let r; const o = t.style; if (o) { const a = n.transition; const s = e.transition; if (a && !nm(a)) { const l = kr(a); !r && (r = i.style = {}); for (var u = 0; u < l.length; u++) { var h = l[u]; var c = o[h]; r[h] = c } } else if (t.getAnimationStyleProps && (nm(s) || nm(a) || p(s, 'style') >= 0)) { const d = t.getAnimationStyleProps(); const f = d ? d.style : null; if (f) { !r && (r = i.style = {}); for (var g = w(n), u = 0; u < g.length; u++) { var h = g[u]; if (f[h]) { var c = o[h]; r[h] = c } } } } } } } function pm (t, e) { return g(t) ? t !== e : t != null && isFinite(t) } function dm (t) { t.stopAnimation('keyframe'), t.attr(IB(t)) } function fm (t, e, n) { if (n.isAnimationEnabled() && e) { if (M(e)) return void y(e, function (e) { fm(t, e, n) }); const i = e.keyframes; let r = e.duration; if (n && r == null) { const o = Ms('enter', n, 0); r = o && o.duration } if (i && r) { const a = IB(t); y(bB, function (n) { if (!n || t[n]) { let o; i.sort(function (t, e) { return t.percent - e.percent }), y(i, function (i) { const s = t.animators; const l = n ? i[n] : i; if (l) { let u = w(l); if (n || (u = _(u, function (t) { return p(CB, t) < 0 })), u.length) { o || (o = t.animate(n, e.loop, !0), o.scope = 'keyframe'); for (let h = 0; h < s.length; h++)s[h] !== o && s[h].targetName === o.targetName && s[h].stopTracks(u); n && (a[n] = a[n] || {}); const c = n ? a[n] : a; y(u, function (e) { c[e] = ((n ? t[n] : t) || {})[e] }), o.whenWithKeys(r * i.percent, l, u, i.easing) } } }), o && o.delay(e.delay || 0).duration(r).start(e.easing) } }) } } } function gm (t) { return t instanceof ZC } function ym (t) { return t instanceof sC } function vm (t, e) { e.copyTransform(t), ym(e) && ym(t) && (e.setStyle(t.style), e.z = t.z, e.z2 = t.z2, e.zlevel = t.zlevel, e.invisible = t.invisible, e.ignore = t.ignore, gm(e) && gm(t) && e.setShape(t.shape)) } function mm (t) { let e; const n = t.type; if (n === 'path') { const i = t.shape; const r = i.width != null && i.height != null ? { x: i.x || 0, y: i.y || 0, width: i.width, height: i.height } : null; const o = Vm(i); e = Bs(o, null, r, i.layout || 'center'), mB(e).customPathData = o } else if (n === 'image')e = new QC({}), mB(e).customImagePath = t.style.image; else if (n === 'text')e = new aD({}); else if (n === 'group')e = new CI(); else { if (n === 'compoundPath') throw new Error('"compoundPath" is not supported yet.'); const a = zs(n); if (!a) { const s = ''; Cr(s) }e = new a() } return mB(e).customGraphicType = n, e.name = t.name, e.z2EmphasisLift = 1, e.z2SelectLift = 1, e } function _m (t, e, n, i, r, o, a) { dm(e); const s = r && r.normal.cfg; s && e.setTextConfig(s), i && i.transition == null && (i.transition = NB); const l = i && i.style; if (l) { if (e.type === 'text') { const u = l; $(u, 'textFill') && (u.fill = u.textFill), $(u, 'textStroke') && (u.stroke = u.textStroke) } var h = void 0; const c = gm(e) ? l.decal : null; t && c && (c.dirty = !0, h = pp(c, t)), l.__decalPattern = h } if (ym(e) && l) { var h = l.__decalPattern; h && (l.decal = h) }Jv(e, i, o, { dataIndex: n, isInit: a, clearStyle: !0 }), fm(e, i.keyframeAnimation, o) } function xm (t, e, n, i, r) { const o = e.isGroup ? null : e; const a = r && r[t].cfg; if (o) { const s = o.ensureState(t); if (i === !1) { const l = o.getState(t); l && (l.style = null) } else s.style = i || null; a && (s.textConfig = a), ka(o) } } function wm (t, e, n) { if (!t.isGroup) { const i = t; const r = n.currentZ; const o = n.currentZLevel; i.z = r, i.zlevel = o; const a = e.z2; a != null && (i.z2 = a || 0); for (let s = 0; s < PB.length; s++)bm(i, e, PB[s]) } } function bm (t, e, n) { let i; const r = n === kB; const o = r ? e : Lm(e, n); const a = o ? o.z2 : null; a != null && (i = r ? t : t.ensureState(n), i.z2 = a || 0) } function Sm (t, e, n, i) { function r (t) { return t === w ? b || (b = e.getItemModel(t)) : e.getItemModel(t) } function o (t, n) { return e.hasItemOption ? t === w ? T[n] || (T[n] = r(t).getModel(OB[n])) : r(t).getModel(OB[n]) : D[n] } function a (t, n) { return e.hasItemOption ? t === w ? C[n] || (C[n] = r(t).getModel(RB[n])) : r(t).getModel(RB[n]) : k[n] } function s (t, n) { return n == null && (n = w), e.getStore().get(e.getDimensionIndex(t || 0), n) } function l (t, n) { n == null && (n = w), t = t || 0; const i = e.getDimensionInfo(t); if (!i) { const r = e.getDimensionIndex(t); return r >= 0 ? e.getStore().get(r, n) : void 0 } const o = e.get(i.name, n); const a = i && i.ordinalMeta; return a ? a.categories[o] : o } function u (n, i) { i == null && (i = w); const r = e.getItemVisual(i, 'style'); const s = r && r.fill; const l = r && r.opacity; let u = o(i, kB).getItemStyle(); s != null && (u.fill = s), l != null && (u.opacity = l); const h = { inheritColor: I(s) ? s : '#000' }; const c = a(i, kB); const f = ul(c, null, h, !1, !0); f.text = c.getShallow('show') ? E(t.getFormattedLabel(i, kB), yg(e, i)) : null; const g = hl(c, h, !1); return d(n, u), u = Kv(u, f, g), n && p(u, n), u.legacy = !0, u } function h (n, i) { i == null && (i = w); let r = o(i, DB).getItemStyle(); const s = a(i, DB); const l = ul(s, null, null, !0, !0); l.text = s.getShallow('show') ? V(t.getFormattedLabel(i, DB), t.getFormattedLabel(i, kB), yg(e, i)) : null; const u = hl(s, null, !0); return d(n, r), r = Kv(r, l, u), n && p(r, n), r.legacy = !0, r } function p (t, e) { for (const n in e)$(e, n) && (t[n] = e[n]) } function d (t, e) { t && (t.textFill && (e.textFill = t.textFill), t.textPosition && (e.textPosition = t.textPosition)) } function f (t, n) { if (n == null && (n = w), $(yB, t)) { const i = e.getItemVisual(n, 'style'); return i ? i[yB[t]] : null } return $(vB, t) ? e.getItemVisual(n, t) : void 0 } function g (t) { if (_.type === 'cartesian2d') { const e = _.getBaseAxis(); return Ld(c({ axis: e }, t)) } } function y () { return n.getCurrentSeriesIndices() } function v (t) { return fl(t, n) } const m = t.get('renderItem'); var _ = t.coordinateSystem; let x = {}; _ && (x = _.prepareCustoms ? _.prepareCustoms(_) : EB[_.type](_)); for (var w, b, S = c({ getWidth: i.getWidth, getHeight: i.getHeight, getZr: i.getZr, getDevicePixelRatio: i.getDevicePixelRatio, value: s, style: u, ordinalRawValue: l, styleEmphasis: h, visual: f, barLayout: g, currentSeriesIndices: y, font: v }, x.api || {}), M = { context: {}, seriesId: t.id, seriesName: t.name, seriesIndex: t.seriesIndex, coordSys: x.coordSys, dataInsideLength: e.count(), encode: Mm(t.getData()) }, T = {}, C = {}, D = {}, k = {}, A = 0; A < PB.length; A++) { const L = PB[A]; D[L] = t.getModel(OB[L]), k[L] = t.getModel(RB[L]) } return function (t, n) { return w = t, b = null, T = {}, C = {}, m && m(c({ dataIndexInside: t, dataIndex: e.getRawIndex(t), actionType: n ? n.type : null }, M), S) } } function Mm (t) { const e = {}; return y(t.dimensions, function (n) { const i = t.getDimensionInfo(n); if (!i.isExtraCoord) { const r = i.coordDim; const o = e[r] = e[r] || []; o[i.coordDimIndex] = t.getDimensionIndex(n) } }), e } function Tm (t, e, n, i, r, o, a) { if (!i) return void o.remove(e); const s = Im(t, e, n, i, r, o); return s && a.setItemGraphicEl(n, s), s && $a(s, i.focus, i.blurScope, i.emphasisDisabled), s } function Im (t, e, n, i, r, o) { let a = -1; const s = e; e && Cm(e, i, r) && (a = p(o.childrenRef(), e), e = null); const l = !e; let u = e; u ? u.clearStates() : (u = mm(i), s && vm(s, u)), i.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), BB.normal.cfg = BB.normal.conOpt = BB.emphasis.cfg = BB.emphasis.conOpt = BB.blur.cfg = BB.blur.conOpt = BB.select.cfg = BB.select.conOpt = null, BB.isLegacy = !1, km(u, n, i, r, l, BB), Dm(u, n, i, r, l), _m(t, u, n, i, BB, r, l), $(i, 'info') && (mB(u).info = i.info); for (let h = 0; h < PB.length; h++) { const c = PB[h]; if (c !== kB) { const d = Lm(i, c); const f = Pm(i, d, c); xm(c, u, d, f, BB) } } return wm(u, i, r), i.type === 'group' && Om(t, u, n, i, r), a >= 0 ? o.replaceAt(u, a) : o.add(u), u } function Cm (t, e, n) { const i = mB(t); const r = e.type; const o = e.shape; const a = e.style; return n.isUniversalTransitionEnabled() || r != null && r !== i.customGraphicType || r === 'path' && Fm(o) && Vm(o) !== i.customPathData || r === 'image' && $(a, 'image') && a.image !== i.customImagePath } function Dm (t, e, n, i, r) { const o = n.clipPath; if (o === !1)t && t.getClipPath() && t.removeClipPath(); else if (o) { let a = t.getClipPath(); a && Cm(a, o, i) && (a = null), a || (a = mm(o), t.setClipPath(a)), _m(null, a, e, o, null, i, r) } } function km (t, e, n, i, r, o) { if (!t.isGroup) { Am(n, null, o), Am(n, DB, o); let a = o.normal.conOpt; const s = o.emphasis.conOpt; const l = o.blur.conOpt; const u = o.select.conOpt; if (a != null || s != null || u != null || l != null) { let h = t.getTextContent(); if (a === !1)h && t.removeTextContent(); else { a = o.normal.conOpt = a || { type: 'text' }, h ? h.clearStates() : (h = mm(a), t.setTextContent(h)), _m(null, h, e, a, null, i, r); for (var c = a && a.style, p = 0; p < PB.length; p++) { const d = PB[p]; if (d !== kB) { const f = o[d].conOpt; xm(d, h, f, Pm(a, f, d), null) } }c ? h.dirty() : h.markRedraw() } } } } function Am (t, e, n) { const i = e ? Lm(t, e) : t; const r = e ? Pm(t, i, DB) : t.style; const o = t.type; let a = i ? i.textConfig : null; const s = t.textContent; let l = s ? e ? Lm(s, e) : s : null; if (r && (n.isLegacy || Zv(r, o, !!a, !!l))) { n.isLegacy = !0; const u = jv(r, o, !e); !a && u.textConfig && (a = u.textConfig), !l && u.textContent && (l = u.textContent) } if (!e && l) { const h = l; !h.type && (h.type = 'text') } const c = e ? n[e] : n.normal; c.cfg = a, c.conOpt = l } function Lm (t, e) { return e ? t ? t[e] : null : t } function Pm (t, e, n) { let i = e && e.style; return i == null && n === DB && t && (i = t.styleEmphasis), i } function Om (t, e, n, i, r) { const o = i.children; const a = o ? o.length : 0; const s = i.$mergeChildren; const l = s === 'byName' || i.diffChildrenByName; const u = s === !1; if (a || l || u) { if (l) return void Nm({ api: t, oldChildren: e.children() || [], newChildren: o || [], dataIndex: n, seriesModel: r, group: e }); u && e.removeAll(); for (var h = 0; a > h; h++) { const c = o[h]; const p = e.childAt(h); c ? (c.ignore == null && (c.ignore = !1), Im(t, p, n, c, r, e)) : p.ignore = !0 } for (let d = e.childCount() - 1; d >= h; d--) { const f = e.childAt(d); Rm(e, f, r) } } } function Rm (t, e, n) { e && em(e, mB(t).option, n) } function Nm (t) { new pR(t.oldChildren, t.newChildren, zm, zm, t).add(Bm).update(Bm).remove(Em).execute() } function zm (t, e) { const n = t && t.name; return n != null ? n : zB + e } function Bm (t, e) { const n = this.context; const i = t != null ? n.newChildren[t] : null; const r = e != null ? n.oldChildren[e] : null; Im(n.api, r, n.dataIndex, i, n.seriesModel, n.group) } function Em (t) { const e = this.context; const n = e.oldChildren[t]; n && em(n, mB(n).option, e.seriesModel) } function Vm (t) { return t && (t.pathData || t.d) } function Fm (t) { return t && ($(t, 'pathData') || $(t, 'd')) } function Hm (t) { t.registerChartView(VB), t.registerSeriesModel(_B) } function Wm (t, e) { let n; const i = t.cellSize; n = M(i) ? i : t.cellSize = [i, i], n.length === 1 && (n[1] = n[0]); const r = v([0, 1], function (t) { return au(e, t) && (n[t] = 'auto'), n[t] != null && n[t] !== 'auto' }); lu(t, e, { type: 'box', ignoreSize: r }) } function Gm (t) { const e = t.calendarModel; const n = t.seriesModel; const i = e ? e.coordinateSystem : n ? n.coordinateSystem : null; return i } function Xm (t) { t.registerComponentModel(FB), t.registerComponentView(HB), t.registerCoordinateSystem('calendar', GB) } function Ym (t) { t.registerComponentModel(XB), t.registerComponentView(YB) } function Um (t, e, n) { const i = e.getBoxLayoutParams(); const r = e.get('padding'); const o = { width: n.getWidth(), height: n.getHeight() }; const a = ru(i, o, r); TA(e.get('orient'), t, e.get('itemGap'), a.width, a.height), ou(t, i, o, r) } function Zm (t, e) { const n = _A(e.get('padding')); const i = e.getItemStyle(['color', 'opacity']); return i.fill = e.get('backgroundColor'), t = new nD({ shape: { x: t.x - n[3], y: t.y - n[0], width: t.width + n[1] + n[3], height: t.height + n[0] + n[2], r: e.get('borderRadius') }, style: i, silent: !0, z2: -1 }) } function jm (t, e, n, i, r, o, a) { function s (t, e) { t.lineWidth === 'auto' && (t.lineWidth = e.lineWidth > 0 ? 2 : 0), qB(t, function (n, i) { t[i] === 'inherit' && (t[i] = e[i]) }) } const l = e.getModel('itemStyle'); const u = l.getItemStyle(); const h = t.lastIndexOf('empty', 0) === 0 ? 'fill' : 'stroke'; const c = l.getShallow('decal'); u.decal = c && c !== 'inherit' ? pp(c, a) : i.decal, u.fill === 'inherit' && (u.fill = i[r]), u.stroke === 'inherit' && (u.stroke = i[h]), u.opacity === 'inherit' && (u.opacity = (r === 'fill' ? i : n).opacity), s(u, i); const p = e.getModel('lineStyle'); const d = p.getLineStyle(); if (s(d, n), u.fill === 'auto' && (u.fill = i.fill), u.stroke === 'auto' && (u.stroke = i.fill), d.stroke === 'auto' && (d.stroke = i.fill), !o) { const f = e.get('inactiveBorderWidth'); const g = u[h]; u.lineWidth = f === 'auto' ? i.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = e.get('inactiveColor'), u.stroke = e.get('inactiveBorderColor'), d.stroke = p.get('inactiveColor'), d.lineWidth = p.get('inactiveWidth') } return { itemStyle: u, lineStyle: d } } function qm (t) { const e = t.icon || 'roundRect'; const n = Oc(e, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill, t.symbolKeepAspect); return n.setStyle(t.itemStyle), n.rotation = (t.iconRotate || 0) * Math.PI / 180, n.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), e.indexOf('empty') > -1 && (n.style.stroke = n.style.fill, n.style.fill = '#fff', n.style.lineWidth = 2), n } function Km (t, e, n, i) { Jm(t, e, n, i), n.dispatchAction({ type: 'legendToggleSelect', name: t != null ? t : e }), Qm(t, e, n, i) } function $m (t) { for (var e, n = t.getZr().storage.getDisplayList(), i = 0, r = n.length; r > i && !(e = n[i].states.emphasis);)i++; return e && e.hoverLayer } function Qm (t, e, n, i) { $m(n) || n.dispatchAction({ type: 'highlight', seriesName: t, name: e, excludeSeriesId: i }) } function Jm (t, e, n, i) { $m(n) || n.dispatchAction({ type: 'downplay', seriesName: t, name: e, excludeSeriesId: i }) } function t_ (t) { const e = t.findComponents({ mainType: 'legend' }); e && e.length && t.filterSeries(function (t) { for (let n = 0; n < e.length; n++) if (!e[n].isSelected(t.name)) return !1; return !0 }) } function e_ (t, e, n) { let i; const r = {}; const o = t === 'toggleSelected'; return n.eachComponent('legend', function (n) { o && i != null ? n[i ? 'select' : 'unSelect'](e.name) : t === 'allSelect' || t === 'inverseSelect' ? n[t]() : (n[t](e.name), i = n.isSelected(e.name)); const a = n.getData(); y(a, function (t) { const e = t.get('name'); if (e !== '\n' && e !== '') { const i = n.isSelected(e); r[e] = r.hasOwnProperty(e) ? r[e] && i : i } }) }), t === 'allSelect' || t === 'inverseSelect' ? { selected: r } : { name: e.name, selected: r } } function n_ (t) { t.registerAction('legendToggleSelect', 'legendselectchanged', S(e_, 'toggleSelected')), t.registerAction('legendAllSelect', 'legendselectall', S(e_, 'allSelect')), t.registerAction('legendInverseSelect', 'legendinverseselect', S(e_, 'inverseSelect')), t.registerAction('legendSelect', 'legendselected', S(e_, 'select')), t.registerAction('legendUnSelect', 'legendunselected', S(e_, 'unSelect')) } function i_ (t) { t.registerComponentModel(ZB), t.registerComponentView($B), t.registerProcessor(t.PRIORITY.PROCESSOR.SERIES_FILTER, t_), t.registerSubTypeDefaulter('legend', function () { return 'plain' }), n_(t) } function r_ (t, e, n) { const i = t.getOrient(); const r = [1, 1]; r[i.index] = 0, lu(e, n, { type: 'box', ignoreSize: !!r }) } function o_ (t) { t.registerAction('legendScroll', 'legendscroll', function (t, e) { const n = t.scrollDataIndex; n != null && e.eachComponent({ mainType: 'legend', subType: 'scroll', query: t }, function (t) { t.setScrollDataIndex(n) }) }) } function a_ (t) { ff(i_), t.registerComponentModel(QB), t.registerComponentView(nE), o_(t) } function s_ (t, e, n, i) { l_(iE(n).lastProp, i) || (iE(n).lastProp = i, e ? Is(n, i, t) : (n.stopAnimation(), n.attr(i))) } function l_ (t, e) { if (k(t) && k(e)) { let n = !0; return y(e, function (e, i) { n = n && l_(t[i], e) }), !!n } return t === e } function u_ (t, e) { t[e.get(['label', 'show']) ? 'show' : 'hide']() } function h_ (t) { return { x: t.x || 0, y: t.y || 0, rotation: t.rotation || 0 } } function c_ (t, e, n) { const i = e.get('z'); const r = e.get('zlevel'); t && t.traverse(function (t) { t.type !== 'group' && (i != null && (t.z = i), r != null && (t.zlevel = r), t.silent = n) }) } function p_ (t) { let e; const n = t.get('type'); const i = t.getModel(n + 'Style'); return n === 'line' ? (e = i.getLineStyle(), e.fill = null) : n === 'shadow' && (e = i.getAreaStyle(), e.stroke = null), e } function d_ (t, e, n, i, r) { const o = n.get('value'); const a = g_(o, e.axis, e.ecModel, n.get('seriesDataIndices'), { precision: n.get(['label', 'precision']), formatter: n.get(['label', 'formatter']) }); const s = n.getModel('label'); const l = _A(s.get('padding') || 0); const u = s.getFont(); const h = Bi(a, u); const c = r.position; const p = h.width + l[1] + l[3]; const d = h.height + l[0] + l[2]; const f = r.align; f === 'right' && (c[0] -= p), f === 'center' && (c[0] -= p / 2); const g = r.verticalAlign; g === 'bottom' && (c[1] -= d), g === 'middle' && (c[1] -= d / 2), f_(c, p, d, i); let y = s.get('backgroundColor'); y && y !== 'auto' || (y = e.get(['axisLine', 'lineStyle', 'color'])), t.label = { x: c[0], y: c[1], style: ul(s, { text: a, font: u, fill: s.getTextColor(), padding: l, backgroundColor: y }), z2: 10 } } function f_ (t, e, n, i) { const r = i.getWidth(); const o = i.getHeight(); t[0] = Math.min(t[0] + e, r) - e, t[1] = Math.min(t[1] + n, o) - n, t[0] = Math.max(t[0], 0), t[1] = Math.max(t[1], 0) } function g_ (t, e, n, i, r) { t = e.scale.parse(t); let o = e.scale.getLabel({ value: t }, { precision: r.precision }); const a = r.formatter; if (a) { const s = { value: nf(e, { value: t }), axisDimension: e.dim, axisIndex: e.index, seriesData: [] }; y(i, function (t) { const e = n.getSeriesByIndex(t.seriesIndex); const i = t.dataIndexInside; const r = e && e.getDataParams(i); r && s.seriesData.push(r) }), I(a) ? o = a.replace('{value}', o) : T(a) && (o = a(s)) } return o } function y_ (t, e, n) { const i = Ee(); return Ge(i, i, n.rotation), We(i, i, n.position), Xs([t.dataToCoord(e), (n.labelOffset || 0) + (n.labelDirection || 1) * (n.labelMargin || 0)], i) } function v_ (t, e, n, i, r, o) { const a = dz.innerTextLayout(n.rotation, 0, n.labelDirection); n.labelMargin = r.get(['label', 'margin']), d_(e, i, r, o, { position: y_(i.axis, t, n), align: a.textAlign, verticalAlign: a.textVerticalAlign }) } function m_ (t, e, n) { return n = n || 0, { x1: t[n], y1: t[1 - n], x2: e[n], y2: e[1 - n] } } function __ (t, e, n) { return n = n || 0, { x: t[n], y: t[1 - n], width: e[n], height: e[1 - n] } } function x_ (t, e) { const n = {}; return n[e.dim + 'AxisIndex'] = e.index, t.getCartesian(n) } function w_ (t) { return t.dim === 'x' ? 0 : 1 } function b_ (t, e, n) { if (!ZS.node) { const i = e.getZr(); hE(i).records || (hE(i).records = {}), S_(i, e); const r = hE(i).records[t] || (hE(i).records[t] = {}); r.handler = n } } function S_ (t, e) { function n (n, i) { t.on(n, function (n) { const r = C_(e); cE(hE(t).records, function (t) { t && i(t, n, r.dispatchAction) }), M_(r.pendings, e) }) }hE(t).initialized || (hE(t).initialized = !0, n('click', S(I_, 'click')), n('mousemove', S(I_, 'mousemove')), n('globalout', T_)) } function M_ (t, e) { let n; const i = t.showTip.length; const r = t.hideTip.length; i ? n = t.showTip[i - 1] : r && (n = t.hideTip[r - 1]), n && (n.dispatchAction = null, e.dispatchAction(n)) } function T_ (t, e, n) { t.handler('leave', null, n) } function I_ (t, e, n, i) { e.handler(t, n, i) } function C_ (t) { const e = { showTip: [], hideTip: [] }; const n = function (i) { const r = e[i.type]; r ? r.push(i) : (i.dispatchAction = n, t.dispatchAction(i)) }; return { dispatchAction: n, pendings: e } } function D_ (t, e) { if (!ZS.node) { const n = e.getZr(); const i = (hE(n).records || {})[t]; i && (hE(n).records[t] = null) } } function k_ (t, e) { let n; let i = []; const r = t.seriesIndex; if (r == null || !(n = e.getSeriesByIndex(r))) return { point: [] }; const o = n.getData(); const a = jr(o, t); if (a == null || a < 0 || M(a)) return { point: [] }; const s = o.getItemGraphicEl(a); const l = n.coordinateSystem; if (n.getTooltipPosition)i = n.getTooltipPosition(a) || []; else if (l && l.dataToPoint) if (t.isStacked) { const u = l.getBaseAxis(); const h = l.getOtherAxis(u); const c = h.dim; const p = u.dim; const d = c === 'x' || c === 'radius' ? 1 : 0; const f = o.mapDimension(p); const g = []; g[d] = o.get(f, a), g[1 - d] = o.get(o.getCalculationInfo('stackResultDimension'), a), i = l.dataToPoint(g) || [] } else i = l.dataToPoint(o.getValues(v(l.dimensions, function (t) { return o.mapDimension(t) }), a)) || []; else if (s) { const y = s.getBoundingRect().clone(); y.applyTransform(s.transform), i = [y.x + y.width / 2, y.y + y.height / 2] } return { point: i, el: s } } function A_ (t, e, n) { const i = t.currTrigger; let r = [t.x, t.y]; const o = t; const a = t.dispatchAction || gM(n.dispatchAction, n); const s = e.getComponent('axisPointer').coordSysAxesInfo; if (s) { F_(r) && (r = k_({ seriesIndex: o.seriesIndex, dataIndex: o.dataIndex }, e).point); const l = F_(r); const u = o.axesInfo; const h = s.axesInfo; const c = i === 'leave' || F_(r); const p = {}; const d = {}; const f = { list: [], map: {} }; const g = { showPointer: S(O_, d), showTooltip: S(R_, f) }; y(s.coordSysMap, function (t, e) { const n = l || t.containPoint(r); y(s.coordSysAxesInfo[e], function (t) { const e = t.axis; const i = E_(u, t); if (!c && n && (!u || i)) { let o = i && i.value; o != null || l || (o = e.pointToData(r)), o != null && L_(t, o, g, !1, p) } }) }); const v = {}; return y(h, function (t, e) { const n = t.linkGroup; n && !d[e] && y(n.axesInfo, function (e, i) { const r = d[i]; if (e !== t && r) { let o = r.value; n.mapper && (o = t.axis.scale.parse(n.mapper(o, V_(e), V_(t)))), v[t.key] = o } }) }), y(v, function (t, e) { L_(h[e], t, g, !0, p) }), N_(d, h, p), z_(f, r, t, a), B_(h, a, n), p } } function L_ (t, e, n, i, r) { const o = t.axis; if (!o.scale.isBlank() && o.containData(e)) { if (!t.involveSeries) return void n.showPointer(t, e); const a = P_(e, t); const s = a.payloadBatch; const l = a.snapToValue; s[0] && r.seriesIndex == null && h(r, s[0]), !i && t.snap && o.containData(l) && l != null && (e = l), n.showPointer(t, e, s), n.showTooltip(t, a, l) } } function P_ (t, e) { const n = e.axis; const i = n.dim; let r = t; const o = []; let a = Number.MAX_VALUE; let s = -1; return y(e.seriesModels, function (e) { let l; let u; const h = e.getData().mapDimensionsAll(i); if (e.getAxisTooltipData) { const c = e.getAxisTooltipData(h, t, n); u = c.dataIndices, l = c.nestestValue } else { if (u = e.getData().indicesOfNearest(h[0], t, n.type === 'category' ? 0.5 : null), !u.length) return; l = e.getData().get(h[0], u[0]) } if (l != null && isFinite(l)) { const p = t - l; const d = Math.abs(p); a >= d && ((a > d || p >= 0 && s < 0) && (a = d, s = p, r = l, o.length = 0), y(u, function (t) { o.push({ seriesIndex: e.seriesIndex, dataIndexInside: t, dataIndex: e.getData().getRawIndex(t) }) })) } }), { payloadBatch: o, snapToValue: r } } function O_ (t, e, n, i) {
    t[e.key] = { value: n, payloadBatch: i }
  } function R_ (t, e, n, i) { const r = n.payloadBatch; const o = e.axis; const a = o.model; const s = e.axisPointerModel; if (e.triggerTooltip && r.length) { const l = e.coordSys.model; const u = Qg(l); let h = t.map[u]; h || (h = t.map[u] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, t.list.push(h)), h.dataByAxis.push({ axisDim: o.dim, axisIndex: a.componentIndex, axisType: a.type, axisId: a.id, value: i, valueLabelOpt: { precision: s.get(['label', 'precision']), formatter: s.get(['label', 'formatter']) }, seriesDataIndices: r.slice() }) } } function N_ (t, e, n) { const i = n.axesInfo = []; y(e, function (e, n) { const r = e.axisPointerModel.option; const o = t[n]; o ? (!e.useHandle && (r.status = 'show'), r.value = o.value, r.seriesDataIndices = (o.payloadBatch || []).slice()) : !e.useHandle && (r.status = 'hide'), r.status === 'show' && i.push({ axisDim: e.axis.dim, axisIndex: e.axis.model.componentIndex, value: r.value }) }) } function z_ (t, e, n, i) { if (F_(e) || !t.list.length) return void i({ type: 'hideTip' }); const r = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}; i({ type: 'showTip', escapeConnect: !0, x: e[0], y: e[1], tooltipOption: n.tooltipOption, position: n.position, dataIndexInside: r.dataIndexInside, dataIndex: r.dataIndex, seriesIndex: r.seriesIndex, dataByCoordSys: t.list }) } function B_ (t, e, n) { const i = n.getZr(); const r = 'axisPointerLastHighlights'; const o = dE(i)[r] || {}; const a = dE(i)[r] = {}; y(t, function (t) { const e = t.axisPointerModel.option; e.status === 'show' && y(e.seriesDataIndices, function (t) { const e = t.seriesIndex + ' | ' + t.dataIndex; a[e] = t }) }); const s = []; const l = []; y(o, function (t, e) { !a[e] && l.push(t) }), y(a, function (t, e) { !o[e] && s.push(t) }), l.length && n.dispatchAction({ type: 'downplay', escapeConnect: !0, notBlur: !0, batch: l }), s.length && n.dispatchAction({ type: 'highlight', escapeConnect: !0, notBlur: !0, batch: s }) } function E_ (t, e) { for (let n = 0; n < (t || []).length; n++) { const i = t[n]; if (e.axis.dim === i.axisDim && e.axis.model.componentIndex === i.axisIndex) return i } } function V_ (t) { const e = t.axis.model; const n = {}; const i = n.axisDim = t.axis.dim; return n.axisIndex = n[i + 'AxisIndex'] = e.componentIndex, n.axisName = n[i + 'AxisName'] = e.name, n.axisId = n[i + 'AxisId'] = e.id, n } function F_ (t) { return !t || t[0] == null || isNaN(t[0]) || t[1] == null || isNaN(t[1]) } function H_ (t) { yz.registerAxisPointerClass('CartesianAxisPointer', sE), t.registerComponentModel(uE), t.registerComponentView(pE), t.registerPreprocessor(function (t) { if (t) { (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {}); const e = t.axisPointer.link; e && !M(e) && (t.axisPointer.link = [e]) } }), t.registerProcessor(t.PRIORITY.PROCESSOR.STATISTIC, function (t, e) { t.getComponent('axisPointer').coordSysAxesInfo = Wg(t, e) }), t.registerAction({ type: 'updateAxisPointer', event: 'updateAxisPointer', update: ':updateAxisPointer' }, A_) } function W_ (t) { const e = t.get('confine'); return e != null ? !!e : t.get('renderMode') === 'richText' } function G_ (t) { if (ZS.domSupported) for (let e = document.documentElement.style, n = 0, i = t.length; i > n; n++) if (t[n] in e) return t[n] } function X_ (t, e) { if (!t) return e; e = jl(e, !0); const n = t.indexOf(e); return t = n === -1 ? e : '-' + t.slice(0, n) + '-' + e, t.toLowerCase() } function Y_ (t, e) { const n = t.currentStyle || document.defaultView && document.defaultView.getComputedStyle(t); return n ? e ? n[e] : n : null } function U_ (t) { return t = t === 'left' ? 'right' : t === 'right' ? 'left' : t === 'top' ? 'bottom' : 'top' } function Z_ (t, e, n) { if (!I(n) || n === 'inside') return ''; const i = t.get('backgroundColor'); const r = t.get('borderWidth'); e = eu(e); let o; const a = U_(n); const s = Math.max(1.5 * Math.round(r), 6); let l = ''; let u = mE + ':'; p(['left', 'right'], a) > -1 ? (l += 'top:50%', u += 'translateY(-50%) rotate(' + (o = a === 'left' ? -225 : -45) + 'deg)') : (l += 'left:50%', u += 'translateX(-50%) rotate(' + (o = a === 'top' ? 225 : 45) + 'deg)'); const h = o * Math.PI / 180; const c = s + r; const d = c * Math.abs(Math.cos(h)) + c * Math.abs(Math.sin(h)); const f = Math.round(100 * ((d - Math.SQRT2 * r) / 2 + Math.SQRT2 * r - (d - c) / 2)) / 100; l += ';' + a + ':-' + f + 'px'; const g = e + ' solid ' + r + 'px;'; const y = ['position:absolute;width:' + s + 'px;height:' + s + 'px;z-index:-1;', l + ';' + u + ';', 'border-bottom:' + g, 'border-right:' + g, 'background-color:' + i + ';']; return '<div style="' + y.join('') + '"></div>' } function j_ (t, e) { const n = 'cubic-bezier(0.23,1,0.32,1)'; let i = ' ' + t / 2 + 's ' + n; let r = 'opacity' + i + ',visibility' + i; return e || (i = ' ' + t + 's ' + n, r += ZS.transformSupported ? ',' + mE + i : ',left' + i + ',top' + i), vE + ':' + r } function q_ (t, e, n) { const i = t.toFixed(0) + 'px'; const r = e.toFixed(0) + 'px'; if (!ZS.transformSupported) return n ? 'top:' + r + ';left:' + i + ';' : [['top', r], ['left', i]]; const o = ZS.transform3dSupported; const a = 'translate' + (o ? '3d' : '') + '(' + i + ',' + r + (o ? ',0' : '') + ')'; return n ? 'top:0;left:0;' + mE + ':' + a + ';' : [['top', 0], ['left', 0], [gE, a]] } function K_ (t) { const e = []; const n = t.get('fontSize'); const i = t.getTextColor(); i && e.push('color:' + i), e.push('font:' + t.getFont()), n && e.push('line-height:' + Math.round(3 * n / 2) + 'px'); const r = t.get('textShadowColor'); const o = t.get('textShadowBlur') || 0; const a = t.get('textShadowOffsetX') || 0; const s = t.get('textShadowOffsetY') || 0; return r && o && e.push('text-shadow:' + a + 'px ' + s + 'px ' + o + 'px ' + r), y(['decoration', 'align'], function (n) { const i = t.get(n); i && e.push('text-' + n + ':' + i) }), e.join(';') } function $_ (t, e, n) { const i = []; const r = t.get('transitionDuration'); const o = t.get('backgroundColor'); const a = t.get('shadowBlur'); const s = t.get('shadowColor'); const l = t.get('shadowOffsetX'); const u = t.get('shadowOffsetY'); const h = t.getModel('textStyle'); const c = Zh(t, 'html'); const p = l + 'px ' + u + 'px ' + a + 'px ' + s; return i.push('box-shadow:' + p), e && r && i.push(j_(r, n)), o && i.push('background-color:' + o), y(['width', 'color', 'radius'], function (e) { const n = 'border-' + e; const r = jl(n); const o = t.get(r); o != null && i.push(n + ':' + o + (e === 'color' ? '' : 'px')) }), i.push(K_(h)), c != null && i.push('padding:' + _A(c).join('px ') + 'px'), i.join(';') + ';' } function Q_ (t, e, n, i, r) { const o = e && e.painter; if (n) { const a = o && o.getViewportRoot(); a && be(t, a, document.body, i, r) } else { t[0] = i, t[1] = r; const s = o && o.getViewportRootOffset(); s && (t[0] += s.offsetLeft, t[1] += s.offsetTop) }t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight() } function J_ (t) { return Math.max(0, t) } function tx (t) { const e = J_(t.shadowBlur || 0); const n = J_(t.shadowOffsetX || 0); const i = J_(t.shadowOffsetY || 0); return { left: J_(e - n), right: J_(e + n), top: J_(e - i), bottom: J_(e + i) } } function ex (t, e, n, i) { t[0] = n, t[1] = i, t[2] = t[0] / e.getWidth(), t[3] = t[1] / e.getHeight() } function nx (t, e, n) { let i; const r = e.ecModel; n ? (i = new Jk(n, r, r), i = new Jk(e.option, i, r)) : i = e; for (let o = t.length - 1; o >= 0; o--) { let a = t[o]; a && (a instanceof Jk && (a = a.get('tooltip', !0)), I(a) && (a = { formatter: a }), a && (i = new Jk(a, i, r))) } return i } function ix (t, e) { return t.dispatchAction || gM(e.dispatchAction, e) } function rx (t, e, n, i, r, o, a) { const s = n.getSize(); const l = s[0]; const u = s[1]; return o != null && (t + l + o + 2 > i ? t -= l + o : t += o), a != null && (e + u + a > r ? e -= u + a : e += a), [t, e] } function ox (t, e, n, i, r) { const o = n.getSize(); const a = o[0]; const s = o[1]; return t = Math.min(t + a, i) - a, e = Math.min(e + s, r) - s, t = Math.max(t, 0), e = Math.max(e, 0), [t, e] } function ax (t, e, n, i) { const r = n[0]; const o = n[1]; const a = Math.ceil(Math.SQRT2 * i) + 8; let s = 0; let l = 0; const u = e.width; const h = e.height; switch (t) { case 'inside':s = e.x + u / 2 - r / 2, l = e.y + h / 2 - o / 2; break; case 'top':s = e.x + u / 2 - r / 2, l = e.y - o - a; break; case 'bottom':s = e.x + u / 2 - r / 2, l = e.y + h + a; break; case 'left':s = e.x - r - a, l = e.y + h / 2 - o / 2; break; case 'right':s = e.x + u + a, l = e.y + h / 2 - o / 2 } return [s, l] } function sx (t) { return t === 'center' || t === 'middle' } function lx (t, e, n) { const i = $r(t).queryOptionMap; const r = i.keys()[0]; if (r && r !== 'series') { const o = Qr(e, r, i.get(r), { useDefault: !1, enableAll: !1, enableNone: !1 }); const a = o.models[0]; if (a) { let s; const l = n.getViewOfComponentModel(a); return l.group.traverse(function (e) { const n = hD(e).tooltipConfig; return n && n.name === t.name ? (s = e, !0) : void 0 }), s ? { componentMainType: r, componentIndex: a.componentIndex, el: s } : void 0 } } } function ux (t) { ff(H_), t.registerComponentModel(fE), t.registerComponentView(SE), t.registerAction({ type: 'showTip', event: 'showTip', update: 'tooltip:manuallyShowTip' }, Q), t.registerAction({ type: 'hideTip', event: 'hideTip', update: 'tooltip:manuallyHideTip' }, Q) } function hx (t, e) { if (!t) return !1; for (let n = M(t) ? t : [t], i = 0; i < n.length; i++) if (n[i] && n[i][e]) return !0; return !1 } function cx (t) { Ar(t, 'label', ['show']) } function px (t) { return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y))) } function dx (t) { return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y)) } function fx (t, e, n, i, r, o) { const a = []; const s = cd(e, i); const l = s ? e.getCalculationInfo('stackResultDimension') : i; const u = xx(e, l, t); const h = e.indicesOfNearest(l, u)[0]; a[r] = e.get(n, h), a[o] = e.get(l, h); const c = e.get(i, h); let p = lr(e.get(i, h)); return p = Math.min(p, 20), p >= 0 && (a[o] = +a[o].toFixed(p)), [a, c] } function gx (t, e) { if (e) { const n = t.getData(); const i = t.coordinateSystem; const r = i && i.dimensions; if (!dx(e) && !M(e.coord) && M(r)) { const o = yx(e, n, i, t); if (e = s(e), e.type && CE[e.type] && o.baseAxis && o.valueAxis) { const a = p(r, o.baseAxis.dim); const l = p(r, o.valueAxis.dim); const u = CE[e.type](n, o.baseDataDim, o.valueDataDim, a, l); e.coord = u[0], e.value = u[1] } else e.coord = [e.xAxis != null ? e.xAxis : e.radiusAxis, e.yAxis != null ? e.yAxis : e.angleAxis] } if (e.coord != null && M(r)) for (let h = e.coord, c = 0; c < 2; c++)CE[h[c]] && (h[c] = xx(n, n.mapDimension(r[c]), h[c])); else e.coord = []; return e } } function yx (t, e, n, i) { const r = {}; return t.valueIndex != null || t.valueDim != null ? (r.valueDataDim = t.valueIndex != null ? e.getDimension(t.valueIndex) : t.valueDim, r.valueAxis = n.getAxis(vx(i, r.valueDataDim)), r.baseAxis = n.getOtherAxis(r.valueAxis), r.baseDataDim = e.mapDimension(r.baseAxis.dim)) : (r.baseAxis = i.getBaseAxis(), r.valueAxis = n.getOtherAxis(r.baseAxis), r.baseDataDim = e.mapDimension(r.baseAxis.dim), r.valueDataDim = e.mapDimension(r.valueAxis.dim)), r } function vx (t, e) { const n = t.getData().getDimensionInfo(e); return n && n.coordDim } function mx (t, e) { return t && t.containData && e.coord && !px(e) ? t.containData(e.coord) : !0 } function _x (t, e) { return t ? function (t, n, i, r) { const o = r < 2 ? t.coord && t.coord[r] : t.value; return gh(o, e[r]) } : function (t, n, i, r) { return gh(t.value, e[r]) } } function xx (t, e, n) { if (n === 'average') { let i = 0; let r = 0; return t.each(e, function (t) { isNaN(t) || (i += t, r++) }), i / r } return n === 'median' ? t.getMedian(e) : t.getDataExtent(e)[n === 'max' ? 1 : 0] } function bx (t, e, n) { const i = e.coordinateSystem; t.each(function (r) { let o; const a = t.getItemModel(r); const s = or(a.get('x'), n.getWidth()); const l = or(a.get('y'), n.getHeight()); if (isNaN(s) || isNaN(l)) { if (e.getMarkerPosition)o = e.getMarkerPosition(t.getValues(t.dimensions, r)); else if (i) { const u = t.get(i.dimensions[0], r); const h = t.get(i.dimensions[1], r); o = i.dataToPoint([u, h]) } } else o = [s, l]; isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), t.setItemLayout(r, o) }) } function Sx (t, e, n) { let i; i = t ? v(t && t.dimensions, function (t) { const n = e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {}; return h(h({}, n), { name: t, ordinalMeta: null }) }) : [{ name: 'value', type: 'float' }]; const r = new TR(i, n); let o = v(n.get('data'), S(gx, e)); t && (o = _(o, S(mx, t))); const a = _x(!!t, i); return r.initData(o, null, a), r } function Mx (t) { t.registerComponentModel(IE), t.registerComponentView(AE), t.registerPreprocessor(function (t) { hx(t.series, 'markPoint') && (t.markPoint = t.markPoint || {}) }) } function Tx (t, e) { return t.type === e } function Ix (t) { return !isNaN(t) && !isFinite(t) } function Cx (t, e, n, i) { const r = 1 - t; const o = i.dimensions[t]; return Ix(e[r]) && Ix(n[r]) && e[t] === n[t] && i.getAxis(o).containData(e[t]) } function Dx (t, e) { if (t.type === 'cartesian2d') { const n = e[0].coord; const i = e[1].coord; if (n && i && (Cx(1, n, i, t) || Cx(0, n, i, t))) return !0 } return mx(t, e[0]) && mx(t, e[1]) } function kx (t, e, n, i, r) { let o; const a = i.coordinateSystem; const s = t.getItemModel(e); const l = or(s.get('x'), r.getWidth()); const u = or(s.get('y'), r.getHeight()); if (isNaN(l) || isNaN(u)) { if (i.getMarkerPosition)o = i.getMarkerPosition(t.getValues(t.dimensions, e)); else { var h = a.dimensions; const c = t.get(h[0], e); const p = t.get(h[1], e); o = a.dataToPoint([c, p]) } if (Tx(a, 'cartesian2d')) { const d = a.getAxis('x'); const f = a.getAxis('y'); var h = a.dimensions; Ix(t.get(h[0], e)) ? o[0] = d.toGlobalCoord(d.getExtent()[n ? 0 : 1]) : Ix(t.get(h[1], e)) && (o[1] = f.toGlobalCoord(f.getExtent()[n ? 0 : 1])) }isNaN(l) || (o[0] = l), isNaN(u) || (o[1] = u) } else o = [l, u]; t.setItemLayout(e, o) } function Ax (t, e, n) { let i; i = t ? v(t && t.dimensions, function (t) { const n = e.getData().getDimensionInfo(e.getData().mapDimension(t)) || {}; return h(h({}, n), { name: t, ordinalMeta: null }) }) : [{ name: 'value', type: 'float' }]; const r = new TR(i, n); const o = new TR(i, n); const a = new TR([], n); let s = v(n.get('data'), S(OE, e, t, n)); t && (s = _(s, S(Dx, t))); const l = _x(!!t, i); return r.initData(v(s, function (t) { return t[0] }), null, l), o.initData(v(s, function (t) { return t[1] }), null, l), a.initData(v(s, function (t) { return t[2] })), a.hasItemOption = !0, { from: r, to: o, line: a } } function Lx (t) { t.registerComponentModel(LE), t.registerComponentView(RE), t.registerPreprocessor(function (t) { hx(t.series, 'markLine') && (t.markLine = t.markLine || {}) }) } function Px (t, e) { const n = kr(t ? t.brush : []); if (n.length) { let i = []; y(n, function (t) { const e = t.hasOwnProperty('toolbox') ? t.toolbox : []; e instanceof Array && (i = i.concat(e)) }); let r = t && t.toolbox; M(r) && (r = r[0]), r || (r = { feature: {} }, t.toolbox = [r]); const o = r.feature || (r.feature = {}); const a = o.brush || (o.brush = {}); const s = a.type || (a.type = []); s.push.apply(s, i), Ox(s), e && !s.length && s.push.apply(s, NE) } } function Ox (t) { const e = {}; y(t, function (t) { e[t] = 1 }), t.length = 0, y(e, function (e, n) { t.push(n) }) } function Rx (t, e) { const n = KE[e.brushType].createCover(t, e); return n.__brushOption = e, Bx(n, e), t.group.add(n), n } function Nx (t, e) { const n = Vx(e); return n.endCreating && (n.endCreating(t, e), Bx(e, e.__brushOption)), e } function zx (t, e) { const n = e.__brushOption; Vx(e).updateCoverShape(t, e, n.range, n) } function Bx (t, e) { let n = e.z; n == null && (n = FE), t.traverse(function (t) { t.z = n, t.z2 = n }) } function Ex (t, e) { Vx(e).updateCommon(t, e), zx(t, e) } function Vx (t) { return KE[t.__brushOption.brushType] } function Fx (t, e, n) { const i = t._panels; if (!i) return zE; let r; const o = t._transform; return y(i, function (t) { t.isTargetByCursor(e, n, o) && (r = t) }), r } function Hx (t, e) { const n = t._panels; if (!n) return zE; const i = e.__brushOption.panelId; return i != null ? n[i] : zE } function Wx (t) { const e = t._covers; const n = e.length; return y(e, function (e) { t.group.remove(e) }, t), e.length = 0, !!n } function Gx (t, e) { const n = v(t._covers, function (t) { const e = t.__brushOption; const n = s(e.range); return { brushType: e.brushType, panelId: e.panelId, range: n } }); t.trigger('brush', { areas: n, isEnd: !!e.isEnd, removeOnClick: !!e.removeOnClick }) } function Xx (t) { const e = t._track; if (!e.length) return !1; const n = e[e.length - 1]; const i = e[0]; const r = n[0] - i[0]; const o = n[1] - i[1]; const a = VE(r * r + o * o, 0.5); return a > HE } function Yx (t) { let e = t.length - 1; return e < 0 && (e = 0), [t[0], t[e]] } function Ux (t, e, n, i) { const r = new CI(); return r.add(new nD({ name: 'main', style: Kx(n), silent: !0, draggable: !0, cursor: 'move', drift: S(ew, t, e, r, ['n', 's', 'w', 'e']), ondragend: S(Gx, e, { isEnd: !0 }) })), y(i, function (n) { r.add(new nD({ name: n.join(''), style: { opacity: 0 }, draggable: !0, silent: !0, invisible: !0, drift: S(ew, t, e, r, n), ondragend: S(Gx, e, { isEnd: !0 }) })) }), r } function Zx (t, e, n, i) { const r = i.brushStyle.lineWidth || 0; const o = EE(r, WE); const a = n[0][0]; const s = n[1][0]; const l = a - r / 2; const u = s - r / 2; const h = n[0][1]; const c = n[1][1]; const p = h - o + r / 2; const d = c - o + r / 2; const f = h - a; const g = c - s; const y = f + r; const v = g + r; qx(t, e, 'main', a, s, f, g), i.transformable && (qx(t, e, 'w', l, u, o, v), qx(t, e, 'e', p, u, o, v), qx(t, e, 'n', l, u, y, o), qx(t, e, 's', l, d, y, o), qx(t, e, 'nw', l, u, o, o), qx(t, e, 'ne', p, u, o, o), qx(t, e, 'sw', l, d, o, o), qx(t, e, 'se', p, d, o, o)) } function jx (t, e) { const n = e.__brushOption; const i = n.transformable; const r = e.childAt(0); r.useStyle(Kx(n)), r.attr({ silent: !i, cursor: i ? 'move' : 'default' }), y([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (n) { const r = e.childOfName(n.join('')); const o = n.length === 1 ? Jx(t, n[0]) : tw(t, n); r && r.attr({ silent: !i, invisible: !i, cursor: i ? YE[o] + '-resize' : null }) }) } function qx (t, e, n, i, r, o, a) { const s = e.childOfName(n); s && s.setShape(ow(rw(t, e, [[i, r], [i + o, r + a]]))) } function Kx (t) { return c({ strokeNoScale: !0 }, t.brushStyle) } function $x (t, e, n, i) { const r = [BE(t, n), BE(e, i)]; const o = [EE(t, n), EE(e, i)]; return [[r[0], o[0]], [r[1], o[1]]] } function Qx (t) { return Gs(t.group) } function Jx (t, e) { const n = { w: 'left', e: 'right', n: 'top', s: 'bottom' }; const i = { left: 'w', right: 'e', top: 'n', bottom: 's' }; const r = Ys(n[e], Qx(t)); return i[r] } function tw (t, e) { const n = [Jx(t, e[0]), Jx(t, e[1])]; return (n[0] === 'e' || n[0] === 'w') && n.reverse(), n.join('') } function ew (t, e, n, i, r, o) { const a = n.__brushOption; const s = t.toRectRange(a.range); const l = iw(e, r, o); y(i, function (t) { const e = XE[t]; s[e[0]][e[1]] += l[e[0]] }), a.range = t.fromRectRange($x(s[0][0], s[1][0], s[0][1], s[1][1])), Ex(e, n), Gx(e, { isEnd: !1 }) } function nw (t, e, n, i) { const r = e.__brushOption.range; const o = iw(t, n, i); y(r, function (t) { t[0] += o[0], t[1] += o[1] }), Ex(t, e), Gx(t, { isEnd: !1 }) } function iw (t, e, n) { const i = t.group; const r = i.transformCoordToLocal(e, n); const o = i.transformCoordToLocal(0, 0); return [r[0] - o[0], r[1] - o[1]] } function rw (t, e, n) { const i = Hx(t, e); return i && i !== zE ? i.clipPath(n, t._transform) : s(n) } function ow (t) { const e = BE(t[0][0], t[1][0]); const n = BE(t[0][1], t[1][1]); const i = EE(t[0][0], t[1][0]); const r = EE(t[0][1], t[1][1]); return { x: e, y: n, width: i - e, height: r - n } } function aw (t, e, n) { if (t._brushType && !pw(t, e.offsetX, e.offsetY)) { const i = t._zr; const r = t._covers; const o = Fx(t, e, n); if (!t._dragging) for (let a = 0; a < r.length; a++) { const s = r[a].__brushOption; if (o && (o === zE || s.panelId === o.panelId) && KE[s.brushType].contain(r[a], n[0], n[1])) return }o && i.setCursorStyle('crosshair') } } function sw (t) { const e = t.event; e.preventDefault && e.preventDefault() } function lw (t, e, n) { return t.childOfName('main').contain(e, n) } function uw (t, e, n, i) { let r; let o = t._creatingCover; const a = t._creatingPanel; const l = t._brushOption; if (t._track.push(n.slice()), Xx(t) || o) { if (a && !o) { l.brushMode === 'single' && Wx(t); const u = s(l); u.brushType = hw(u.brushType, a), u.panelId = a === zE ? null : a.panelId, o = t._creatingCover = Rx(t, u), t._covers.push(o) } if (o) { const h = KE[hw(t._brushType, a)]; const c = o.__brushOption; c.range = h.getCreatingRange(rw(t, o, t._track)), i && (Nx(t, o), h.updateCommon(t, o)), zx(t, o), r = { isEnd: i } } } else i && l.brushMode === 'single' && l.removeOnClick && Fx(t, e, n) && Wx(t) && (r = { isEnd: i, removeOnClick: !0 }); return r } function hw (t, e) { return t === 'auto' ? e.defaultBrushType : t } function cw (t, e) { if (t._dragging) { sw(e); const n = e.offsetX; const i = e.offsetY; const r = t.group.transformCoordToLocal(n, i); const o = uw(t, e, r, !0); t._dragging = !1, t._track = [], t._creatingCover = null, o && Gx(t, o) } } function pw (t, e, n) { const i = t._zr; return e < 0 || e > i.getWidth() || n < 0 || n > i.getHeight() } function dw (t) { return { createCover: function (e, n) { return Ux({ toRectRange: function (e) { const n = [e, [0, 100]]; return t && n.reverse(), n }, fromRectRange: function (e) { return e[t] } }, e, n, [[['w'], ['e']], [['n'], ['s']]][t]) }, getCreatingRange: function (e) { const n = Yx(e); const i = BE(n[0][t], n[1][t]); const r = EE(n[0][t], n[1][t]); return [i, r] }, updateCoverShape: function (e, n, i, r) { let o; const a = Hx(e, n); if (a !== zE && a.getLinearBrushOtherExtent)o = a.getLinearBrushOtherExtent(t); else { const s = e._zr; o = [0, [s.getWidth(), s.getHeight()][1 - t]] } const l = [i, o]; t && l.reverse(), Zx(e, n, l, r) }, updateCommon: jx, contain: lw } } function fw (t) { const e = t.pieceList; t.hasSpecialVisual = !1, y(e, function (e, n) { e.originIndex = n, e.visual != null && (t.hasSpecialVisual = !0) }) } function gw (t) { const e = t.categories; const n = t.categoryMap = {}; let i = t.visual; if ($E(e, function (t, e) { n[t] = e }), !M(i)) { const r = []; k(i) ? $E(i, function (t, e) { const i = n[e]; r[i != null ? i : JE] = t }) : r[JE] = i, i = Mw(t, r) } for (let o = e.length - 1; o >= 0; o--)i[o] == null && (delete n[e[o]], e.pop()) } function yw (t, e) { const n = t.visual; const i = []; k(n) ? $E(n, function (t) { i.push(t) }) : n != null && i.push(n); const r = { color: 1, symbol: 1 }; e || i.length !== 1 || r.hasOwnProperty(t.type) || (i[1] = i[0]), Mw(t, i) } function vw (t) { return { applyVisual: function (e, n, i) { const r = this.mapValueToVisual(e); i('color', t(n('color'), r)) }, _normalizedToVisual: bw([0, 1]) } } function mw (t) { const e = this.option.visual; return e[Math.round(rr(t, [0, 1], [0, e.length - 1], !0))] || {} } function _w (t) { return function (e, n, i) { i(t, this.mapValueToVisual(e)) } } function xw (t) { const e = this.option.visual; return e[this.option.loop && t !== JE ? t % e.length : t] } function ww () { return this.option.visual[0] } function bw (t) { return { linear: function (e) { return rr(e, t, this.option.visual, !0) }, category: xw, piecewise: function (e, n) { let i = Sw.call(this, n); return i == null && (i = rr(e, t, this.option.visual, !0)), i }, fixed: ww } } function Sw (t) { const e = this.option; const n = e.pieceList; if (e.hasSpecialVisual) { const i = tV.findPieceIndex(t, n); const r = n[i]; if (r && r.visual) return r.visual[this.type] } } function Mw (t, e) { return t.visual = e, t.type === 'color' && (t.parsedVisual = v(e, function (t) { const e = zn(t); return e || [0, 0, 0, 1] })), e } function Tw (t, e, n) { return t ? n >= e : n > e } function Iw (t) { if (t) for (const e in t) if (t.hasOwnProperty(e)) return !0 } function Cw (t, e, n) { function i () { const t = function () {}; t.prototype.__hidden = t.prototype; const e = new t(); return e } const r = {}; return nV(e, function (e) { const o = r[e] = i(); nV(t[e], function (t, i) { if (tV.isValidType(i)) { let r = { type: i, visual: t }; n && n(r, e), o[i] = new tV(r), i === 'opacity' && (r = s(r), r.type = 'colorAlpha', o.__hidden.__alphaForOpacity = new tV(r)) } }) }), r } function Dw (t, e, n) { let i; y(n, function (t) { e.hasOwnProperty(t) && Iw(e[t]) && (i = !0) }), i && y(n, function (n) { e.hasOwnProperty(n) && Iw(e[n]) ? t[n] = s(e[n]) : delete t[n] }) } function kw (t, e, n, i, r, o) { function a (t) { return Ic(n, h, t) } function s (t, e) { Dc(n, h, t, e) } function l (t, l) { h = o == null ? t : l; const c = n.getRawDataItem(h); if (!c || c.visualMap !== !1) for (let p = i.call(r, t), d = e[p], f = u[p], g = 0, y = f.length; y > g; g++) { const v = f[g]; d[v] && d[v].applyVisual(t, a, s) } } var u = {}; y(t, function (t) { const n = tV.prepareVisualTypes(e[t]); u[t] = n }); let h; o == null ? n.each(l) : n.each([o], l) } function Aw (t) { const e = t.brushType; var n = { point: function (i) { return iV[e].point(i, n, t) }, rect: function (i) { return iV[e].rect(i, n, t) } }; return n } function Lw (t) { const e = ['x', 'y']; const n = ['width', 'height']; return { point: function (e, n, i) { if (e) { const r = i.range; const o = e[t]; return Pw(o, r) } }, rect: function (i, r, o) { if (i) { const a = o.range; const s = [i[e[t]], i[e[t]] + i[n[t]]]; return s[1] < s[0] && s.reverse(), Pw(s[0], a) || Pw(s[1], a) || Pw(a[0], s) || Pw(a[1], s) } } } } function Pw (t, e) { return e[0] <= t && t <= e[1] } function Ow (t) { return t = zw(t), function (e) { return qs(e, t) } } function Rw (t, e) { return t = zw(t), function (n) { const i = e != null ? e : n; const r = i ? t.width : t.height; const o = i ? t.x : t.y; return [o, o + (r || 0)] } } function Nw (t, e, n) { const i = zw(t); return function (t, r) { return i.contain(r[0], r[1]) && !Iy(t, e, n) } } function zw (t) { return $M.create(t) } function Bw (t) { return t[0] > t[1] && t.reverse(), t } function Ew (t, e) { return Kr(t, e, { includeMainTypes: rV }) } function Vw (t, e, n, i) { const r = n.getAxis(['x', 'y'][t]); const o = Bw(v([0, 1], function (t) { return e ? r.coordToData(r.toLocalCoord(i[t]), !0) : r.toGlobalCoord(r.dataToCoord(i[t])) })); const a = []; return a[t] = o, a[1 - t] = [0 / 0, 0 / 0], { values: o, xyMinMax: a } } function Fw (t, e, n, i) { return [e[0] - i[t] * n[0], e[1] - i[t] * n[1]] } function Hw (t, e) { const n = Ww(t); const i = Ww(e); const r = [n[0] / i[0], n[1] / i[1]]; return isNaN(r[0]) && (r[0] = 1), isNaN(r[1]) && (r[1] = 1), r } function Ww (t) { return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [0 / 0, 0 / 0] } function Gw (t) { t.eachComponent({ mainType: 'brush' }, function (e) { const n = e.brushTargetManager = new oV(e.option, t); n.setInputRanges(e.areas, t) }) } function Xw (t, e, n) { let i; let r; const o = []; t.eachComponent({ mainType: 'brush' }, function (t) { n && n.type === 'takeGlobalCursor' && t.setBrushOption(n.key === 'brush' ? n.brushOption : { brushType: !1 }) }), Gw(t), t.eachComponent({ mainType: 'brush' }, function (e, n) { function a (t) { return f === 'all' || !!g[t] } function l (t) { return !!t.length } function u (t, e) { const n = t.coordinateSystem; x = x || n.hasAxisBrushed(), a(e) && n.eachActiveState(t.getData(), function (t, e) { t === 'active' && (m[e] = 1) }) } function h (n, i, r) { if (n.brushSelector && !jw(e, i) && (y(w, function (i) { e.brushTargetManager.controlSeries(i, n, t) && r.push(i), x = x || l(r) }), a(i) && l(r))) { const o = n.getData(); o.each(function (t) { Zw(n, r, o, t) && (m[t] = 1) }) } } const p = { brushId: e.id, brushIndex: n, brushName: e.name, areas: s(e.areas), selected: [] }; o.push(p); const d = e.option; var f = d.brushLink; var g = []; var m = []; const _ = []; var x = !1; n || (i = d.throttleType, r = d.throttleDelay); var w = v(e.areas, function (t) { const e = fV[t.brushType]; const n = c({ boundingRect: e ? e(t) : void 0 }, t); return n.selectors = Aw(n), n }); const b = Cw(e.option, cV, function (t) { t.mappingMethod = 'fixed' }); M(f) && y(f, function (t) { g[t] = 1 }), t.eachSeries(function (t, e) { const n = _[e] = []; t.subType === 'parallel' ? u(t, e) : h(t, e, n) }), t.eachSeries(function (t, e) { const n = { seriesId: t.id, seriesIndex: e, seriesName: t.name, dataIndex: [] }; p.selected.push(n); const i = _[e]; const r = t.getData(); const o = a(e) ? function (t) { return m[t] ? (n.dataIndex.push(r.getRawIndex(t)), 'inBrush') : 'outOfBrush' } : function (e) { return Zw(t, i, r, e) ? (n.dataIndex.push(r.getRawIndex(e)), 'inBrush') : 'outOfBrush' }; (a(e) ? x : l(i)) && kw(cV, b, r, o) }) }), Yw(e, i, r, o, n) } function Yw (t, e, n, i, r) { if (r) { const o = t.getZr(); if (!o[dV]) { o[pV] || (o[pV] = Uw); const a = cc(o, pV, n, e); a(t, i) } } } function Uw (t, e) { if (!t.isDisposed()) { const n = t.getZr(); n[dV] = !0, t.dispatchAction({ type: 'brushSelect', batch: e }), n[dV] = !1 } } function Zw (t, e, n, i) { for (let r = 0, o = e.length; o > r; r++) { const a = e[r]; if (t.brushSelector(i, n, a.selectors, a)) return !0 } } function jw (t, e) { const n = t.option.seriesIndex; return n != null && n !== 'all' && (M(n) ? p(n, e) < 0 : e !== n) } function qw (t) { return new $M(t[0][0], t[1][0], t[0][1] - t[0][0], t[1][1] - t[1][0]) } function Kw (t, e) { return l({ brushType: t.brushType, brushMode: t.brushMode, transformable: t.transformable, brushStyle: new Jk(t.brushStyle).getItemStyle(), removeOnClick: t.removeOnClick, z: t.z }, e, !0) } function $w (t, e) { _V[t] = e } function Qw (t) { return _V[t] } function Jw (t) { t.registerComponentView(gV), t.registerComponentModel(vV), t.registerPreprocessor(Px), t.registerVisual(t.PRIORITY.VISUAL.BRUSH, Xw), t.registerAction({ type: 'brush', event: 'brush', update: 'updateVisual' }, function (t, e) { e.eachComponent({ mainType: 'brush', query: t }, function (e) { e.setAreas(t.areas) }) }), t.registerAction({ type: 'brushSelect', event: 'brushSelected', update: 'none' }, Q), t.registerAction({ type: 'brushEnd', event: 'brushEnd', update: 'none' }, Q), $w('brush', wV) } function tb (t) { const e = t.get('coordinateSystem'); return p(SV, e) >= 0 } function eb (t) { return t + 'Axis' } function nb (t, e) { function n (t) { !l.get(t.uid) && r(t) && (i(t), u = !0) } function i (t) { l.set(t.uid, !0), s.push(t), o(t) } function r (t) { let e = !1; return t.eachTargetAxis(function (t, n) { const i = a.get(t); i && i[n] && (e = !0) }), e } function o (t) { t.eachTargetAxis(function (t, e) { (a.get(t) || a.set(t, []))[e] = !0 }) } var a = Z(); var s = []; var l = Z(); t.eachComponent({ mainType: 'dataZoom', query: e }, function (t) { l.get(t.uid) || i(t) }); let u; do u = !1, t.eachComponent('dataZoom', n); while (u); return s } function ib (t) { const e = {}; return y(['start', 'end', 'startValue', 'endValue', 'throttle'], function (n) { t.hasOwnProperty(n) && (e[n] = t[n]) }), e } function rb (t, e, n, i, r, o) { t = t || 0; const a = n[1] - n[0]; if (r != null && (r = ab(r, [0, a])), o != null && (o = Math.max(o, r != null ? r : 0)), i === 'all') { let s = Math.abs(e[1] - e[0]); s = ab(s, [0, a]), r = o = ab(s, [r, o]), i = 0 }e[0] = ab(e[0], n), e[1] = ab(e[1], n); const l = ob(e, i); e[i] += t; const u = r || 0; const h = n.slice(); l.sign < 0 ? h[0] += u : h[1] -= u, e[i] = ab(e[i], h); let c; return c = ob(e, i), r != null && (c.sign !== l.sign || c.span < r) && (e[1 - i] = e[i] + l.sign * r), c = ob(e, i), o != null && c.span > o && (e[1 - i] = e[i] + c.sign * o), e } function ob (t, e) { const n = t[e] - t[1 - e]; return { span: Math.abs(n), sign: n > 0 ? -1 : n < 0 ? 1 : e ? -1 : 1 } } function ab (t, e) { return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, t)) } function sb (t, e, n) { const i = [1 / 0, -1 / 0]; kV(n, function (t) { uf(i, t.getData(), e) }); const r = t.getAxisModel(); const o = jd(r.axis.scale, r, i).calculate(); return [o.min, o.max] } function lb (t) { t.registerAction('dataZoom', function (t, e) { const n = nb(e, t); y(n, function (e) { e.setRawRange({ start: t.start, end: t.end, startValue: t.startValue, endValue: t.endValue }) }) }) } function ub (t) { OV || (OV = !0, t.registerProcessor(t.PRIORITY.PROCESSOR.FILTER, PV), lb(t), t.registerSubTypeDefaulter('dataZoom', function () { return 'slider' })) } function hb (t) { t.registerComponentModel(IV), t.registerComponentView(DV), ub(t) } function cb (t) { return t.indexOf('my') === 0 } function pb (t) { const e = {}; const n = []; const i = []; return t.eachRawSeries(function (t) { const r = t.coordinateSystem; if (!r || r.type !== 'cartesian2d' && r.type !== 'polar')n.push(t); else { const o = r.getBaseAxis(); if (o.type === 'category') { const a = o.dim + '_' + o.index; e[a] || (e[a] = { categoryAxis: o, valueAxis: r.getOtherAxis(o), series: [] }, i.push({ axisDim: o.dim, axisIndex: o.index })), e[a].series.push(t) } else n.push(t) } }), { seriesGroupByCategoryAxis: e, other: n, meta: i } } function db (t) { const e = []; return y(t, function (t) { const n = t.categoryAxis; const i = t.valueAxis; const r = i.dim; const o = [' '].concat(v(t.series, function (t) { return t.name })); const a = [n.model.getCategories()]; y(t.series, function (t) { const e = t.getRawData(); a.push(t.getRawData().mapArray(e.mapDimension(r), function (t) { return t })) }); for (var s = [o.join(WV)], l = 0; l < a[0].length; l++) { for (var u = [], h = 0; h < a.length; h++)u.push(a[h][l]); s.push(u.join(WV)) }e.push(s.join('\n')) }), e.join('\n\n' + HV + '\n\n') } function fb (t) { return v(t, function (t) { const e = t.getRawData(); const n = [t.name]; const i = []; return e.each(e.dimensions, function () { for (var t = arguments.length, r = arguments[t - 1], o = e.getName(r), a = 0; t - 1 > a; a++)i[a] = arguments[a]; n.push((o ? o + WV : '') + i.join(WV)) }), n.join('\n') }).join('\n\n' + HV + '\n\n') } function gb (t) { const e = pb(t); return { value: _([db(e.seriesGroupByCategoryAxis), fb(e.other)], function (t) { return !!t.replace(/[\n\t\s]/g, '') }).join('\n\n' + HV + '\n\n'), meta: e.meta } } function yb (t) { return t.replace(/^\s\s*/, '').replace(/\s\s*$/, '') } function vb (t) { const e = t.slice(0, t.indexOf('\n')); return e.indexOf(WV) >= 0 ? !0 : void 0 } function mb (t) { for (var e = t.split(/\n+/g), n = yb(e.shift()).split(GV), i = [], r = v(n, function (t) { return { name: t, data: [] } }), o = 0; o < e.length; o++) { const a = yb(e[o]).split(GV); i.push(a.shift()); for (let s = 0; s < a.length; s++)r[s] && (r[s].data[o] = a[s]) } return { series: r, categories: i } } function _b (t) { for (var e = t.split(/\n+/g), n = yb(e.shift()), i = [], r = 0; r < e.length; r++) { const o = yb(e[r]); if (o) { let a = o.split(GV); let s = ''; let l = void 0; let u = !1; isNaN(a[0]) ? (u = !0, s = a[0], a = a.slice(1), i[r] = { name: s, value: [] }, l = i[r].value) : l = i[r] = []; for (let h = 0; h < a.length; h++)l.push(+a[h]); l.length === 1 && (u ? i[r].value = l[0] : i[r] = l[0]) } } return { name: n, data: i } } function xb (t, e) { const n = t.split(new RegExp('\n*' + HV + '\n*', 'g')); const i = { series: [] }; return y(n, function (t, n) { if (vb(t)) { var r = mb(t); const o = e[n]; const a = o.axisDim + 'Axis'; o && (i[a] = i[a] || [], i[a][o.axisIndex] = { data: r.categories }, i.series = i.series.concat(r.series)) } else { var r = _b(t); i.series.push(r) } }), i } function wb (t, e) { return v(t, function (t, n) { const i = e && e[n]; if (k(i) && !M(i)) { const r = k(t) && !M(t); r || (t = { value: t }); const o = i.name != null && t.name == null; return t = c(t, i), o && delete t.name, t } return t }) } function bb (t, e) { const n = Ib(t); YV(e, function (e, i) { for (var r = n.length - 1; r >= 0; r--) { const o = n[r]; if (o[i]) break } if (r < 0) { const a = t.queryComponents({ mainType: 'dataZoom', subType: 'select', id: i })[0]; if (a) { const s = a.getPercentRange(); n[0][i] = { dataZoomId: i, start: s[0], end: s[1] } } } }), n.push(e) } function Sb (t) { const e = Ib(t); const n = e[e.length - 1]; e.length > 1 && e.pop(); const i = {}; return YV(n, function (t, n) { for (let r = e.length - 1; r >= 0; r--) if (t = e[r][n]) { i[n] = t; break } }), i } function Mb (t) { UV(t).snapshots = null } function Tb (t) { return Ib(t).length } function Ib (t) { const e = UV(t); return e.snapshots || (e.snapshots = [{}]), e.snapshots } function Cb (t) { const e = { xAxisIndex: t.get('xAxisIndex', !0), yAxisIndex: t.get('yAxisIndex', !0), xAxisId: t.get('xAxisId', !0), yAxisId: t.get('yAxisId', !0) }; return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = 'all'), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = 'all'), e } function Db (t, e) { t.setIconStatus('back', Tb(e) > 1 ? 'emphasis' : 'normal') } function kb (t, e, n, i, r) { let o = n._isZoomActive; i && i.type === 'takeGlobalCursor' && (o = i.key === 'dataZoomSelect' ? i.dataZoomSelectActive : !1), n._isZoomActive = o, t.setIconStatus('zoom', o ? 'emphasis' : 'normal'); const a = new oV(Cb(t), e, { include: ['grid'] }); const s = a.makePanelOpts(r, function (t) { return t.xAxisDeclared && !t.yAxisDeclared ? 'lineX' : !t.xAxisDeclared && t.yAxisDeclared ? 'lineY' : 'rect' }); n._brushController.setPanels(s).enableBrush(o && s.length ? { brushType: 'auto', brushStyle: t.getModel('brushStyle').getItemStyle() } : !1) } function Ab (t) { t.registerComponentModel(RV), t.registerComponentView(NV), $w('saveAsImage', zV), $w('magicType', VV), $w('dataView', XV), $w('dataZoom', KV), $w('restore', ZV), ff(hb) } function Lb (t, e) { const n = t.existing; if (e.id = t.keyInfo.id, !e.type && n && (e.type = n.type), e.parentId == null) { const i = e.parentOption; i ? e.parentId = i.id : n && (e.parentId = n.parentId) }e.parentOption = null } function Pb (t, e) { let n; return y(e, function (e) { t[e] != null && t[e] !== 'auto' && (n = !0) }), n } function Ob (t, e, n) { const i = h({}, n); const r = t[e]; const o = n.$action || 'merge'; o === 'merge' ? r ? (l(r, i, !0), lu(r, i, { ignoreSize: !0 }), hu(n, r), Rb(n, r), Rb(n, r, 'shape'), Rb(n, r, 'style'), Rb(n, r, 'extra'), n.clipPath = r.clipPath) : t[e] = i : o === 'replace' ? t[e] = i : o === 'remove' && r && (t[e] = null) } function Rb (t, e, n) { if (n && (!t[n] && e[n] && (t[n] = {}), t = t[n], e = e[n]), t && e) for (let i = n ? QV : JV, r = 0; r < i.length; r++) { const o = i[r]; t[o] == null && e[o] != null && (t[o] = e[o]) } } function Nb (t, e) { if (t && (t.hv = e.hv = [Pb(e, ['left', 'right']), Pb(e, ['top', 'bottom'])], t.type === 'group')) { const n = t; const i = e; n.width == null && (n.width = i.width = 0), n.height == null && (n.height = i.height = 0) } } function zb (t) { const e = $(eF, t) ? eF[t] : zs(t); const n = new e({}); return nF(n).type = t, n } function Bb (t, e, n, i) { const r = zb(n); return e.add(r), i.set(t, r), nF(r).id = t, nF(r).isNew = !0, r } function Eb (t, e, n, i) { const r = t && t.parent; r && (t.type === 'group' && t.traverse(function (t) { Eb(t, e, n, i) }), em(t, e, i), n.removeKey(nF(t).id)) } function Vb (t, e, n, i) { t.isGroup || y([['cursor', sC.prototype.cursor], ['zlevel', i || 0], ['z', n || 0], ['z2', 0]], function (n) { const i = n[0]; $(e, i) ? t[i] = E(e[i], n[1]) : t[i] == null && (t[i] = n[1]) }), y(w(e), function (n) { if (n.indexOf('on') === 0) { const i = e[n]; t[n] = T(i) ? i : null } }), $(e, 'draggable') && (t.draggable = e.draggable), e.name != null && (t.name = e.name), e.id != null && (t.id = e.id) } function Fb (t) { return t = h({}, t), y(['id', 'parentId', '$action', 'hv', 'bounding', 'textContent', 'clipPath'].concat(SA), function (e) { delete t[e] }), t } function Hb (t, e, n) {
    let i = hD(t).eventData; t.silent || t.ignore || i || (i = hD(t).eventData = { componentType: 'graphic', componentIndex: e.componentIndex, name: t.name }), i && (i.info = n.info)
  } function Wb (t) { t.registerComponentModel(tF), t.registerComponentView(iF), t.registerPreprocessor(function (t) { const e = t.graphic; M(e) ? t.graphic = e[0] && e[0].elements ? [t.graphic[0]] : [{ elements: e }] : e && !e.elements && (t.graphic = [{ elements: [e] }]) }) } function Gb (t) { const e = t.fill; return e != null && e !== hF } function Xb (t) { const e = t.stroke; return e != null && e !== hF } function Yb (t, e, n, i) { const r = e.opacity == null ? 1 : e.opacity; if (n instanceof QC) return void t('opacity', r); if (Gb(e)) { const o = jn(e.fill); t('fill', o.color); const a = e.fillOpacity != null ? e.fillOpacity * o.opacity * r : o.opacity * r; (i || a < 1) && t('fill-opacity', a) } else t('fill', hF); if (Xb(e)) { const s = jn(e.stroke); t('stroke', s.color); const l = e.strokeNoScale ? n.getLineScale() : 1; const u = l ? (e.lineWidth || 0) / l : 0; const h = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * r : s.opacity * r; const c = e.strokeFirst; if ((i || u !== 1) && t('stroke-width', u), (i || c) && t('paint-order', c ? 'stroke' : 'fill'), (i || h < 1) && t('stroke-opacity', h), e.lineDash) { const p = Xc(n); const d = p[0]; let f = p[1]; d && (f = cF(f || 0), t('stroke-dasharray', d.join(',')), (f || i) && t('stroke-dashoffset', f)) } else i && t('stroke-dasharray', hF); for (let g = 0; g < pF.length; g++) { const y = pF[g]; if (i || e[y] !== XC[y]) { const v = e[y] || XC[y]; v && t(dF[g], v) } } } else i && t('stroke', hF) } function Ub (t) { return document.createElementNS(fF, t) } function Zb (t, e, n, i, r) { return { tag: t, attrs: n || {}, children: i, text: r, key: e } } function jb (t, e) { const n = []; if (e) for (const i in e) { const r = e[i]; let o = i; r !== !1 && (r !== !0 && r != null && (o += '="' + r + '"'), n.push(o)) } return '<' + t + ' ' + n.join(' ') + '>' } function qb (t) { return '</' + t + '>' } function Kb (t, e) { function n (t) { const e = t.children; const r = t.tag; const o = t.attrs; const a = t.text; return jb(r, o) + (r !== 'style' ? Ce(a) : a || '') + (e ? '' + i + v(e, function (t) { return n(t) }).join(i) + i : '') + qb(r) }e = e || {}; var i = e.newline ? '\n' : ''; return n(t) } function $b (t, e, n) { n = n || {}; const i = n.newline ? '\n' : ''; const r = ' {' + i; const o = i + '}'; const a = v(w(t), function (e) { return e + r + v(w(t[e]), function (n) { return n + ':' + t[e][n] + ';' }).join(i) + o }).join(i); const s = v(w(e), function (t) { return '@keyframes ' + t + r + v(w(e[t]), function (n) { return n + r + v(w(e[t][n]), function (i) { let r = e[t][n][i]; return i === 'd' && (r = 'path("' + r + '")'), i + ':' + r + ';' }).join(i) + o }).join(i) + o }).join(i); return a || s ? ['<![CDATA[', a, s, ']]>'].join(i) : '' } function Qb (t) { return { zrId: t, shadowCache: {}, patternCache: {}, gradientCache: {}, clipPathCache: {}, defs: {}, cssNodes: {}, cssAnims: {}, cssClassIdx: 0, cssAnimIdx: 0, shadowIdx: 0, gradientIdx: 0, patternIdx: 0, clipPathIdx: 0 } } function Jb (t, e, n, i) { return Zb('svg', 'root', { width: t, height: e, xmlns: fF, 'xmlns:xlink': gF, version: '1.1', baseProfile: 'full', viewBox: i ? '0 0 ' + t + ' ' + e : !1 }, n) } function tS (t, e, n) { const i = h({}, t.shape); h(i, e), t.buildPath(n, i); const r = new uF(); return r.reset(ui(t)), n.rebuildPath(r, 1), r.generateStr(), r.getStr() } function eS (t, e) { const n = e.originX; const i = e.originY; (n || i) && (t[_F] = n + 'px ' + i + 'px') } function nS (t, e) { const n = e.zrId + '-ani-' + e.cssAnimIdx++; return e.cssAnims[n] = t, n } function iS (t, e, n) { let i; let r; const o = t.shape.paths; const a = {}; if (y(o, function (t) { const e = Qb(n.zrId); e.animation = !0, oS(t, {}, e, !0); const o = e.cssAnims; const s = e.cssNodes; const l = w(o); const u = l.length; if (u) { r = l[u - 1]; const h = o[r]; for (const c in h) { const p = h[c]; a[c] = a[c] || { d: '' }, a[c].d += p.d || '' } for (const d in s) { const f = s[d].animation; f.indexOf(r) >= 0 && (i = f) } } }), i) { e.d = !1; const s = nS(a, n); return i.replace(r, s) } } function rS (t) { return I(t) ? mF[t] ? 'cubic-bezier(' + mF[t] + ')' : Tn(t) ? t : '' : '' } function oS (t, e, n, i) { function r (r) { function o (t, e, n) { for (let i = t.getTracks(), r = t.getMaxTime(), o = 0; o < i.length; o++) { const a = i[o]; if (a.needsAnimate()) { const s = a.keyframes; let l = a.propName; if (n && (l = n(l)), l) for (let u = 0; u < s.length; u++) { const h = s[u]; const c = Math.round(h.time / r * 100) + '%'; const d = rS(h.easing); const f = h.rawValue; (I(f) || D(f)) && (e[c] = e[c] || {}, e[c][l] = h.rawValue, d && (e[c][p] = d)) } } } } for (var a = r[1], s = a.length, l = {}, u = {}, c = {}, p = 'animation-timing-function', d = 0; s > d; d++) { var f = a[d]; var g = f.targetName; g ? g === 'shape' && o(f, u) : !i && o(f, l) } for (var y in l) { const v = {}; Ri(v, t), h(v, l[y]); const m = hi(v); var x = l[y][p]; c[y] = m ? { transform: m } : {}, eS(c[y], v), x && (c[y][p] = x) } let b; let S = !0; for (var y in u) { c[y] = c[y] || {}; const M = !b; var x = u[y][p]; M && (b = new zC()); const T = b.len(); b.reset(), c[y].d = tS(t, u[y], b); const C = b.len(); if (!M && T !== C) { S = !1; break }x && (c[y][p] = x) } if (!S) for (var y in c) delete c[y].d; if (!i) for (var d = 0; s > d; d++) { var f = a[d]; var g = f.targetName; g === 'style' && o(f, c, function (t) { return xF[t] }) } for (var k, A = w(c), L = !0, d = 1; d < A.length; d++) { const P = A[d - 1]; const O = A[d]; if (c[P][_F] !== c[O][_F]) { L = !1; break }k = c[P][_F] } if (L && k) { for (var y in c)c[y][_F] && delete c[y][_F]; e[_F] = k } if (_(A, function (t) { return w(c[t]).length > 0 }).length) { const R = nS(c, n); return R + ' ' + r[0] + ' both' } } const o = t.animators; const a = o.length; const s = []; if (t instanceof _k) { var l = iS(t, e, n); if (l)s.push(l); else if (!a) return } else if (!a) return; for (var u = {}, c = 0; a > c; c++) { const p = o[c]; const d = [p.getMaxTime() / 1e3 + 's']; const f = rS(p.getClip().easing); const g = p.getDelay(); d.push(f || 'linear'), g && d.push(g / 1e3 + 's'), p.getLoop() && d.push('infinite'); const y = d.join(' '); u[y] = u[y] || [y, []], u[y][1].push(p) } for (const v in u) { var l = r(u[v]); l && s.push(l) } if (s.length) { const m = n.zrId + '-cls-' + n.cssClassIdx++; n.cssNodes['.' + m] = { animation: s.join(',') }, e.class = m } } function aS (t) { return t && I(t.src) } function sS (t) { return t && T(t.toDataURL) } function lS (t, e, n, i) { Yb(function (r, o) { const a = r === 'fill' || r === 'stroke'; a && si(o) ? wS(e, t, r, i) : a && ri(o) ? bS(n, t, r, i) : t[r] = o }, e, n, !1), xS(n, t, i) } function uS (t) { return qn(t[0] - 1) && qn(t[1]) && qn(t[2]) && qn(t[3] - 1) } function hS (t) { return qn(t[4]) && qn(t[5]) } function cS (t, e, n) { if (e && (!hS(e) || !uS(e))) { const i = n ? 10 : 1e4; t.transform = uS(e) ? 'translate(' + wF(e[4] * i) / i + ' ' + wF(e[5] * i) / i + ')' : Qn(e) } } function pS (t, e, n) { for (var i = t.points, r = [], o = 0; o < i.length; o++)r.push(wF(i[o][0] * n) / n), r.push(wF(i[o][1] * n) / n); e.points = r.join(' ') } function dS (t) { return !t.smooth } function fS (t) { const e = v(t, function (t) { return typeof t === 'string' ? [t, t] : t }); return function (t, n, i) { for (let r = 0; r < e.length; r++) { const o = e[r]; const a = t[o[0]]; a != null && (n[o[1]] = wF(a * i) / i) } } } function gS (t) { for (let e = t.animators, n = 0; n < e.length; n++) if (e[n].targetName === 'shape') return !0; return !1 } function yS (t, e) { const n = t.style; const i = t.shape; const r = bF[t.type]; const o = {}; const a = e.animation; let s = 'path'; const l = t.style.strokePercent; const u = e.compress && ui(t) || 4; if (!r || e.willUpdate || r[1] && !r[1](i) || a && gS(t) || l < 1) { const h = !t.path || t.shapeChanged(); t.path || t.createPathProxy(); const c = t.path; h && (c.beginPath(), t.buildPath(c, t.shape), t.pathUpdated()); const p = c.getVersion(); const d = t; let f = d.__svgPathBuilder; d.__svgPathVersion === p && f && l === d.__svgPathStrokePercent || (f || (f = d.__svgPathBuilder = new uF()), f.reset(u), c.rebuildPath(f, l), f.generateStr(), d.__svgPathVersion = p, d.__svgPathStrokePercent = l), o.d = f.getStr() } else { s = t.type; const g = Math.pow(10, u); r[0](i, o, g) } return cS(o, t.transform), lS(o, n, t, e), e.animation && oS(t, o, e), Zb(s, t.id + '', o) } function vS (t, e) { const n = t.style; let i = n.image; if (i && !I(i) && (aS(i) ? i = i.src : sS(i) && (i = i.toDataURL())), i) { const r = n.x || 0; const o = n.y || 0; const a = n.width; const s = n.height; const l = { href: i, width: a, height: s }; return r && (l.x = r), o && (l.y = o), cS(l, t.transform), lS(l, n, t, e), e.animation && oS(t, l, e), Zb('image', t.id + '', l) } } function mS (t, e) { const n = t.style; let i = n.text; if (i != null && (i += ''), i && !isNaN(n.x) && !isNaN(n.y)) { const r = n.font || KS; const o = n.x || 0; const a = Jn(n.y || 0, Fi(r), n.textBaseline); const s = zT[n.textAlign] || n.textAlign; const l = { 'dominant-baseline': 'central', 'text-anchor': s }; if (ra(n)) { let u = ''; const h = n.fontStyle; const c = na(n.fontSize); if (!parseFloat(c)) return; const p = n.fontFamily || qS; const d = n.fontWeight; u += 'font-size:' + c + ';font-family:' + p + ';', h && h !== 'normal' && (u += 'font-style:' + h + ';'), d && d !== 'normal' && (u += 'font-weight:' + d + ';'), l.style = u } else l.style = 'font: ' + r; return i.match(/\s/) && (l['xml:space'] = 'preserve'), o && (l.x = o), a && (l.y = a), cS(l, t.transform), lS(l, n, t, e), e.animation && oS(t, l, e), Zb('text', t.id + '', l, void 0, i) } } function _S (t, e) { return t instanceof ZC ? yS(t, e) : t instanceof QC ? vS(t, e) : t instanceof qC ? mS(t, e) : void 0 } function xS (t, e, n) { const i = t.style; if (ti(i)) { const r = ei(t); const o = n.shadowCache; let a = o[r]; if (!a) { const s = t.getGlobalScale(); const l = s[0]; const u = s[1]; if (!l || !u) return; const h = i.shadowOffsetX || 0; const c = i.shadowOffsetY || 0; const p = i.shadowBlur; const d = jn(i.shadowColor); const f = d.opacity; const g = d.color; const y = p / 2 / l; const v = p / 2 / u; const m = y + ' ' + v; a = n.zrId + '-s' + n.shadowIdx++, n.defs[a] = Zb('filter', a, { id: a, x: '-100%', y: '-100%', width: '300%', height: '300%' }, [Zb('feDropShadow', '', { dx: h / l, dy: c / u, stdDeviation: m, 'flood-color': g, 'flood-opacity': f })]), o[r] = a }e.filter = li(a) } } function wS (t, e, n, i) { let r; const o = t[n]; const a = { gradientUnits: o.global ? 'userSpaceOnUse' : 'objectBoundingBox' }; if (oi(o))r = 'linearGradient', a.x1 = o.x, a.y1 = o.y, a.x2 = o.x2, a.y2 = o.y2; else { if (!ai(o)) return; r = 'radialGradient', a.cx = E(o.x, 0.5), a.cy = E(o.y, 0.5), a.r = E(o.r, 0.5) } for (var s = o.colorStops, l = [], u = 0, h = s.length; h > u; ++u) { const c = 100 * $n(s[u].offset) + '%'; const p = s[u].color; const d = jn(p); const f = d.color; const g = d.opacity; const y = { offset: c }; y['stop-color'] = f, g < 1 && (y['stop-opacity'] = g), l.push(Zb('stop', u + '', y)) } const v = Zb(r, '', a, l); const m = Kb(v); const _ = i.gradientCache; let x = _[m]; x || (x = i.zrId + '-g' + i.gradientIdx++, _[m] = x, a.id = x, i.defs[x] = Zb(r, x, a, l)), e[n] = li(x) } function bS (t, e, n, i) { let r; const o = t.style[n]; const a = t.getBoundingRect(); const l = {}; const u = o.repeat; const h = u === 'no-repeat'; const c = u === 'repeat-x'; const p = u === 'repeat-y'; if (ni(o)) { let d = o.imageWidth; let f = o.imageHeight; let g = void 0; const y = o.image; if (I(y) ? g = y : aS(y) ? g = y.src : sS(y) && (g = y.toDataURL()), typeof Image === 'undefined') { const v = 'Image width/height must been given explictly in svg-ssr renderer.'; W(d, v), W(f, v) } else if (d == null || f == null) { const m = function (t, e) { if (t) { const n = t.elm; let i = d || e.width; let r = f || e.height; t.tag === 'pattern' && (c ? (r = 1, i /= a.width) : p && (i = 1, r /= a.height)), t.attrs.width = i, t.attrs.height = r, n && (n.setAttribute('width', i), n.setAttribute('height', r)) } }; const _ = yo(g, null, t, function (t) { h || m(S, t), m(r, t) }); _ && _.width && _.height && (d = d || _.width, f = f || _.height) }r = Zb('image', 'img', { href: g, width: d, height: f }), l.width = d, l.height = f } else o.svgElement && (r = s(o.svgElement), l.width = o.svgWidth, l.height = o.svgHeight); if (r) { let x, w; h ? x = w = 1 : c ? (w = 1, x = l.width / a.width) : p ? (x = 1, w = l.height / a.height) : l.patternUnits = 'userSpaceOnUse', x == null || isNaN(x) || (l.width = x), w == null || isNaN(w) || (l.height = w); const b = hi(o); b && (l.patternTransform = b); var S = Zb('pattern', '', l, [r]); const M = Kb(S); const T = i.patternCache; let C = T[M]; C || (C = i.zrId + '-p' + i.patternIdx++, T[M] = C, l.id = C, S = i.defs[C] = Zb('pattern', C, l, [r])), e[n] = li(C) } } function SS (t, e, n) { const i = n.clipPathCache; const r = n.defs; let o = i[t.id]; if (!o) { o = n.zrId + '-c' + n.clipPathIdx++; const a = { id: o }; i[t.id] = o, r[o] = Zb('clipPath', o, a, [yS(t, n)]) }e['clip-path'] = li(o) } function MS (t) { return document.createTextNode(t) } function TS (t, e, n) { t.insertBefore(e, n) } function IS (t, e) { t.removeChild(e) } function CS (t, e) { t.appendChild(e) } function DS (t) { return t.parentNode } function kS (t) { return t.nextSibling } function AS (t, e) { t.textContent = e } function LS (t) { return void 0 === t } function PS (t) { return void 0 !== t } function OS (t, e, n) { for (var i = {}, r = e; n >= r; ++r) { const o = t[r].key; void 0 !== o && (i[o] = r) } return i } function RS (t, e) { const n = t.key === e.key; const i = t.tag === e.tag; return i && n } function NS (t) { let e; const n = t.children; const i = t.tag; if (PS(i)) { const r = t.elm = Ub(i); if (ES(TF, t), M(n)) for (e = 0; e < n.length; ++e) { const o = n[e]; o != null && CS(r, NS(o)) } else PS(t.text) && !k(t.text) && CS(r, MS(t.text)) } else t.elm = MS(t.text); return t.elm } function zS (t, e, n, i, r) { for (;r >= i; ++i) { const o = n[i]; o != null && TS(t, NS(o), e) } } function BS (t, e, n, i) { for (;i >= n; ++n) { const r = e[n]; if (r != null) if (PS(r.tag)) { const o = DS(r.elm); IS(o, r.elm) } else IS(t, r.elm) } } function ES (t, e) { let n; const i = e.elm; const r = t && t.attrs || {}; const o = e.attrs || {}; if (r !== o) { for (n in o) { const a = o[n]; const s = r[n]; s !== a && (a === !0 ? i.setAttribute(n, '') : a === !1 ? i.removeAttribute(n) : n.charCodeAt(0) !== MF ? i.setAttribute(n, a) : n === 'xmlns:xlink' || n === 'xmlns' ? i.setAttributeNS(yF, n, a) : n.charCodeAt(3) === SF ? i.setAttributeNS(vF, n, a) : n.charCodeAt(5) === SF ? i.setAttributeNS(gF, n, a) : i.setAttribute(n, a)) } for (n in r)n in o || i.removeAttribute(n) } } function VS (t, e, n) { for (var i, r, o, a, s = 0, l = 0, u = e.length - 1, h = e[0], c = e[u], p = n.length - 1, d = n[0], f = n[p]; u >= s && p >= l;)h == null ? h = e[++s] : c == null ? c = e[--u] : d == null ? d = n[++l] : f == null ? f = n[--p] : RS(h, d) ? (FS(h, d), h = e[++s], d = n[++l]) : RS(c, f) ? (FS(c, f), c = e[--u], f = n[--p]) : RS(h, f) ? (FS(h, f), TS(t, h.elm, kS(c.elm)), h = e[++s], f = n[--p]) : RS(c, d) ? (FS(c, d), TS(t, c.elm, h.elm), c = e[--u], d = n[++l]) : (LS(i) && (i = OS(e, s, u)), r = i[d.key], LS(r) ? TS(t, NS(d), h.elm) : (o = e[r], o.tag !== d.tag ? TS(t, NS(d), h.elm) : (FS(o, d), e[r] = void 0, TS(t, o.elm, h.elm))), d = n[++l]); (u >= s || p >= l) && (s > u ? (a = n[p + 1] == null ? null : n[p + 1].elm, zS(t, a, n, l, p)) : BS(t, e, s, u)) } function FS (t, e) { const n = e.elm = t.elm; const i = t.children; const r = e.children; t !== e && (ES(t, e), LS(e.text) ? PS(i) && PS(r) ? i !== r && VS(n, i, r) : PS(r) ? (PS(t.text) && AS(n, ''), zS(n, null, r, 0, r.length - 1)) : PS(i) ? BS(n, i, 0, i.length - 1) : PS(t.text) && AS(n, '') : t.text !== e.text && (PS(i) && BS(n, i, 0, i.length - 1), AS(n, e.text))) } function HS (t, e) { if (RS(t, e))FS(t, e); else { const n = t.elm; const i = DS(n); NS(e), i !== null && (TS(i, e.elm, kS(n)), BS(i, [t], 0, 0)) } return e } function WS () { return function () {} } function GS (t, e, n, i) { let r; if (n && n !== 'none') if (r = Zb('rect', 'bg', { width: t, height: e, x: '0', y: '0', id: '0' }), si(n))wS({ fill: n }, r.attrs, 'fill', i); else if (ri(n))bS({ style: { fill: n }, dirty: Q, getBoundingRect: function () { return { width: t, height: e } } }, r.attrs, 'fill', i); else { const o = jn(n); const a = o.color; const s = o.opacity; r.attrs.fill = a, s < 1 && (r.attrs['fill-opacity'] = s) } return r } var XS = function (t, e) { return (XS = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, e) { t.__proto__ = e } || function (t, e) { for (const n in e)Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]) })(t, e) }; const YS = (function () { function t () { this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1 } return t }()); const US = (function () { function t () { this.browser = new YS(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window !== 'undefined' } return t }()); var ZS = new US(); typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function' ? (ZS.wxa = !0, ZS.touchEventsSupported = !0) : typeof document === 'undefined' && typeof self !== 'undefined' ? ZS.worker = !0 : typeof navigator === 'undefined' ? (ZS.node = !0, ZS.svgSupported = !0) : n(navigator.userAgent, ZS); var jS = 12; var qS = 'sans-serif'; var KS = jS + 'px ' + qS; var $S = 20; var QS = 100; const JS = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N"; const tM = i(JS); var eM = { createCanvas: function () { return typeof document !== 'undefined' && document.createElement('canvas') }, measureText: (function () { let t, e; return function (n, i) { if (!t) { const r = eM.createCanvas(); t = r && r.getContext('2d') } if (t) return e !== i && (e = t.font = i || KS), t.measureText(n); n = n || '', i = i || KS; const o = /(\d+)px/.exec(i); const a = o && +o[1] || jS; let s = 0; if (i.indexOf('mono') >= 0)s = a * n.length; else for (let l = 0; l < n.length; l++) { const u = tM[n[l]]; s += u == null ? a : u * a } return { width: s } } }()), loadImage: function (t, e, n) { const i = new Image(); return i.onload = e, i.onerror = n, i.src = t, i } }; var nM = m(['Function', 'RegExp', 'Date', 'Error', 'CanvasGradient', 'CanvasPattern', 'Image', 'Canvas'], function (t, e) { return t['[object ' + e + ']'] = !0, t }, {}); var iM = m(['Int8', 'Uint8', 'Uint8Clamped', 'Int16', 'Uint16', 'Int32', 'Uint32', 'Float32', 'Float64'], function (t, e) { return t['[object ' + e + 'Array]'] = !0, t }, {}); var rM = Object.prototype.toString; const oM = Array.prototype; var aM = oM.forEach; var sM = oM.filter; var lM = oM.slice; var uM = oM.map; const hM = function () {}.constructor; const cM = hM ? hM.prototype : null; var pM = '__proto__'; var dM = 2311; const fM = eM.createCanvas; var gM = cM && T(cM.bind) ? cM.call.bind(cM.bind) : b; var yM = '__ec_primitive__'; var vM = (function () { function t () { this.data = {} } return t.prototype.delete = function (t) { const e = this.has(t); return e && delete this.data[t], e }, t.prototype.has = function (t) { return this.data.hasOwnProperty(t) }, t.prototype.get = function (t) { return this.data[t] }, t.prototype.set = function (t, e) { return this.data[t] = e, this }, t.prototype.keys = function () { return w(this.data) }, t.prototype.forEach = function (t) { const e = this.data; for (const n in e)e.hasOwnProperty(n) && t(e[n], n) }, t }()); var mM = typeof Map === 'function'; var _M = (function () { function t (e) { function n (t, e) { i ? r.set(t, e) : r.set(e, t) } var i = M(e); this.data = U(); var r = this; e instanceof t ? e.each(n) : e && y(e, n) } return t.prototype.hasKey = function (t) { return this.data.has(t) }, t.prototype.get = function (t) { return this.data.get(t) }, t.prototype.set = function (t, e) { return this.data.set(t, e), e }, t.prototype.each = function (t, e) { this.data.forEach(function (n, i) { t.call(e, n, i) }) }, t.prototype.keys = function () { const t = this.data.keys(); return mM ? Array.from(t) : t }, t.prototype.removeKey = function (t) { this.data.delete(t) }, t }()); var xM = 180 / Math.PI; const wM = (Object.freeze || Object)({ guid: o, logError: a, clone: s, merge: l, mergeAll: u, extend: h, defaults: c, createCanvas: fM, indexOf: p, inherits: d, mixin: f, isArrayLike: g, each: y, map: v, reduce: m, filter: _, find: x, keys: w, bind: gM, curry: S, isArray: M, isFunction: T, isString: I, isStringSafe: C, isNumber: D, isObject: k, isBuiltInObject: A, isTypedArray: L, isDom: P, isGradientObject: O, isImagePatternObject: R, isRegExp: N, eqNaN: z, retrieve: B, retrieve2: E, retrieve3: V, slice: F, normalizeCssArray: H, assert: W, trim: G, setAsPrimitive: X, isPrimitive: Y, HashMap: _M, createHashMap: Z, concatArray: j, createObject: q, disableUserSelect: K, hasOwn: $, noop: Q, RADIAN_TO_DEGREE: xM }); const bM = ae; const SM = se; var MM = de; var TM = fe; const IM = (Object.freeze || Object)({ create: J, copy: te, clone: ee, set: ne, add: ie, scaleAndAdd: re, sub: oe, len: ae, length: bM, lenSquare: se, lengthSquare: SM, mul: le, div: ue, dot: he, scale: ce, normalize: pe, distance: de, dist: MM, distanceSquare: fe, distSquare: TM, negate: ge, lerp: ye, applyTransform: ve, min: me, max: _e }); const CM = (function () { function t (t, e) { this.target = t, this.topTarget = e && e.topTarget } return t }()); const DM = (function () { function t (t) { this.handler = t, t.on('mousedown', this._dragStart, this), t.on('mousemove', this._drag, this), t.on('mouseup', this._dragEnd, this) } return t.prototype._dragStart = function (t) { for (var e = t.target; e && !e.draggable;)e = e.parent || e.__hostTarget; e && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new CM(e, t), 'dragstart', t.event)) }, t.prototype._drag = function (t) { const e = this._draggingTarget; if (e) { const n = t.offsetX; const i = t.offsetY; const r = n - this._x; const o = i - this._y; this._x = n, this._y = i, e.drift(r, o, t), this.handler.dispatchToElement(new CM(e, t), 'drag', t.event); const a = this.handler.findHover(n, i, e).target; const s = this._dropTarget; this._dropTarget = a, e !== a && (s && a !== s && this.handler.dispatchToElement(new CM(s, t), 'dragleave', t.event), a && a !== s && this.handler.dispatchToElement(new CM(a, t), 'dragenter', t.event)) } }, t.prototype._dragEnd = function (t) { const e = this._draggingTarget; e && (e.dragging = !1), this.handler.dispatchToElement(new CM(e, t), 'dragend', t.event), this._dropTarget && this.handler.dispatchToElement(new CM(this._dropTarget, t), 'drop', t.event), this._draggingTarget = null, this._dropTarget = null }, t }()); var kM = (function () { function t (t) { t && (this._$eventProcessor = t) } return t.prototype.on = function (t, e, n, i) { this._$handlers || (this._$handlers = {}); const r = this._$handlers; if (typeof e === 'function' && (i = n, n = e, e = null), !n || !t) return this; const o = this._$eventProcessor; e != null && o && o.normalizeQuery && (e = o.normalizeQuery(e)), r[t] || (r[t] = []); for (let a = 0; a < r[t].length; a++) if (r[t][a].h === n) return this; const s = { h: n, query: e, ctx: i || this, callAtLast: n.zrEventfulCallAtLast }; const l = r[t].length - 1; const u = r[t][l]; return u && u.callAtLast ? r[t].splice(l, 0, s) : r[t].push(s), this }, t.prototype.isSilent = function (t) { const e = this._$handlers; return !e || !e[t] || !e[t].length }, t.prototype.off = function (t, e) { const n = this._$handlers; if (!n) return this; if (!t) return this._$handlers = {}, this; if (e) { if (n[t]) { for (var i = [], r = 0, o = n[t].length; o > r; r++)n[t][r].h !== e && i.push(n[t][r]); n[t] = i }n[t] && n[t].length === 0 && delete n[t] } else delete n[t]; return this }, t.prototype.trigger = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; if (!this._$handlers) return this; const i = this._$handlers[t]; const r = this._$eventProcessor; if (i) for (let o = e.length, a = i.length, s = 0; a > s; s++) { const l = i[s]; if (!r || !r.filter || l.query == null || r.filter(t, l.query)) switch (o) { case 0:l.h.call(l.ctx); break; case 1:l.h.call(l.ctx, e[0]); break; case 2:l.h.call(l.ctx, e[0], e[1]); break; default:l.h.apply(l.ctx, e) } } return r && r.afterTrigger && r.afterTrigger(t), this }, t.prototype.triggerWithContext = function (t) { for (var e = [], n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; if (!this._$handlers) return this; const i = this._$handlers[t]; const r = this._$eventProcessor; if (i) for (let o = e.length, a = e[o - 1], s = i.length, l = 0; s > l; l++) { const u = i[l]; if (!r || !r.filter || u.query == null || r.filter(t, u.query)) switch (o) { case 0:u.h.call(a); break; case 1:u.h.call(a, e[0]); break; case 2:u.h.call(a, e[0], e[1]); break; default:u.h.apply(a, e.slice(1, o - 1)) } } return r && r.afterTrigger && r.afterTrigger(t), this }, t }()); var AM = Math.log(2); var LM = '___zrEVENTSAVED'; var PM = []; var OM = /([&<>"'])/g; var RM = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }; var NM = /^(?:mouse|pointer|contextmenu|drag|drop)|click/; var zM = []; var BM = ZS.browser.firefox && +ZS.browser.version.split('.')[0] < 39; var EM = function (t) { t.preventDefault(), t.stopPropagation(), t.cancelBubble = !0 }; const VM = (function () { function t () { this._track = [] } return t.prototype.recognize = function (t, e, n) { return this._doTrack(t, e, n), this._recognize(t) }, t.prototype.clear = function () { return this._track.length = 0, this }, t.prototype._doTrack = function (t, e, n) { const i = t.touches; if (i) { for (var r = { points: [], touches: [], target: e, event: t }, o = 0, a = i.length; a > o; o++) { const s = i[o]; const l = De(n, s, {}); r.points.push([l.zrX, l.zrY]), r.touches.push(s) } this._track.push(r) } }, t.prototype._recognize = function (t) { for (const e in FM) if (FM.hasOwnProperty(e)) { const n = FM[e](this._track, t); if (n) return n } }, t }()); var FM = { pinch: function (t, e) { const n = t.length; if (n) { const i = (t[n - 1] || {}).points; const r = (t[n - 2] || {}).points || i; if (r && r.length > 1 && i && i.length > 1) { let o = ze(i) / ze(r); !isFinite(o) && (o = 1), e.pinchScale = o; const a = Be(i); return e.pinchX = a[0], e.pinchY = a[1], { type: 'pinch', target: t[0].target, event: e } } } } }; const HM = (Object.freeze || Object)({ create: Ee, identity: Ve, copy: Fe, mul: He, translate: We, rotate: Ge, scale: Xe, invert: Ye, clone: Ue }); var WM = (function () { function t (t, e) { this.x = t || 0, this.y = e || 0 } return t.prototype.copy = function (t) { return this.x = t.x, this.y = t.y, this }, t.prototype.clone = function () { return new t(this.x, this.y) }, t.prototype.set = function (t, e) { return this.x = t, this.y = e, this }, t.prototype.equal = function (t) { return t.x === this.x && t.y === this.y }, t.prototype.add = function (t) { return this.x += t.x, this.y += t.y, this }, t.prototype.scale = function (t) { this.x *= t, this.y *= t }, t.prototype.scaleAndAdd = function (t, e) { this.x += t.x * e, this.y += t.y * e }, t.prototype.sub = function (t) { return this.x -= t.x, this.y -= t.y, this }, t.prototype.dot = function (t) { return this.x * t.x + this.y * t.y }, t.prototype.len = function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, t.prototype.lenSquare = function () { return this.x * this.x + this.y * this.y }, t.prototype.normalize = function () { const t = this.len(); return this.x /= t, this.y /= t, this }, t.prototype.distance = function (t) { const e = this.x - t.x; const n = this.y - t.y; return Math.sqrt(e * e + n * n) }, t.prototype.distanceSquare = function (t) { const e = this.x - t.x; const n = this.y - t.y; return e * e + n * n }, t.prototype.negate = function () { return this.x = -this.x, this.y = -this.y, this }, t.prototype.transform = function (t) { if (t) { const e = this.x; const n = this.y; return this.x = t[0] * e + t[2] * n + t[4], this.y = t[1] * e + t[3] * n + t[5], this } }, t.prototype.toArray = function (t) { return t[0] = this.x, t[1] = this.y, t }, t.prototype.fromArray = function (t) { this.x = t[0], this.y = t[1] }, t.set = function (t, e, n) { t.x = e, t.y = n }, t.copy = function (t, e) { t.x = e.x, t.y = e.y }, t.len = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y) }, t.lenSquare = function (t) { return t.x * t.x + t.y * t.y }, t.dot = function (t, e) { return t.x * e.x + t.y * e.y }, t.add = function (t, e, n) { t.x = e.x + n.x, t.y = e.y + n.y }, t.sub = function (t, e, n) { t.x = e.x - n.x, t.y = e.y - n.y }, t.scale = function (t, e, n) { t.x = e.x * n, t.y = e.y * n }, t.scaleAndAdd = function (t, e, n, i) { t.x = e.x + n.x * i, t.y = e.y + n.y * i }, t.lerp = function (t, e, n, i) { const r = 1 - i; t.x = r * e.x + i * n.x, t.y = r * e.y + i * n.y }, t }()); const GM = Math.min; const XM = Math.max; const YM = new WM(); const UM = new WM(); const ZM = new WM(); const jM = new WM(); const qM = new WM(); const KM = new WM(); var $M = (function () { function t (t, e, n, i) { n < 0 && (t += n, n = -n), i < 0 && (e += i, i = -i), this.x = t, this.y = e, this.width = n, this.height = i } return t.prototype.union = function (t) { const e = GM(t.x, this.x); const n = GM(t.y, this.y); this.width = isFinite(this.x) && isFinite(this.width) ? XM(t.x + t.width, this.x + this.width) - e : t.width, this.height = isFinite(this.y) && isFinite(this.height) ? XM(t.y + t.height, this.y + this.height) - n : t.height, this.x = e, this.y = n }, t.prototype.applyTransform = function (e) { t.applyTransform(this, this, e) }, t.prototype.calculateTransform = function (t) { const e = this; const n = t.width / e.width; const i = t.height / e.height; const r = Ee(); return We(r, r, [-e.x, -e.y]), Xe(r, r, [n, i]), We(r, r, [t.x, t.y]), r }, t.prototype.intersect = function (e, n) { if (!e) return !1; e instanceof t || (e = t.create(e)); const i = this; const r = i.x; const o = i.x + i.width; const a = i.y; const s = i.y + i.height; const l = e.x; const u = e.x + e.width; const h = e.y; const c = e.y + e.height; const p = !(l > o || r > u || h > s || a > c); if (n) { let d = 1 / 0; let f = 0; const g = Math.abs(o - l); const y = Math.abs(u - r); const v = Math.abs(s - h); const m = Math.abs(c - a); const _ = Math.min(g, y); const x = Math.min(v, m); l > o || r > u ? _ > f && (f = _, y > g ? WM.set(KM, -g, 0) : WM.set(KM, y, 0)) : d > _ && (d = _, y > g ? WM.set(qM, g, 0) : WM.set(qM, -y, 0)), h > s || a > c ? x > f && (f = x, m > v ? WM.set(KM, 0, -v) : WM.set(KM, 0, m)) : d > _ && (d = _, m > v ? WM.set(qM, 0, v) : WM.set(qM, 0, -m)) } return n && WM.copy(n, p ? qM : KM), p }, t.prototype.contain = function (t, e) { const n = this; return t >= n.x && t <= n.x + n.width && e >= n.y && e <= n.y + n.height }, t.prototype.clone = function () { return new t(this.x, this.y, this.width, this.height) }, t.prototype.copy = function (e) { t.copy(this, e) }, t.prototype.plain = function () { return { x: this.x, y: this.y, width: this.width, height: this.height } }, t.prototype.isFinite = function () { return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height) }, t.prototype.isZero = function () { return this.width === 0 || this.height === 0 }, t.create = function (e) { return new t(e.x, e.y, e.width, e.height) }, t.copy = function (t, e) { t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height }, t.applyTransform = function (e, n, i) { if (!i) return void (e !== n && t.copy(e, n)); if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) { const r = i[0]; const o = i[3]; const a = i[4]; const s = i[5]; return e.x = n.x * r + a, e.y = n.y * o + s, e.width = n.width * r, e.height = n.height * o, e.width < 0 && (e.x += e.width, e.width = -e.width), void (e.height < 0 && (e.y += e.height, e.height = -e.height)) }YM.x = ZM.x = n.x, YM.y = jM.y = n.y, UM.x = jM.x = n.x + n.width, UM.y = ZM.y = n.y + n.height, YM.transform(i), jM.transform(i), UM.transform(i), ZM.transform(i), e.x = GM(YM.x, UM.x, ZM.x, jM.x), e.y = GM(YM.y, UM.y, ZM.y, jM.y); const l = XM(YM.x, UM.x, ZM.x, jM.x); const u = XM(YM.y, UM.y, ZM.y, jM.y); e.width = l - e.x, e.height = u - e.y }, t }()); var QM = 'silent'; const JM = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.handler = null, e } return e(n, t), n.prototype.dispose = function () {}, n.prototype.setCursor = function () {}, n }(kM)); const tT = (function () { function t (t, e) { this.x = t, this.y = e } return t }()); const eT = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu']; const nT = new $M(0, 0, 0, 0); const iT = (function (t) { function n (e, n, i, r, o) { const a = t.call(this) || this; return a._hovered = new tT(0, 0), a.storage = e, a.painter = n, a.painterRoot = r, a._pointerSize = o, i = i || new JM(), a.proxy = null, a.setHandlerProxy(i), a._draggingMgr = new DM(a), a } return e(n, t), n.prototype.setHandlerProxy = function (t) { this.proxy && this.proxy.dispose(), t && (y(eT, function (e) { t.on && t.on(e, this[e], this) }, this), t.handler = this), this.proxy = t }, n.prototype.mousemove = function (t) { const e = t.zrX; const n = t.zrY; const i = $e(this, e, n); let r = this._hovered; let o = r.target; o && !o.__zr && (r = this.findHover(r.x, r.y), o = r.target); const a = this._hovered = i ? new tT(e, n) : this.findHover(e, n); const s = a.target; const l = this.proxy; l.setCursor && l.setCursor(s ? s.cursor : 'default'), o && s !== o && this.dispatchToElement(r, 'mouseout', t), this.dispatchToElement(a, 'mousemove', t), s && s !== o && this.dispatchToElement(a, 'mouseover', t) }, n.prototype.mouseout = function (t) { const e = t.zrEventControl; e !== 'only_globalout' && this.dispatchToElement(this._hovered, 'mouseout', t), e !== 'no_globalout' && this.trigger('globalout', { type: 'globalout', event: t }) }, n.prototype.resize = function () { this._hovered = new tT(0, 0) }, n.prototype.dispatch = function (t, e) { const n = this[t]; n && n.call(this, e) }, n.prototype.dispose = function () { this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null }, n.prototype.setCursorStyle = function (t) { const e = this.proxy; e.setCursor && e.setCursor(t) }, n.prototype.dispatchToElement = function (t, e, n) { t = t || {}; let i = t.target; if (!i || !i.silent) { for (var r = 'on' + e, o = Ze(e, t, n); i && (i[r] && (o.cancelBubble = !!i[r].call(i, o)), i.trigger(e, o), i = i.__hostTarget ? i.__hostTarget : i.parent, !o.cancelBubble););o.cancelBubble || (this.trigger(e, o), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function (t) { typeof t[r] === 'function' && t[r].call(t, o), t.trigger && t.trigger(e, o) })) } }, n.prototype.findHover = function (t, e, n) { const i = this.storage.getDisplayList(); const r = new tT(t, e); if (Ke(i, r, t, e, n), this._pointerSize && !r.target) { for (var o = [], a = this._pointerSize, s = a / 2, l = new $M(t - s, e - s, a, a), u = i.length - 1; u >= 0; u--) { const h = i[u]; h === n || h.ignore || h.ignoreCoarsePointer || h.parent && h.parent.ignoreCoarsePointer || (nT.copy(h.getBoundingRect()), h.transform && nT.applyTransform(h.transform), nT.intersect(l) && o.push(h)) } if (o.length) for (let c = 4, p = Math.PI / 12, d = 2 * Math.PI, f = 0; s > f; f += c) for (let g = 0; d > g; g += p) { const y = t + f * Math.cos(g); const v = e + f * Math.sin(g); if (Ke(o, r, y, v, n), r.target) return r } } return r }, n.prototype.processGesture = function (t, e) { this._gestureMgr || (this._gestureMgr = new VM()); const n = this._gestureMgr; e === 'start' && n.clear(); const i = n.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom); if (e === 'end' && n.clear(), i) { const r = i.type; t.gestureEvent = r; const o = new tT(); o.target = i.target, this.dispatchToElement(o, r, i.event) } }, n }(kM)); y(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (t) { iT.prototype[t] = function (e) { let n; let i; const r = e.zrX; const o = e.zrY; const a = $e(this, r, o); if (t === 'mouseup' && a || (n = this.findHover(r, o), i = n.target), t === 'mousedown') this._downEl = i, this._downPoint = [e.zrX, e.zrY], this._upEl = i; else if (t === 'mouseup') this._upEl = i; else if (t === 'click') { if (this._downEl !== this._upEl || !this._downPoint || MM(this._downPoint, [e.zrX, e.zrY]) > 4) return; this._downPoint = null } this.dispatchToElement(n, t, e) } }); let rT; var oT = 32; var aT = 7; var sT = 1; const lT = 2; var uT = 4; var hT = !1; const cT = (function () { function t () { this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = ln } return t.prototype.traverse = function (t, e) { for (let n = 0; n < this._roots.length; n++) this._roots[n].traverse(t, e) }, t.prototype.getDisplayList = function (t, e) { e = e || !1; const n = this._displayList; return (t || !n.length) && this.updateDisplayList(e), n }, t.prototype.updateDisplayList = function (t) { this._displayListLen = 0; for (var e = this._roots, n = this._displayList, i = 0, r = e.length; r > i; i++) this._updateAndAddDisplayable(e[i], null, t); n.length = this._displayListLen, an(n, ln) }, t.prototype._updateAndAddDisplayable = function (t, e, n) { if (!t.ignore || n) { t.beforeUpdate(), t.update(), t.afterUpdate(); const i = t.getClipPath(); if (t.ignoreClip)e = null; else if (i) { e = e ? e.slice() : []; for (let r = i, o = t; r;)r.parent = o, r.updateTransform(), e.push(r), o = r, r = r.getClipPath() } if (t.childrenRef) { for (let a = t.childrenRef(), s = 0; s < a.length; s++) { const l = a[s]; t.__dirty && (l.__dirty |= sT), this._updateAndAddDisplayable(l, e, n) }t.__dirty = 0 } else { const u = t; e && e.length ? u.__clipPaths = e : u.__clipPaths && u.__clipPaths.length > 0 && (u.__clipPaths = []), isNaN(u.z) && (sn(), u.z = 0), isNaN(u.z2) && (sn(), u.z2 = 0), isNaN(u.zlevel) && (sn(), u.zlevel = 0), this._displayList[this._displayListLen++] = u } const h = t.getDecalElement && t.getDecalElement(); h && this._updateAndAddDisplayable(h, e, n); const c = t.getTextGuideLine(); c && this._updateAndAddDisplayable(c, e, n); const p = t.getTextContent(); p && this._updateAndAddDisplayable(p, e, n) } }, t.prototype.addRoot = function (t) { t.__zr && t.__zr.storage === this || this._roots.push(t) }, t.prototype.delRoot = function (t) { if (t instanceof Array) for (let e = 0, n = t.length; n > e; e++) this.delRoot(t[e]); else { const i = p(this._roots, t); i >= 0 && this._roots.splice(i, 1) } }, t.prototype.delAllRoots = function () { this._roots = [], this._displayList = [], this._displayListLen = 0 }, t.prototype.getRoots = function () { return this._roots }, t.prototype.dispose = function () { this._displayList = null, this._roots = null }, t }()); rT = ZS.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (t) { return setTimeout(t, 16) }; const pT = rT; var dT = {
    linear: function (t) { return t },
    quadraticIn: function (t) { return t * t },
    quadraticOut: function (t) { return t * (2 - t) },
    quadraticInOut: function (t) { return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1) },
    cubicIn: function (t) { return t * t * t },
    cubicOut: function (t) { return --t * t * t + 1 },
    cubicInOut: function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2) },
    quarticIn: function (t) { return t * t * t * t },
    quarticOut: function (t) { return 1 - --t * t * t * t },
    quarticInOut: function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2) },
    quinticIn: function (t) { return t * t * t * t * t },
    quinticOut: function (t) { return --t * t * t * t * t + 1 },
    quinticInOut: function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2) },
    sinusoidalIn: function (t) { return 1 - Math.cos(t * Math.PI / 2) },
    sinusoidalOut: function (t) { return Math.sin(t * Math.PI / 2) },
    sinusoidalInOut: function (t) { return 0.5 * (1 - Math.cos(Math.PI * t)) },
    exponentialIn: function (t) {
      return t === 0 ? 0 : Math.pow(1024, t - 1)
    },
    exponentialOut: function (t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t) },
    exponentialInOut: function (t) { return t === 0 ? 0 : t === 1 ? 1 : (t *= 2) < 1 ? 0.5 * Math.pow(1024, t - 1) : 0.5 * (-Math.pow(2, -10 * (t - 1)) + 2) },
    circularIn: function (t) { return 1 - Math.sqrt(1 - t * t) },
    circularOut: function (t) { return Math.sqrt(1 - --t * t) },
    circularInOut: function (t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) },
    elasticIn: function (t) { let e; let n = 0.1; const i = 0.4; return t === 0 ? 0 : t === 1 ? 1 : (!n || n < 1 ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), -(n * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / i))) },
    elasticOut: function (t) { let e; let n = 0.1; const i = 0.4; return t === 0 ? 0 : t === 1 ? 1 : (!n || n < 1 ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * t) * Math.sin(2 * (t - e) * Math.PI / i) + 1) },
    elasticInOut: function (t) { let e; let n = 0.1; const i = 0.4; return t === 0 ? 0 : t === 1 ? 1 : (!n || n < 1 ? (n = 1, e = i / 4) : e = i * Math.asin(1 / n) / (2 * Math.PI), (t *= 2) < 1 ? -0.5 * n * Math.pow(2, 10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / i) : n * Math.pow(2, -10 * (t -= 1)) * Math.sin(2 * (t - e) * Math.PI / i) * 0.5 + 1) },
    backIn: function (t) { const e = 1.70158; return t * t * ((e + 1) * t - e) },
    backOut: function (t) { const e = 1.70158; return --t * t * ((e + 1) * t + e) + 1 },
    backInOut: function (t) { const e = 2.5949095; return (t *= 2) < 1 ? 0.5 * t * t * ((e + 1) * t - e) : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2) },
    bounceIn: function (t) { return 1 - dT.bounceOut(1 - t) },
    bounceOut: function (t) { return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375 },
    bounceInOut: function (t) { return t < 0.5 ? 0.5 * dT.bounceIn(2 * t) : 0.5 * dT.bounceOut(2 * t - 1) + 0.5 }
  }; var fT = Math.pow; var gT = Math.sqrt; var yT = 1e-8; var vT = 1e-4; var mT = gT(3); var _T = 1 / 3; var xT = J(); var wT = J(); var bT = J(); var ST = /cubic-bezier\(([0-9,\.e ]+)\)/; const MT = (function () { function t (t) { this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || Q, this.ondestroy = t.ondestroy || Q, this.onrestart = t.onrestart || Q, t.easing && this.setEasing(t.easing) } return t.prototype.step = function (t, e) { if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) return void (this._pausedTime += e); const n = this._life; const i = t - this._startTime - this._pausedTime; let r = i / n; r < 0 && (r = 0), r = Math.min(r, 1); const o = this.easingFunc; const a = o ? o(r) : r; if (this.onframe(a), r === 1) { if (!this.loop) return !0; const s = i % n; this._startTime = t - s, this._pausedTime = 0, this.onrestart() } return !1 }, t.prototype.pause = function () { this._paused = !0 }, t.prototype.resume = function () { this._paused = !1 }, t.prototype.setEasing = function (t) { this.easing = t, this.easingFunc = T(t) ? t : dT[t] || Tn(t) }, t }()); const TT = (function () { function t (t) { this.value = t } return t }()); const IT = (function () { function t () { this._len = 0 } return t.prototype.insert = function (t) { const e = new TT(t); return this.insertEntry(e), e }, t.prototype.insertEntry = function (t) { this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++ }, t.prototype.remove = function (t) { const e = t.prev; const n = t.next; e ? e.next = n : this.head = n, n ? n.prev = e : this.tail = e, t.next = t.prev = null, this._len-- }, t.prototype.len = function () { return this._len }, t.prototype.clear = function () { this.head = this.tail = null, this._len = 0 }, t }()); var CT = (function () { function t (t) { this._list = new IT(), this._maxSize = 10, this._map = {}, this._maxSize = t } return t.prototype.put = function (t, e) { const n = this._list; const i = this._map; let r = null; if (i[t] == null) { const o = n.len(); let a = this._lastRemovedEntry; if (o >= this._maxSize && o > 0) { const s = n.head; n.remove(s), delete i[s.key], r = s.value, this._lastRemovedEntry = s }a ? a.value = e : a = new TT(e), a.key = t, n.insertEntry(a), i[t] = a } return r }, t.prototype.get = function (t) { const e = this._map[t]; const n = this._list; return e != null ? (e !== n.tail && (n.remove(e), n.insertEntry(e)), e.value) : void 0 }, t.prototype.clear = function () { this._list.clear(), this._map = {} }, t.prototype.len = function () { return this._list.len() }, t }()); var DT = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }; var kT = new CT(20); var AT = null; const LT = Hn; const PT = Wn; const OT = (Object.freeze || Object)({ parse: zn, lift: Vn, toHex: Fn, fastLerp: Hn, fastMapToColor: LT, lerp: Wn, mapToColor: PT, modifyHSL: Gn, modifyAlpha: Xn, stringify: Yn, lum: Un, random: Zn }); var RT = Math.round; var NT = 1e-4; var zT = { left: 'start', right: 'end', center: 'middle', middle: 'middle' }; const BT = (function () { return ZS.hasGlobalWindow && T(window.btoa) ? function (t) { return window.btoa(unescape(encodeURIComponent(t))) } : typeof Buffer !== 'undefined' ? function (t) { return Buffer.from(t).toString('base64') } : function () { return null } }()); var ET = Array.prototype.slice; const VT = 0; var FT = 1; var HT = 2; const WT = 3; var GT = 4; var XT = 5; const YT = 6; const UT = [0, 0, 0, 0]; const ZT = (function () { function t (t) { this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t } return t.prototype.isFinished = function () { return this._finished }, t.prototype.setFinished = function () { this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished() }, t.prototype.needsAnimate = function () { return this.keyframes.length >= 1 }, t.prototype.getAdditiveTrack = function () { return this._additiveTrack }, t.prototype.addKeyframe = function (t, e, n) { this._needsSort = !0; const i = this.keyframes; const r = i.length; let o = !1; let a = YT; let s = e; if (g(e)) { const l = xi(e); a = l, (l === 1 && !D(e[0]) || l === 2 && !D(e[0][0])) && (o = !0) } else if (D(e) && !z(e))a = VT; else if (I(e)) if (isNaN(+e)) { const u = zn(e); u && (s = u, a = WT) } else a = VT; else if (O(e)) { const c = h({}, s); c.colorStops = v(e.colorStops, function (t) { return { offset: t.offset, color: zn(t.color) } }), oi(e) ? a = GT : ai(e) && (a = XT), s = c }r === 0 ? this.valType = a : (a !== this.valType || a === YT) && (o = !0), this.discrete = this.discrete || o; const p = { time: t, value: s, rawValue: e, percent: 0 }; return n && (p.easing = n, p.easingFunc = T(n) ? n : dT[n] || Tn(n)), i.push(p), p }, t.prototype.prepare = function (t, e) { const n = this.keyframes; this._needsSort && n.sort(function (t, e) { return t.time - e.time }); for (var i = this.valType, r = n.length, o = n[r - 1], a = this.discrete, s = bi(i), l = wi(i), u = 0; r > u; u++) { const h = n[u]; const c = h.value; const p = o.value; h.percent = h.time / t, a || (s && u !== r - 1 ? vi(c, p, i) : l && yi(c.colorStops, p.colorStops)) } if (!a && i !== XT && e && this.needsAnimate() && e.needsAnimate() && i === e.valType && !e._finished) { this._additiveTrack = e; for (var d = n[0].value, u = 0; r > u; u++)i === VT ? n[u].additiveValue = n[u].value - d : i === WT ? n[u].additiveValue = fi([], n[u].value, d, -1) : bi(i) && (n[u].additiveValue = i === FT ? fi([], n[u].value, d, -1) : gi([], n[u].value, d, -1)) } }, t.prototype.step = function (t, e) { if (!this._finished) { this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null); let n; let i; let r; const o = this._additiveTrack != null; const a = o ? 'additiveValue' : 'value'; const s = this.valType; const l = this.keyframes; const u = l.length; const h = this.propName; const c = s === WT; const p = this._lastFr; const d = Math.min; if (u === 1)i = r = l[0]; else { if (e < 0)n = 0; else if (e < this._lastFrP) { const f = d(p + 1, u - 1); for (n = f; n >= 0 && !(l[n].percent <= e); n--);n = d(n, u - 2) } else { for (n = p; u > n && !(l[n].percent > e); n++);n = d(n - 1, u - 2) }r = l[n + 1], i = l[n] } if (i && r) { this._lastFr = n, this._lastFrP = e; const g = r.percent - i.percent; let y = g === 0 ? 1 : d((e - i.percent) / g, 1); r.easingFunc && (y = r.easingFunc(y)); let m = o ? this._additiveValue : c ? UT : t[h]; if (!bi(s) && !c || m || (m = this._additiveValue = []), this.discrete)t[h] = y < 1 ? i.rawValue : r.rawValue; else if (bi(s))s === FT ? pi(m, i[a], r[a], y) : di(m, i[a], r[a], y); else if (wi(s)) { const _ = i[a]; const x = r[a]; const w = s === GT; t[h] = { type: w ? 'linear' : 'radial', x: ci(_.x, x.x, y), y: ci(_.y, x.y, y), colorStops: v(_.colorStops, function (t, e) { const n = x.colorStops[e]; return { offset: ci(t.offset, n.offset, y), color: _i(pi([], t.color, n.color, y)) } }), global: x.global }, w ? (t[h].x2 = ci(_.x2, x.x2, y), t[h].y2 = ci(_.y2, x.y2, y)) : t[h].r = ci(_.r, x.r, y) } else if (c)pi(m, i[a], r[a], y), o || (t[h] = _i(m)); else { const b = ci(i[a], r[a], y); o ? this._additiveValue = b : t[h] = b }o && this._addToTarget(t) } } }, t.prototype._addToTarget = function (t) { const e = this.valType; const n = this.propName; const i = this._additiveValue; e === VT ? t[n] = t[n] + i : e === WT ? (zn(t[n], UT), fi(UT, UT, i, 1), t[n] = _i(UT)) : e === FT ? fi(t[n], t[n], i, 1) : e === HT && gi(t[n], t[n], i, 1) }, t }()); var jT = (function () { function t (t, e, n, i) { return this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = e, e && i ? void a("Can' use additive animation on looped animation.") : (this._additiveAnimators = i, void (this._allowDiscrete = n)) } return t.prototype.getMaxTime = function () { return this._maxTime }, t.prototype.getDelay = function () { return this._delay }, t.prototype.getLoop = function () { return this._loop }, t.prototype.getTarget = function () { return this._target }, t.prototype.changeTarget = function (t) { this._target = t }, t.prototype.when = function (t, e, n) { return this.whenWithKeys(t, e, w(e), n) }, t.prototype.whenWithKeys = function (t, e, n, i) { for (let r = this._tracks, o = 0; o < n.length; o++) { const a = n[o]; let s = r[a]; if (!s) { s = r[a] = new ZT(a); let l = void 0; const u = this._getAdditiveTrack(a); if (u) { const h = u.keyframes; const c = h[h.length - 1]; l = c && c.value, u.valType === WT && l && (l = _i(l)) } else l = this._target[a]; if (l == null) continue; t > 0 && s.addKeyframe(0, mi(l), i), this._trackKeys.push(a) }s.addKeyframe(t, mi(e[a]), i) } return this._maxTime = Math.max(this._maxTime, t), this }, t.prototype.pause = function () { this._clip.pause(), this._paused = !0 }, t.prototype.resume = function () { this._clip.resume(), this._paused = !1 }, t.prototype.isPaused = function () { return !!this._paused }, t.prototype.duration = function (t) { return this._maxTime = t, this._force = !0, this }, t.prototype._doneCallback = function () { this._setTracksFinished(), this._clip = null; const t = this._doneCbs; if (t) for (let e = t.length, n = 0; e > n; n++)t[n].call(this) }, t.prototype._abortedCallback = function () { this._setTracksFinished(); const t = this.animation; const e = this._abortedCbs; if (t && t.removeClip(this._clip), this._clip = null, e) for (let n = 0; n < e.length; n++)e[n].call(this) }, t.prototype._setTracksFinished = function () { for (let t = this._tracks, e = this._trackKeys, n = 0; n < e.length; n++)t[e[n]].setFinished() }, t.prototype._getAdditiveTrack = function (t) { let e; const n = this._additiveAnimators; if (n) for (let i = 0; i < n.length; i++) { const r = n[i].getTrack(t); r && (e = r) } return e }, t.prototype.start = function (t) { if (!(this._started > 0)) { this._started = 1; for (var e = this, n = [], i = this._maxTime || 0, r = 0; r < this._trackKeys.length; r++) { const o = this._trackKeys[r]; const a = this._tracks[o]; const s = this._getAdditiveTrack(o); const l = a.keyframes; const u = l.length; if (a.prepare(i, s), a.needsAnimate()) if (!this._allowDiscrete && a.discrete) { const h = l[u - 1]; h && (e._target[a.propName] = h.rawValue), a.setFinished() } else n.push(a) } if (n.length || this._force) { const c = new MT({ life: i, loop: this._loop, delay: this._delay || 0, onframe: function (t) { e._started = 2; const i = e._additiveAnimators; if (i) { for (var r = !1, o = 0; o < i.length; o++) if (i[o]._clip) { r = !0; break }r || (e._additiveAnimators = null) } for (var o = 0; o < n.length; o++)n[o].step(e._target, t); const a = e._onframeCbs; if (a) for (var o = 0; o < a.length; o++)a[o](e._target, t) }, ondestroy: function () { e._doneCallback() } }); this._clip = c, this.animation && this.animation.addClip(c), t && c.setEasing(t) } else this._doneCallback(); return this } }, t.prototype.stop = function (t) { if (this._clip) { const e = this._clip; t && e.onframe(1), this._abortedCallback() } }, t.prototype.delay = function (t) { return this._delay = t, this }, t.prototype.during = function (t) { return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this }, t.prototype.done = function (t) { return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this }, t.prototype.aborted = function (t) { return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this }, t.prototype.getClip = function () { return this._clip }, t.prototype.getTrack = function (t) { return this._tracks[t] }, t.prototype.getTracks = function () { const t = this; return v(this._trackKeys, function (e) { return t._tracks[e] }) }, t.prototype.stopTracks = function (t, e) { if (!t.length || !this._clip) return !0; for (var n = this._tracks, i = this._trackKeys, r = 0; r < t.length; r++) { const o = n[t[r]]; o && !o.isFinished() && (e ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished()) } for (var a = !0, r = 0; r < i.length; r++) if (!n[i[r]].isFinished()) { a = !1; break } return a && this._abortedCallback(), a }, t.prototype.saveTo = function (t, e, n) { if (t) { e = e || this._trackKeys; for (let i = 0; i < e.length; i++) { const r = e[i]; const o = this._tracks[r]; if (o && !o.isFinished()) { const a = o.keyframes; const s = a[n ? 0 : a.length - 1]; s && (t[r] = mi(s.rawValue)) } } } }, t.prototype.__changeFinalValue = function (t, e) { e = e || w(t); for (let n = 0; n < e.length; n++) { const i = e[n]; const r = this._tracks[i]; if (r) { const o = r.keyframes; if (o.length > 1) { const a = o.pop(); r.addKeyframe(a.time, t[i]), r.prepare(this._maxTime, r.getAdditiveTrack()) } } } }, t }()); const qT = (function (t) { function n (e) { const n = t.call(this) || this; return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, e = e || {}, n.stage = e.stage || {}, n } return e(n, t), n.prototype.addClip = function (t) { t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this }, n.prototype.addAnimator = function (t) { t.animation = this; const e = t.getClip(); e && this.addClip(e) }, n.prototype.removeClip = function (t) { if (t.animation) { const e = t.prev; const n = t.next; e ? e.next = n : this._head = n, n ? n.prev = e : this._tail = e, t.next = t.prev = t.animation = null } }, n.prototype.removeAnimator = function (t) { const e = t.getClip(); e && this.removeClip(e), t.animation = null }, n.prototype.update = function (t) { for (var e = Si() - this._pausedTime, n = e - this._time, i = this._head; i;) { const r = i.next; const o = i.step(e, n); o ? (i.ondestroy(), this.removeClip(i), i = r) : i = r } this._time = e, t || (this.trigger('frame', n), this.stage.update && this.stage.update()) }, n.prototype._startLoop = function () { function t () { e._running && (pT(t), !e._paused && e.update()) } var e = this; this._running = !0, pT(t) }, n.prototype.start = function () { this._running || (this._time = Si(), this._pausedTime = 0, this._startLoop()) }, n.prototype.stop = function () { this._running = !1 }, n.prototype.pause = function () { this._paused || (this._pauseStart = Si(), this._paused = !0) }, n.prototype.resume = function () { this._paused && (this._pausedTime += Si() - this._pauseStart, this._paused = !1) }, n.prototype.clear = function () { for (let t = this._head; t;) { const e = t.next; t.prev = t.next = t.animation = null, t = e } this._head = this._tail = null }, n.prototype.isFinished = function () { return this._head == null }, n.prototype.animate = function (t, e) { e = e || {}, this.start(); const n = new jT(t, e.loop); return this.addAnimator(n), n }, n }(kM)); const KT = 300; const $T = ZS.domSupported; var QT = (function () { const t = ['click', 'dblclick', 'mousewheel', 'wheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu']; const e = ['touchstart', 'touchend', 'touchmove']; const n = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 }; const i = v(t, function (t) { const e = t.replace('mouse', 'pointer'); return n.hasOwnProperty(e) ? e : t }); return { mouse: t, touch: e, pointer: i } }()); var JT = { mouse: ['mousemove', 'mouseup'], pointer: ['pointermove', 'pointerup'] }; let tI = !1; var eI = (function () { function t (t, e) { this.stopPropagation = Q, this.stopImmediatePropagation = Q, this.preventDefault = Q, this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY } return t }()); var nI = { mousedown: function (t) { t = Le(this.dom, t), this.__mayPointerCapture = [t.zrX, t.zrY], this.trigger('mousedown', t) }, mousemove: function (t) { t = Le(this.dom, t); const e = this.__mayPointerCapture; !e || t.zrX === e[0] && t.zrY === e[1] || this.__togglePointerCapture(!0), this.trigger('mousemove', t) }, mouseup: function (t) { t = Le(this.dom, t), this.__togglePointerCapture(!1), this.trigger('mouseup', t) }, mouseout: function (t) { t = Le(this.dom, t); const e = t.toElement || t.relatedTarget; Di(this, e) || (this.__pointerCapturing && (t.zrEventControl = 'no_globalout'), this.trigger('mouseout', t)) }, wheel: function (t) { tI = !0, t = Le(this.dom, t), this.trigger('mousewheel', t) }, mousewheel: function (t) { tI || (t = Le(this.dom, t), this.trigger('mousewheel', t)) }, touchstart: function (t) { t = Le(this.dom, t), Ii(t), this.__lastTouchMoment = new Date(), this.handler.processGesture(t, 'start'), nI.mousemove.call(this, t), nI.mousedown.call(this, t) }, touchmove: function (t) { t = Le(this.dom, t), Ii(t), this.handler.processGesture(t, 'change'), nI.mousemove.call(this, t) }, touchend: function (t) { t = Le(this.dom, t), Ii(t), this.handler.processGesture(t, 'end'), nI.mouseup.call(this, t), +new Date() - +this.__lastTouchMoment < KT && nI.click.call(this, t) }, pointerdown: function (t) { nI.mousedown.call(this, t) }, pointermove: function (t) { Mi(t) || nI.mousemove.call(this, t) }, pointerup: function (t) { nI.mouseup.call(this, t) }, pointerout: function (t) { Mi(t) || nI.mouseout.call(this, t) } }; y(['click', 'dblclick', 'contextmenu'], function (t) { nI[t] = function (e) { e = Le(this.dom, e), this.trigger(t, e) } }); var iI = { pointermove: function (t) { Mi(t) || iI.mousemove.call(this, t) }, pointerup: function (t) { iI.mouseup.call(this, t) }, mousemove: function (t) { this.trigger('mousemove', t) }, mouseup: function (t) { const e = this.__pointerCapturing; this.__togglePointerCapture(!1), this.trigger('mouseup', t), e && (t.zrEventControl = 'only_globalout', this.trigger('mouseout', t)) } }; const rI = (function () { function t (t, e) { this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = e } return t }()); const oI = (function (t) { function n (e, n) { const i = t.call(this) || this; return i.__pointerCapturing = !1, i.dom = e, i.painterRoot = n, i._localHandlerScope = new rI(e, nI), $T && (i._globalHandlerScope = new rI(document, iI)), ki(i, i._localHandlerScope), i } return e(n, t), n.prototype.dispose = function () { Pi(this._localHandlerScope), $T && Pi(this._globalHandlerScope) }, n.prototype.setCursor = function (t) { this.dom.style && (this.dom.style.cursor = t || 'default') }, n.prototype.__togglePointerCapture = function (t) { if (this.__mayPointerCapture = null, $T && +this.__pointerCapturing ^ +t) { this.__pointerCapturing = t; const e = this._globalHandlerScope; t ? Ai(this, e) : Pi(e) } }, n }(kM)); let aI = 1; ZS.hasGlobalWindow && (aI = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1)); const sI = aI; var lI = 0.4; const uI = '#333'; const hI = '#ccc'; const cI = '#eee'; const pI = Ve; var dI = 5e-5; const fI = []; const gI = []; const yI = Ee(); const vI = Math.abs; var mI = (function () { function t () {} return t.prototype.getLocalTransform = function (e) { return t.getLocalTransform(this, e) }, t.prototype.setPosition = function (t) { this.x = t[0], this.y = t[1] }, t.prototype.setScale = function (t) { this.scaleX = t[0], this.scaleY = t[1] }, t.prototype.setSkew = function (t) { this.skewX = t[0], this.skewY = t[1] }, t.prototype.setOrigin = function (t) { this.originX = t[0], this.originY = t[1] }, t.prototype.needLocalTransform = function () { return Oi(this.rotation) || Oi(this.x) || Oi(this.y) || Oi(this.scaleX - 1) || Oi(this.scaleY - 1) || Oi(this.skewX) || Oi(this.skewY) }, t.prototype.updateTransform = function () { const t = this.parent && this.parent.transform; const e = this.needLocalTransform(); let n = this.transform; return e || t ? (n = n || Ee(), e ? this.getLocalTransform(n) : pI(n), t && (e ? He(n, t, n) : Fe(n, t)), this.transform = n, void this._resolveGlobalScaleRatio(n)) : void (n && pI(n)) }, t.prototype._resolveGlobalScaleRatio = function (t) { const e = this.globalScaleRatio; if (e != null && e !== 1) { this.getGlobalScale(fI); const n = fI[0] < 0 ? -1 : 1; const i = fI[1] < 0 ? -1 : 1; const r = ((fI[0] - n) * e + n) / fI[0] || 0; const o = ((fI[1] - i) * e + i) / fI[1] || 0; t[0] *= r, t[1] *= r, t[2] *= o, t[3] *= o } this.invTransform = this.invTransform || Ee(), Ye(this.invTransform, t) }, t.prototype.getComputedTransform = function () { for (var t = this, e = []; t;)e.push(t), t = t.parent; for (;t = e.pop();)t.updateTransform(); return this.transform }, t.prototype.setLocalTransform = function (t) { if (t) { let e = t[0] * t[0] + t[1] * t[1]; let n = t[2] * t[2] + t[3] * t[3]; const i = Math.atan2(t[1], t[0]); const r = Math.PI / 2 + i - Math.atan2(t[3], t[2]); n = Math.sqrt(n) * Math.cos(r), e = Math.sqrt(e), this.skewX = r, this.skewY = 0, this.rotation = -i, this.x = +t[4], this.y = +t[5], this.scaleX = e, this.scaleY = n, this.originX = 0, this.originY = 0 } }, t.prototype.decomposeTransform = function () { if (this.transform) { const t = this.parent; let e = this.transform; t && t.transform && (He(gI, t.invTransform, e), e = gI); const n = this.originX; const i = this.originY; (n || i) && (yI[4] = n, yI[5] = i, He(gI, e, yI), gI[4] -= n, gI[5] -= i, e = gI), this.setLocalTransform(e) } }, t.prototype.getGlobalScale = function (t) { const e = this.transform; return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t) }, t.prototype.transformCoordToLocal = function (t, e) { const n = [t, e]; const i = this.invTransform; return i && ve(n, n, i), n }, t.prototype.transformCoordToGlobal = function (t, e) { const n = [t, e]; const i = this.transform; return i && ve(n, n, i), n }, t.prototype.getLineScale = function () { const t = this.transform; return t && vI(t[0] - 1) > 1e-10 && vI(t[3] - 1) > 1e-10 ? Math.sqrt(vI(t[0] * t[3] - t[2] * t[1])) : 1 }, t.prototype.copyTransform = function (t) { Ri(this, t) }, t.getLocalTransform = function (t, e) { e = e || []; const n = t.originX || 0; const i = t.originY || 0; const r = t.scaleX; const o = t.scaleY; const a = t.anchorX; const s = t.anchorY; const l = t.rotation || 0; const u = t.x; const h = t.y; const c = t.skewX ? Math.tan(t.skewX) : 0; const p = t.skewY ? Math.tan(-t.skewY) : 0; if (n || i || a || s) { const d = n + a; const f = i + s; e[4] = -d * r - c * f * o, e[5] = -f * o - p * d * r } else e[4] = e[5] = 0; return e[0] = r, e[3] = o, e[1] = p * r, e[2] = c * o, l && Ge(e, e, l), e[4] += n + u, e[5] += i + h, e }, t.initDefaultProps = (function () { const e = t.prototype; e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0 }()), t }()); var _I = ['x', 'y', 'originX', 'originY', 'anchorX', 'anchorY', 'rotation', 'scaleX', 'scaleY', 'skewX', 'skewY']; var xI = {}; const wI = '__zr_normal__'; const bI = _I.concat(['ignore']); const SI = m(_I, function (t, e) { return t[e] = !0, t }, { ignore: !1 }); const MI = {}; const TI = new $M(0, 0, 0, 0); const II = (function () {
    function t (t) { this.id = o(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t) } return t.prototype._init = function (t) { this.attr(t) }, t.prototype.drift = function (t, e) { switch (this.draggable) { case 'horizontal':e = 0; break; case 'vertical':t = 0 } let n = this.transform; n || (n = this.transform = [1, 0, 0, 1, 0, 0]), n[4] += t, n[5] += e, this.decomposeTransform(), this.markRedraw() }, t.prototype.beforeUpdate = function () {}, t.prototype.afterUpdate = function () {}, t.prototype.update = function () { this.updateTransform(), this.__dirty && this.updateInnerText() }, t.prototype.updateInnerText = function (t) { const e = this._textContent; if (e && (!e.ignore || t)) { this.textConfig || (this.textConfig = {}); const n = this.textConfig; const i = n.local; const r = e.innerTransformable; let o = void 0; let a = void 0; let s = !1; r.parent = i ? this : null; let l = !1; if (r.copyTransform(e), n.position != null) { const u = TI; u.copy(n.layoutRect ? n.layoutRect : this.getBoundingRect()), i || u.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(MI, n, u) : Wi(MI, n, u), r.x = MI.x, r.y = MI.y, o = MI.align, a = MI.verticalAlign; const h = n.origin; if (h && n.rotation != null) { let c = void 0; let p = void 0; h === 'center' ? (c = 0.5 * u.width, p = 0.5 * u.height) : (c = Hi(h[0], u.width), p = Hi(h[1], u.height)), l = !0, r.originX = -r.x + c + (i ? 0 : u.x), r.originY = -r.y + p + (i ? 0 : u.y) } }n.rotation != null && (r.rotation = n.rotation); const d = n.offset; d && (r.x += d[0], r.y += d[1], l || (r.originX = -d[0], r.originY = -d[1])); const f = n.inside == null ? typeof n.position === 'string' && n.position.indexOf('inside') >= 0 : n.inside; const g = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}); let y = void 0; let v = void 0; let m = void 0; f && this.canBeInsideText() ? (y = n.insideFill, v = n.insideStroke, (y == null || y === 'auto') && (y = this.getInsideTextFill()), (v == null || v === 'auto') && (v = this.getInsideTextStroke(y), m = !0)) : (y = n.outsideFill, v = n.outsideStroke, (y == null || y === 'auto') && (y = this.getOutsideFill()), (v == null || v === 'auto') && (v = this.getOutsideStroke(y), m = !0)), y = y || '#000', (y !== g.fill || v !== g.stroke || m !== g.autoStroke || o !== g.align || a !== g.verticalAlign) && (s = !0, g.fill = y, g.stroke = v, g.autoStroke = m, g.align = o, g.verticalAlign = a, e.setDefaultTextStyle(g)), e.__dirty |= sT, s && e.dirtyStyle(!0) } }, t.prototype.canBeInsideText = function () { return !0 }, t.prototype.getInsideTextFill = function () { return '#fff' }, t.prototype.getInsideTextStroke = function () { return '#000' }, t.prototype.getOutsideFill = function () { return this.__zr && this.__zr.isDarkMode() ? hI : uI }, t.prototype.getOutsideStroke = function () { const t = this.__zr && this.__zr.getBackgroundColor(); let e = typeof t === 'string' && zn(t); e || (e = [255, 255, 255, 1]); for (let n = e[3], i = this.__zr.isDarkMode(), r = 0; r < 3; r++)e[r] = e[r] * n + (i ? 0 : 255) * (1 - n); return e[3] = 1, Yn(e, 'rgba') }, t.prototype.traverse = function () {}, t.prototype.attrKV = function (t, e) { t === 'textConfig' ? this.setTextConfig(e) : t === 'textContent' ? this.setTextContent(e) : t === 'clipPath' ? this.setClipPath(e) : t === 'extra' ? (this.extra = this.extra || {}, h(this.extra, e)) : this[t] = e }, t.prototype.hide = function () { this.ignore = !0, this.markRedraw() }, t.prototype.show = function () { this.ignore = !1, this.markRedraw() }, t.prototype.attr = function (t, e) { if (typeof t === 'string') this.attrKV(t, e); else if (k(t)) for (let n = t, i = w(n), r = 0; r < i.length; r++) { const o = i[r]; this.attrKV(o, t[o]) } return this.markRedraw(), this }, t.prototype.saveCurrentToNormalState = function (t) { this._innerSaveToNormal(t); for (let e = this._normalState, n = 0; n < this.animators.length; n++) { const i = this.animators[n]; const r = i.__fromStateTransition; if (!(i.getLoop() || r && r !== wI)) { const o = i.targetName; const a = o ? e[o] : e; i.saveTo(a) } } }, t.prototype._innerSaveToNormal = function (t) { let e = this._normalState; e || (e = this._normalState = {}), t.textConfig && !e.textConfig && (e.textConfig = this.textConfig), this._savePrimaryToNormal(t, e, bI) }, t.prototype._savePrimaryToNormal = function (t, e, n) { for (let i = 0; i < n.length; i++) { const r = n[i]; t[r] == null || r in e || (e[r] = this[r]) } }, t.prototype.hasState = function () { return this.currentStates.length > 0 }, t.prototype.getState = function (t) { return this.states[t] }, t.prototype.ensureState = function (t) { const e = this.states; return e[t] || (e[t] = {}), e[t] }, t.prototype.clearStates = function (t) { this.useState(wI, !1, t) }, t.prototype.useState = function (t, e, n, i) { const r = t === wI; const o = this.hasState(); if (o || !r) { const s = this.currentStates; const l = this.stateTransition; if (!(p(s, t) >= 0) || !e && s.length !== 1) { let u; if (this.stateProxy && !r && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !r) return void a('State ' + t + ' not exists.'); r || this.saveCurrentToNormalState(u); const h = !!(u && u.hoverLayer || i); h && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, e, !n && !this.__inHover && l && l.duration > 0, l); const c = this._textContent; const d = this._textGuide; return c && c.useState(t, e, n, h), d && d.useState(t, e, n, h), r ? (this.currentStates = [], this._normalState = {}) : e ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~sT), u } } }, t.prototype.useStates = function (t, e, n) { if (t.length) { const i = []; const r = this.currentStates; const o = t.length; let a = o === r.length; if (a) for (var s = 0; o > s; s++) if (t[s] !== r[s]) { a = !1; break } if (a) return; for (var s = 0; o > s; s++) { const l = t[s]; let u = void 0; this.stateProxy && (u = this.stateProxy(l, t)), u || (u = this.states[l]), u && i.push(u) } const h = i[o - 1]; const c = !!(h && h.hoverLayer || n); c && this._toggleHoverLayerFlag(!0); const p = this._mergeStates(i); const d = this.stateTransition; this.saveCurrentToNormalState(p), this._applyStateObj(t.join(','), p, this._normalState, !1, !e && !this.__inHover && d && d.duration > 0, d); const f = this._textContent; const g = this._textGuide; f && f.useStates(t, e, c), g && g.useStates(t, e, c), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~sT) } else this.clearStates() }, t.prototype._updateAnimationTargets = function () { for (let t = 0; t < this.animators.length; t++) { const e = this.animators[t]; e.targetName && e.changeTarget(this[e.targetName]) } }, t.prototype.removeState = function (t) { const e = p(this.currentStates, t); if (e >= 0) { const n = this.currentStates.slice(); n.splice(e, 1), this.useStates(n) } }, t.prototype.replaceState = function (t, e, n) { const i = this.currentStates.slice(); const r = p(i, t); const o = p(i, e) >= 0; r >= 0 ? o ? i.splice(r, 1) : i[r] = e : n && !o && i.push(e), this.useStates(i) }, t.prototype.toggleState = function (t, e) { e ? this.useState(t, !0) : this.removeState(t) }, t.prototype._mergeStates = function (t) { for (var e, n = {}, i = 0; i < t.length; i++) { const r = t[i]; h(n, r), r.textConfig && (e = e || {}, h(e, r.textConfig)) } return e && (n.textConfig = e), n }, t.prototype._applyStateObj = function (t, e, n, i, r, o) { const a = !(e && i); e && e.textConfig ? (this.textConfig = h({}, i ? this.textConfig : n.textConfig), h(this.textConfig, e.textConfig)) : a && n.textConfig && (this.textConfig = n.textConfig); for (var s = {}, l = !1, u = 0; u < bI.length; u++) { const c = bI[u]; const p = r && SI[c]; e && e[c] != null ? p ? (l = !0, s[c] = e[c]) : this[c] = e[c] : a && n[c] != null && (p ? (l = !0, s[c] = n[c]) : this[c] = n[c]) } if (!r) for (var u = 0; u < this.animators.length; u++) { const d = this.animators[u]; const f = d.targetName; d.getLoop() || d.__changeFinalValue(f ? (e || n)[f] : e || n) }l && this._transitionState(t, s, o) }, t.prototype._attachComponent = function (t) { if ((!t.__zr || t.__hostTarget) && t !== this) { const e = this.__zr; e && t.addSelfToZr(e), t.__zr = e, t.__hostTarget = this } }, t.prototype._detachComponent = function (t) { t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null }, t.prototype.getClipPath = function () { return this._clipPath }, t.prototype.setClipPath = function (t) { this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw() }, t.prototype.removeClipPath = function () { const t = this._clipPath; t && (this._detachComponent(t), this._clipPath = null, this.markRedraw()) }, t.prototype.getTextContent = function () { return this._textContent }, t.prototype.setTextContent = function (t) { const e = this._textContent; e !== t && (e && e !== t && this.removeTextContent(), t.innerTransformable = new mI(), this._attachComponent(t), this._textContent = t, this.markRedraw()) }, t.prototype.setTextConfig = function (t) { this.textConfig || (this.textConfig = {}), h(this.textConfig, t), this.markRedraw() }, t.prototype.removeTextConfig = function () { this.textConfig = null, this.markRedraw() }, t.prototype.removeTextContent = function () { const t = this._textContent; t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw()) }, t.prototype.getTextGuideLine = function () { return this._textGuide }, t.prototype.setTextGuideLine = function (t) {
      this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw()
    }, t.prototype.removeTextGuideLine = function () { const t = this._textGuide; t && (this._detachComponent(t), this._textGuide = null, this.markRedraw()) }, t.prototype.markRedraw = function () { this.__dirty |= sT; const t = this.__zr; t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw() }, t.prototype.dirty = function () { this.markRedraw() }, t.prototype._toggleHoverLayerFlag = function (t) { this.__inHover = t; const e = this._textContent; const n = this._textGuide; e && (e.__inHover = t), n && (n.__inHover = t) }, t.prototype.addSelfToZr = function (t) { if (this.__zr !== t) { this.__zr = t; const e = this.animators; if (e) for (let n = 0; n < e.length; n++)t.animation.addAnimator(e[n]); this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t) } }, t.prototype.removeSelfFromZr = function (t) { if (this.__zr) { this.__zr = null; const e = this.animators; if (e) for (let n = 0; n < e.length; n++)t.animation.removeAnimator(e[n]); this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t) } }, t.prototype.animate = function (t, e, n) { const i = t ? this[t] : this; const r = new jT(i, e, n); return t && (r.targetName = t), this.addAnimator(r, t), r }, t.prototype.addAnimator = function (t, e) { const n = this.__zr; const i = this; t.during(function () { i.updateDuringAnimation(e) }).done(function () { const e = i.animators; const n = p(e, t); n >= 0 && e.splice(n, 1) }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp() }, t.prototype.updateDuringAnimation = function () { this.markRedraw() }, t.prototype.stopAnimation = function (t, e) { for (var n = this.animators, i = n.length, r = [], o = 0; i > o; o++) { const a = n[o]; t && t !== a.scope ? r.push(a) : a.stop(e) } return this.animators = r, this }, t.prototype.animateTo = function (t, e, n) { Gi(this, t, e, n) }, t.prototype.animateFrom = function (t, e, n) { Gi(this, t, e, n, !0) }, t.prototype._transitionState = function (t, e, n, i) { for (let r = Gi(this, e, n, i), o = 0; o < r.length; o++)r[o].__fromStateTransition = t }, t.prototype.getBoundingRect = function () { return null }, t.prototype.getPaintRect = function () { return null }, t.initDefaultProps = (function () { function e (t, e, i, r) { function o (t, e) { Object.defineProperty(e, 0, { get: function () { return t[i] }, set: function (e) { t[i] = e } }), Object.defineProperty(e, 1, { get: function () { return t[r] }, set: function (e) { t[r] = e } }) }Object.defineProperty(n, t, { get: function () { if (!this[e]) { const t = this[e] = []; o(this, t) } return this[e] }, set: function (t) { this[i] = t[0], this[r] = t[1], this[e] = t, o(this, t) } }) } var n = t.prototype; n.type = 'element', n.name = '', n.ignore = n.silent = n.isGroup = n.draggable = n.dragging = n.ignoreClip = n.__inHover = !1, n.__dirty = sT, Object.defineProperty && (e('position', '_legacyPos', 'x', 'y'), e('scale', '_legacyScale', 'scaleX', 'scaleY'), e('origin', '_legacyOrigin', 'originX', 'originY')) }()), t
  }()); f(II, kM), f(II, mI); var CI = (function (t) { function n (e) { const n = t.call(this) || this; return n.isGroup = !0, n._children = [], n.attr(e), n } return e(n, t), n.prototype.childrenRef = function () { return this._children }, n.prototype.children = function () { return this._children.slice() }, n.prototype.childAt = function (t) { return this._children[t] }, n.prototype.childOfName = function (t) { for (let e = this._children, n = 0; n < e.length; n++) if (e[n].name === t) return e[n] }, n.prototype.childCount = function () { return this._children.length }, n.prototype.add = function (t) { return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this }, n.prototype.addBefore = function (t, e) { if (t && t !== this && t.parent !== this && e && e.parent === this) { const n = this._children; const i = n.indexOf(e); i >= 0 && (n.splice(i, 0, t), this._doAdd(t)) } return this }, n.prototype.replace = function (t, e) { const n = p(this._children, t); return n >= 0 && this.replaceAt(e, n), this }, n.prototype.replaceAt = function (t, e) { const n = this._children; const i = n[e]; if (t && t !== this && t.parent !== this && t !== i) { n[e] = t, i.parent = null; const r = this.__zr; r && i.removeSelfFromZr(r), this._doAdd(t) } return this }, n.prototype._doAdd = function (t) { t.parent && t.parent.remove(t), t.parent = this; const e = this.__zr; e && e !== t.__zr && t.addSelfToZr(e), e && e.refresh() }, n.prototype.remove = function (t) { const e = this.__zr; const n = this._children; const i = p(n, t); return i < 0 ? this : (n.splice(i, 1), t.parent = null, e && t.removeSelfFromZr(e), e && e.refresh(), this) }, n.prototype.removeAll = function () { for (var t = this._children, e = this.__zr, n = 0; n < t.length; n++) { const i = t[n]; e && i.removeSelfFromZr(e), i.parent = null } return t.length = 0, this }, n.prototype.eachChild = function (t, e) { for (let n = this._children, i = 0; i < n.length; i++) { const r = n[i]; t.call(e, r, i) } return this }, n.prototype.traverse = function (t, e) { for (let n = 0; n < this._children.length; n++) { const i = this._children[n]; const r = t.call(e, i); i.isGroup && !r && i.traverse(t, e) } return this }, n.prototype.addSelfToZr = function (e) { t.prototype.addSelfToZr.call(this, e); for (let n = 0; n < this._children.length; n++) { const i = this._children[n]; i.addSelfToZr(e) } }, n.prototype.removeSelfFromZr = function (e) { t.prototype.removeSelfFromZr.call(this, e); for (let n = 0; n < this._children.length; n++) { const i = this._children[n]; i.removeSelfFromZr(e) } }, n.prototype.getBoundingRect = function (t) { for (var e = new $M(0, 0, 0, 0), n = t || this._children, i = [], r = null, o = 0; o < n.length; o++) { const a = n[o]; if (!a.ignore && !a.invisible) { const s = a.getBoundingRect(); const l = a.getLocalTransform(i); l ? ($M.applyTransform(e, s, l), r = r || e.clone(), r.union(e)) : (r = r || s.clone(), r.union(s)) } } return r || e }, n }(II)); CI.prototype.type = 'group'; var DI = {}; var kI = {}; var AI = (function () { function t (t, e, n) { const i = this; this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = e, this.id = t; const r = new cT(); let o = n.renderer || 'canvas'; DI[o] || (o = w(DI)[0]), n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect; const a = new DI[o](e, r, n, t); const s = n.ssr || a.ssrOnly; this.storage = r, this.painter = a; let l; const u = ZS.node || ZS.worker || s ? null : new oI(a.getViewportRoot(), a.root); const h = n.useCoarsePointer; const c = h == null || h === 'auto' ? ZS.touchEventsSupported : !!h; const p = 44; c && (l = E(n.pointerSize, p)), this.handler = new iT(r, a, u, a.root, l), this.animation = new qT({ stage: { update: s ? null : function () { return i._flush(!0) } } }), s || this.animation.start() } return t.prototype.add = function (t) { t && (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh()) }, t.prototype.remove = function (t) { t && (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh()) }, t.prototype.configLayer = function (t, e) { this.painter.configLayer && this.painter.configLayer(t, e), this.refresh() }, t.prototype.setBackgroundColor = function (t) { this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = $i(t) }, t.prototype.getBackgroundColor = function () { return this._backgroundColor }, t.prototype.setDarkMode = function (t) { this._darkMode = t }, t.prototype.isDarkMode = function () { return this._darkMode }, t.prototype.refreshImmediately = function (t) { t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1 }, t.prototype.refresh = function () { this._needsRefresh = !0, this.animation.start() }, t.prototype.flush = function () { this._flush(!1) }, t.prototype._flush = function (t) { let e; const n = Si(); this._needsRefresh && (e = !0, this.refreshImmediately(t)), this._needsRefreshHover && (e = !0, this.refreshHoverImmediately()); const i = Si(); e ? (this._stillFrameAccum = 0, this.trigger('rendered', { elapsedTime: i - n })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop()) }, t.prototype.setSleepAfterStill = function (t) { this._sleepAfterStill = t }, t.prototype.wakeUp = function () { this.animation.start(), this._stillFrameAccum = 0 }, t.prototype.refreshHover = function () { this._needsRefreshHover = !0 }, t.prototype.refreshHoverImmediately = function () { this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === 'canvas' && this.painter.refreshHover() }, t.prototype.resize = function (t) { t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize() }, t.prototype.clearAnimation = function () { this.animation.clear() }, t.prototype.getWidth = function () { return this.painter.getWidth() }, t.prototype.getHeight = function () { return this.painter.getHeight() }, t.prototype.setCursorStyle = function (t) { this.handler.setCursorStyle(t) }, t.prototype.findHover = function (t, e) { return this.handler.findHover(t, e) }, t.prototype.on = function (t, e, n) { return this.handler.on(t, e, n), this }, t.prototype.off = function (t, e) { this.handler.off(t, e) }, t.prototype.trigger = function (t, e) { this.handler.trigger(t, e) }, t.prototype.clear = function () { for (let t = this.storage.getRoots(), e = 0; e < t.length; e++)t[e] instanceof CI && t[e].removeSelfFromZr(this); this.storage.delAllRoots(), this.painter.clear() }, t.prototype.dispose = function () { this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, Ki(this.id) }, t }()); const LI = '5.4.3'; const PI = (Object.freeze || Object)({ init: Qi, dispose: Ji, disposeAll: tr, getInstance: er, registerPainter: nr, version: LI }); var OI = 1e-4; var RI = 20; const NI = 9007199254740991; var zI = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; var BI = (typeof console !== 'undefined' && console.warn && console.log, 'series\x00'); var EI = '\x00_ec_\x00'; var VI = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; var FI = Mr(); var HI = { useDefault: !0, enableAll: !1, enableNone: !1 }; const WI = { useDefault: !1, enableAll: !0, enableNone: !0 }; var GI = '.'; var XI = '___EC__COMPONENT__CONTAINER___'; var YI = '___EC__EXTENDED_CLASS___'; var UI = Math.round(10 * Math.random()); const ZI = [['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]; const jI = fo(ZI); const qI = (function () { function t () {} return t.prototype.getAreaStyle = function (t, e) { return jI(this, t, e) }, t }()); var KI = new CT(50); var $I = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g; var QI = (function () { function t () {} return t }()); var JI = (function () { function t (t) { this.tokens = [], t && (this.tokens = t) } return t }()); var tC = (function () { function t () { this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [] } return t }()); var eC = m(',&?/;] '.split(''), function (t, e) { return t[e] = !0, t }, {}); const nC = '__zr_style_' + Math.round(10 * Math.random()); var iC = { shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, shadowColor: '#000', opacity: 1, blend: 'source-over' }; const rC = { style: { shadowBlur: !0, shadowOffsetX: !0, shadowOffsetY: !0, shadowColor: !0, opacity: !0 } }; iC[nC] = !0; const oC = ['z', 'z2', 'invisible']; const aC = ['invisible']; var sC = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype._init = function (e) { for (let n = w(e), i = 0; i < n.length; i++) { const r = n[i]; r === 'style' ? this.useStyle(e[r]) : t.prototype.attrKV.call(this, r, e[r]) } this.style || this.useStyle({}) }, n.prototype.beforeBrush = function () {}, n.prototype.afterBrush = function () {}, n.prototype.innerBeforeBrush = function () {}, n.prototype.innerAfterBrush = function () {}, n.prototype.shouldBePainted = function (t, e, n, i) { const r = this.transform; if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && ko(this, t, e) || r && !r[0] && !r[3]) return !1; if (n && this.__clipPaths) for (let o = 0; o < this.__clipPaths.length; ++o) if (this.__clipPaths[o].isZeroArea()) return !1; if (i && this.parent) for (let a = this.parent; a;) { if (a.ignore) return !1; a = a.parent } return !0 }, n.prototype.contain = function (t, e) { return this.rectContain(t, e) }, n.prototype.traverse = function (t, e) { t.call(e, this) }, n.prototype.rectContain = function (t, e) { const n = this.transformCoordToLocal(t, e); const i = this.getBoundingRect(); return i.contain(n[0], n[1]) }, n.prototype.getPaintRect = function () { let t = this._paintRect; if (!this._paintRect || this.__dirty) { const e = this.transform; const n = this.getBoundingRect(); const i = this.style; const r = i.shadowBlur || 0; const o = i.shadowOffsetX || 0; const a = i.shadowOffsetY || 0; t = this._paintRect || (this._paintRect = new $M(0, 0, 0, 0)), e ? $M.applyTransform(t, n, e) : t.copy(n), (r || o || a) && (t.width += 2 * r + Math.abs(o), t.height += 2 * r + Math.abs(a), t.x = Math.min(t.x, t.x + o - r), t.y = Math.min(t.y, t.y + a - r)); const s = this.dirtyRectTolerance; t.isZero() || (t.x = Math.floor(t.x - s), t.y = Math.floor(t.y - s), t.width = Math.ceil(t.width + 1 + 2 * s), t.height = Math.ceil(t.height + 1 + 2 * s)) } return t }, n.prototype.setPrevPaintRect = function (t) { t ? (this._prevPaintRect = this._prevPaintRect || new $M(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null }, n.prototype.getPrevPaintRect = function () { return this._prevPaintRect }, n.prototype.animateStyle = function (t) { return this.animate('style', t) }, n.prototype.updateDuringAnimation = function (t) { t === 'style' ? this.dirtyStyle() : this.markRedraw() }, n.prototype.attrKV = function (e, n) { e !== 'style' ? t.prototype.attrKV.call(this, e, n) : this.style ? this.setStyle(n) : this.useStyle(n) }, n.prototype.setStyle = function (t, e) { return typeof t === 'string' ? this.style[t] = e : h(this.style, t), this.dirtyStyle(), this }, n.prototype.dirtyStyle = function (t) { t || this.markRedraw(), this.__dirty |= lT, this._rect && (this._rect = null) }, n.prototype.dirty = function () { this.dirtyStyle() }, n.prototype.styleChanged = function () { return !!(this.__dirty & lT) }, n.prototype.styleUpdated = function () { this.__dirty &= ~lT }, n.prototype.createStyle = function (t) { return q(iC, t) }, n.prototype.useStyle = function (t) { t[nC] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle() }, n.prototype.isStyleObject = function (t) { return t[nC] }, n.prototype._innerSaveToNormal = function (e) { t.prototype._innerSaveToNormal.call(this, e); const n = this._normalState; e.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(e, n, oC) }, n.prototype._applyStateObj = function (e, n, i, r, o, a) { t.prototype._applyStateObj.call(this, e, n, i, r, o, a); let s; const l = !(n && r); if (n && n.style ? o ? r ? s = n.style : (s = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(s, n.style)) : (s = this._mergeStyle(this.createStyle(), r ? this.style : i.style), this._mergeStyle(s, n.style)) : l && (s = i.style), s) if (o) { const u = this.style; if (this.style = this.createStyle(l ? {} : u), l) for (var h = w(u), c = 0; c < h.length; c++) { var p = h[c]; p in s && (s[p] = s[p], this.style[p] = u[p]) } for (var d = w(s), c = 0; c < d.length; c++) { var p = d[c]; this.style[p] = this.style[p] } this._transitionState(e, { style: s }, a, this.getAnimationStyleProps()) } else this.useStyle(s); for (var f = this.__inHover ? aC : oC, c = 0; c < f.length; c++) { var p = f[c]; n && n[p] != null ? this[p] = n[p] : l && i[p] != null && (this[p] = i[p]) } }, n.prototype._mergeStates = function (e) { for (var n, i = t.prototype._mergeStates.call(this, e), r = 0; r < e.length; r++) { const o = e[r]; o.style && (n = n || {}, this._mergeStyle(n, o.style)) } return n && (i.style = n), i }, n.prototype._mergeStyle = function (t, e) { return h(t, e), t }, n.prototype.getAnimationStyleProps = function () { return rC }, n.initDefaultProps = (function () { const t = n.prototype; t.type = 'displayable', t.invisible = !1, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = !1, t.cursor = 'pointer', t.rectHover = !1, t.incremental = !1, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = sT | lT }()), n }(II)); var lC = new $M(0, 0, 0, 0); var uC = new $M(0, 0, 0, 0); var hC = Math.min; var cC = Math.max; var pC = Math.sin; var dC = Math.cos; var fC = 2 * Math.PI; var gC = J(); var yC = J(); var vC = J(); var mC = []; var _C = []; const xC = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 }; const wC = []; const bC = []; const SC = []; const MC = []; const TC = []; const IC = []; const CC = Math.min; const DC = Math.max; const kC = Math.cos; const AC = Math.sin; const LC = Math.abs; var PC = Math.PI; var OC = 2 * PC; const RC = typeof Float32Array !== 'undefined'; const NC = []; var zC = (function () { function t (t) { this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []) } return t.prototype.increaseVersion = function () { this._version++ }, t.prototype.getVersion = function () { return this._version }, t.prototype.setScale = function (t, e, n) { n = n || 0, n > 0 && (this._ux = LC(n / sI / t) || 0, this._uy = LC(n / sI / e) || 0) }, t.prototype.setDPR = function (t) { this.dpr = t }, t.prototype.setContext = function (t) { this._ctx = t }, t.prototype.getContext = function () { return this._ctx }, t.prototype.beginPath = function () { return this._ctx && this._ctx.beginPath(), this.reset(), this }, t.prototype.reset = function () { this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++ }, t.prototype.moveTo = function (t, e) { return this._drawPendingPt(), this.addData(xC.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this }, t.prototype.lineTo = function (t, e) { const n = LC(t - this._xi); const i = LC(e - this._yi); const r = n > this._ux || i > this._uy; if (this.addData(xC.L, t, e), this._ctx && r && this._ctx.lineTo(t, e), r) this._xi = t, this._yi = e, this._pendingPtDist = 0; else { const o = n * n + i * i; o > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = e, this._pendingPtDist = o) } return this }, t.prototype.bezierCurveTo = function (t, e, n, i, r, o) { return this._drawPendingPt(), this.addData(xC.C, t, e, n, i, r, o), this._ctx && this._ctx.bezierCurveTo(t, e, n, i, r, o), this._xi = r, this._yi = o, this }, t.prototype.quadraticCurveTo = function (t, e, n, i) { return this._drawPendingPt(), this.addData(xC.Q, t, e, n, i), this._ctx && this._ctx.quadraticCurveTo(t, e, n, i), this._xi = n, this._yi = i, this }, t.prototype.arc = function (t, e, n, i, r, o) { this._drawPendingPt(), NC[0] = i, NC[1] = r, zo(NC, o), i = NC[0], r = NC[1]; const a = r - i; return this.addData(xC.A, t, e, n, n, i, a, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, n, i, r, o), this._xi = kC(r) * n + t, this._yi = AC(r) * n + e, this }, t.prototype.arcTo = function (t, e, n, i, r) { return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, e, n, i, r), this }, t.prototype.rect = function (t, e, n, i) { return this._drawPendingPt(), this._ctx && this._ctx.rect(t, e, n, i), this.addData(xC.R, t, e, n, i), this }, t.prototype.closePath = function () { this._drawPendingPt(), this.addData(xC.Z); const t = this._ctx; const e = this._x0; const n = this._y0; return t && t.closePath(), this._xi = e, this._yi = n, this }, t.prototype.fill = function (t) { t && t.fill(), this.toStatic() }, t.prototype.stroke = function (t) { t && t.stroke(), this.toStatic() }, t.prototype.len = function () { return this._len }, t.prototype.setData = function (t) { const e = t.length; this.data && this.data.length === e || !RC || (this.data = new Float32Array(e)); for (let n = 0; e > n; n++) this.data[n] = t[n]; this._len = e }, t.prototype.appendPath = function (t) { t instanceof Array || (t = [t]); for (var e = t.length, n = 0, i = this._len, r = 0; e > r; r++)n += t[r].len(); RC && this.data instanceof Float32Array && (this.data = new Float32Array(i + n)); for (var r = 0; e > r; r++) for (let o = t[r].data, a = 0; a < o.length; a++) this.data[i++] = o[a]; this._len = i }, t.prototype.addData = function () { if (this._saveData) { let t = this.data; this._len + arguments.length > t.length && (this._expandData(), t = this.data); for (let e = 0; e < arguments.length; e++)t[this._len++] = arguments[e] } }, t.prototype._drawPendingPt = function () { this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0) }, t.prototype._expandData = function () { if (!(this.data instanceof Array)) { for (var t = [], e = 0; e < this._len; e++)t[e] = this.data[e]; this.data = t } }, t.prototype.toStatic = function () { if (this._saveData) { this._drawPendingPt(); const t = this.data; t instanceof Array && (t.length = this._len, RC && this._len > 11 && (this.data = new Float32Array(t))) } }, t.prototype.getBoundingRect = function () { SC[0] = SC[1] = TC[0] = TC[1] = Number.MAX_VALUE, MC[0] = MC[1] = IC[0] = IC[1] = -Number.MAX_VALUE; let t; const e = this.data; let n = 0; let i = 0; let r = 0; let o = 0; for (t = 0; t < this._len;) { const a = e[t++]; const s = t === 1; switch (s && (n = e[t], i = e[t + 1], r = n, o = i), a) { case xC.M:n = r = e[t++], i = o = e[t++], TC[0] = r, TC[1] = o, IC[0] = r, IC[1] = o; break; case xC.L:Lo(n, i, e[t], e[t + 1], TC, IC), n = e[t++], i = e[t++]; break; case xC.C:Po(n, i, e[t++], e[t++], e[t++], e[t++], e[t], e[t + 1], TC, IC), n = e[t++], i = e[t++]; break; case xC.Q:Oo(n, i, e[t++], e[t++], e[t], e[t + 1], TC, IC), n = e[t++], i = e[t++]; break; case xC.A:var l = e[t++]; var u = e[t++]; var h = e[t++]; var c = e[t++]; var p = e[t++]; var d = e[t++] + p; t += 1; var f = !e[t++]; s && (r = kC(p) * h + l, o = AC(p) * c + u), Ro(l, u, h, c, p, d, f, TC, IC), n = kC(d) * h + l, i = AC(d) * c + u; break; case xC.R:r = n = e[t++], o = i = e[t++]; var g = e[t++]; var y = e[t++]; Lo(r, o, r + g, o + y, TC, IC); break; case xC.Z:n = r, i = o }me(SC, SC, TC), _e(MC, MC, IC) } return t === 0 && (SC[0] = SC[1] = MC[0] = MC[1] = 0), new $M(SC[0], SC[1], MC[0] - SC[0], MC[1] - SC[1]) }, t.prototype._calculateLength = function () { const t = this.data; const e = this._len; const n = this._ux; const i = this._uy; let r = 0; let o = 0; let a = 0; let s = 0; this._pathSegLen || (this._pathSegLen = []); for (var l = this._pathSegLen, u = 0, h = 0, c = 0; e > c;) { const p = t[c++]; const d = c === 1; d && (r = t[c], o = t[c + 1], a = r, s = o); let f = -1; switch (p) { case xC.M:r = a = t[c++], o = s = t[c++]; break; case xC.L:var g = t[c++]; var y = t[c++]; var v = g - r; var m = y - o; (LC(v) > n || LC(m) > i || c === e - 1) && (f = Math.sqrt(v * v + m * m), r = g, o = y); break; case xC.C:var _ = t[c++]; var x = t[c++]; var g = t[c++]; var y = t[c++]; var w = t[c++]; var b = t[c++]; f = vn(r, o, _, x, g, y, w, b, 10), r = w, o = b; break; case xC.Q:var _ = t[c++]; var x = t[c++]; var g = t[c++]; var y = t[c++]; f = Mn(r, o, _, x, g, y, 10), r = g, o = y; break; case xC.A:var S = t[c++]; var M = t[c++]; var T = t[c++]; var I = t[c++]; var C = t[c++]; var D = t[c++]; var k = D + C; c += 1; { !t[c++] }d && (a = kC(C) * T + S, s = AC(C) * I + M), f = DC(T, I) * CC(OC, Math.abs(D)), r = kC(k) * T + S, o = AC(k) * I + M; break; case xC.R:a = r = t[c++], s = o = t[c++]; var A = t[c++]; var L = t[c++]; f = 2 * A + 2 * L; break; case xC.Z:var v = a - r; var m = s - o; f = Math.sqrt(v * v + m * m), r = a, o = s }f >= 0 && (l[h++] = f, u += f) } return this._pathLen = u, u }, t.prototype.rebuildPath = function (t, e) { let n; let i; let r; let o; let a; let s; let l; let u; let h; let c; let p; const d = this.data; const f = this._ux; const g = this._uy; const y = this._len; const v = e < 1; let m = 0; let _ = 0; let x = 0; if (!v || (this._pathSegLen || this._calculateLength(), l = this._pathSegLen, u = this._pathLen, h = e * u))t:for (let w = 0; y > w;) { const b = d[w++]; const S = w === 1; switch (S && (r = d[w], o = d[w + 1], n = r, i = o), b !== xC.L && x > 0 && (t.lineTo(c, p), x = 0), b) { case xC.M:n = r = d[w++], i = o = d[w++], t.moveTo(r, o); break; case xC.L:a = d[w++], s = d[w++]; var M = LC(a - r); var T = LC(s - o); if (M > f || T > g) { if (v) { var I = l[_++]; if (m + I > h) { var C = (h - m) / I; t.lineTo(r * (1 - C) + a * C, o * (1 - C) + s * C); break t }m += I }t.lineTo(a, s), r = a, o = s, x = 0 } else { const D = M * M + T * T; D > x && (c = a, p = s, x = D) } break; case xC.C:var k = d[w++]; var A = d[w++]; var L = d[w++]; var P = d[w++]; var O = d[w++]; var R = d[w++]; if (v) { var I = l[_++]; if (m + I > h) { var C = (h - m) / I; gn(r, k, L, O, C, wC), gn(o, A, P, R, C, bC), t.bezierCurveTo(wC[1], bC[1], wC[2], bC[2], wC[3], bC[3]); break t }m += I }t.bezierCurveTo(k, A, L, P, O, R), r = O, o = R; break; case xC.Q:var k = d[w++]; var A = d[w++]; var L = d[w++]; var P = d[w++]; if (v) { var I = l[_++]; if (m + I > h) { var C = (h - m) / I; bn(r, k, L, C, wC), bn(o, A, P, C, bC), t.quadraticCurveTo(wC[1], bC[1], wC[2], bC[2]); break t }m += I }t.quadraticCurveTo(k, A, L, P), r = L, o = P; break; case xC.A:var N = d[w++]; var z = d[w++]; var B = d[w++]; var E = d[w++]; var V = d[w++]; var F = d[w++]; var H = d[w++]; var W = !d[w++]; var G = B > E ? B : E; var X = LC(B - E) > 0.001; var Y = V + F; var U = !1; if (v) { var I = l[_++]; m + I > h && (Y = V + F * (h - m) / I, U = !0), m += I } if (X && t.ellipse ? t.ellipse(N, z, B, E, H, V, Y, W) : t.arc(N, z, G, V, Y, W), U) break t; S && (n = kC(V) * B + N, i = AC(V) * E + z), r = kC(Y) * B + N, o = AC(Y) * E + z; break; case xC.R:n = r = d[w], i = o = d[w + 1], a = d[w++], s = d[w++]; var Z = d[w++]; var j = d[w++]; if (v) { var I = l[_++]; if (m + I > h) { let q = h - m; t.moveTo(a, s), t.lineTo(a + CC(q, Z), s), q -= Z, q > 0 && t.lineTo(a + Z, s + CC(q, j)), q -= j, q > 0 && t.lineTo(a + DC(Z - q, 0), s + j), q -= Z, q > 0 && t.lineTo(a, s + DC(j - q, 0)); break t }m += I }t.rect(a, s, Z, j); break; case xC.Z:if (v) { var I = l[_++]; if (m + I > h) { var C = (h - m) / I; t.lineTo(r * (1 - C) + n * C, o * (1 - C) + i * C); break t }m += I }t.closePath(), r = n, o = i } } }, t.prototype.clone = function () { const e = new t(); const n = this.data; return e.data = n.slice ? n.slice() : Array.prototype.slice.call(n), e._len = this._len, e }, t.CMD = xC, t.initDefaultProps = (function () { const e = t.prototype; e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0 }()), t }()); var BC = 2 * Math.PI; var EC = 2 * Math.PI; var VC = zC.CMD; var FC = 2 * Math.PI; var HC = 1e-4; var WC = [-1, -1, -1]; var GC = [-1, -1]; var XC = c({ fill: '#000', stroke: null, strokePercent: 1, fillOpacity: 1, strokeOpacity: 1, lineDashOffset: 0, lineWidth: 1, lineCap: 'butt', miterLimit: 10, strokeNoScale: !1, strokeFirst: !1 }, iC); const YC = { style: c({ fill: !0, stroke: !0, strokePercent: !0, fillOpacity: !0, strokeOpacity: !0, lineDashOffset: !0, lineWidth: !0, miterLimit: !0 }, rC.style) }; const UC = _I.concat(['invisible', 'culling', 'z', 'z2', 'zlevel', 'parent']); var ZC = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.update = function () { const e = this; t.prototype.update.call(this); const i = this.style; if (i.decal) { const r = this._decalEl = this._decalEl || new n(); r.buildPath === n.prototype.buildPath && (r.buildPath = function (t) { e.buildPath(t, e.shape) }), r.silent = !0; const o = r.style; for (const a in i)o[a] !== i[a] && (o[a] = i[a]); o.fill = i.fill ? i.decal : null, o.decal = null, o.shadowColor = null, i.strokeFirst && (o.stroke = null); for (let s = 0; s < UC.length; ++s)r[UC[s]] = this[UC[s]]; r.__dirty |= sT } else this._decalEl && (this._decalEl = null) }, n.prototype.getDecalElement = function () { return this._decalEl }, n.prototype._init = function (e) { const n = w(e); this.shape = this.getDefaultShape(); const i = this.getDefaultStyle(); i && this.useStyle(i); for (let r = 0; r < n.length; r++) { const o = n[r]; const a = e[o]; o === 'style' ? this.style ? h(this.style, a) : this.useStyle(a) : o === 'shape' ? h(this.shape, a) : t.prototype.attrKV.call(this, o, a) } this.style || this.useStyle({}) }, n.prototype.getDefaultStyle = function () { return null }, n.prototype.getDefaultShape = function () { return {} }, n.prototype.canBeInsideText = function () { return this.hasFill() }, n.prototype.getInsideTextFill = function () { const t = this.style.fill; if (t !== 'none') { if (I(t)) { const e = Un(t, 0); return e > 0.5 ? uI : e > 0.2 ? cI : hI } if (t) return hI } return uI }, n.prototype.getInsideTextStroke = function (t) { const e = this.style.fill; if (I(e)) { const n = this.__zr; const i = !(!n || !n.isDarkMode()); const r = Un(t, 0) < lI; if (i === r) return e } }, n.prototype.buildPath = function () {}, n.prototype.pathUpdated = function () { this.__dirty &= ~uT }, n.prototype.getUpdatedPathProxy = function (t) { return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path }, n.prototype.createPathProxy = function () { this.path = new zC(!1) }, n.prototype.hasStroke = function () { const t = this.style; const e = t.stroke; return !(e == null || e === 'none' || !(t.lineWidth > 0)) }, n.prototype.hasFill = function () { const t = this.style; const e = t.fill; return e != null && e !== 'none' }, n.prototype.getBoundingRect = function () { let t = this._rect; const e = this.style; const n = !t; if (n) { let i = !1; this.path || (i = !0, this.createPathProxy()); const r = this.path; (i || this.__dirty & uT) && (r.beginPath(), this.buildPath(r, this.shape, !1), this.pathUpdated()), t = r.getBoundingRect() } if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) { const o = this._rectStroke || (this._rectStroke = t.clone()); if (this.__dirty || n) { o.copy(t); const a = e.strokeNoScale ? this.getLineScale() : 1; let s = e.lineWidth; if (!this.hasFill()) { const l = this.strokeContainThreshold; s = Math.max(s, l == null ? 4 : l) }a > 1e-10 && (o.width += s / a, o.height += s / a, o.x -= s / a / 2, o.y -= s / a / 2) } return o } return t }, n.prototype.contain = function (t, e) { const n = this.transformCoordToLocal(t, e); const i = this.getBoundingRect(); const r = this.style; if (t = n[0], e = n[1], i.contain(t, e)) { const o = this.path; if (this.hasStroke()) { let a = r.lineWidth; const s = r.strokeNoScale ? this.getLineScale() : 1; if (s > 1e-10 && (this.hasFill() || (a = Math.max(a, this.strokeContainThreshold)), Ko(o, a / s, t, e))) return !0 } if (this.hasFill()) return qo(o, t, e) } return !1 }, n.prototype.dirtyShape = function () { this.__dirty |= uT, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw() }, n.prototype.dirty = function () { this.dirtyStyle(), this.dirtyShape() }, n.prototype.animateShape = function (t) { return this.animate('shape', t) }, n.prototype.updateDuringAnimation = function (t) { t === 'style' ? this.dirtyStyle() : t === 'shape' ? this.dirtyShape() : this.markRedraw() }, n.prototype.attrKV = function (e, n) { e === 'shape' ? this.setShape(n) : t.prototype.attrKV.call(this, e, n) }, n.prototype.setShape = function (t, e) { let n = this.shape; return n || (n = this.shape = {}), typeof t === 'string' ? n[t] = e : h(n, t), this.dirtyShape(), this }, n.prototype.shapeChanged = function () { return !!(this.__dirty & uT) }, n.prototype.createStyle = function (t) { return q(XC, t) }, n.prototype._innerSaveToNormal = function (e) { t.prototype._innerSaveToNormal.call(this, e); const n = this._normalState; e.shape && !n.shape && (n.shape = h({}, this.shape)) }, n.prototype._applyStateObj = function (e, n, i, r, o, a) { t.prototype._applyStateObj.call(this, e, n, i, r, o, a); let s; const l = !(n && r); if (n && n.shape ? o ? r ? s = n.shape : (s = h({}, i.shape), h(s, n.shape)) : (s = h({}, r ? this.shape : i.shape), h(s, n.shape)) : l && (s = i.shape), s) if (o) { this.shape = h({}, this.shape); for (var u = {}, c = w(s), p = 0; p < c.length; p++) { const d = c[p]; typeof s[d] === 'object' ? this.shape[d] = s[d] : u[d] = s[d] } this._transitionState(e, { shape: u }, a) } else this.shape = s, this.dirtyShape() }, n.prototype._mergeStates = function (e) { for (var n, i = t.prototype._mergeStates.call(this, e), r = 0; r < e.length; r++) { const o = e[r]; o.shape && (n = n || {}, this._mergeStyle(n, o.shape)) } return n && (i.shape = n), i }, n.prototype.getAnimationStyleProps = function () { return YC }, n.prototype.isZeroArea = function () { return !1 }, n.extend = function (t) { const i = (function (n) { function i (e) { const i = n.call(this, e) || this; return t.init && t.init.call(i, e), i } return e(i, n), i.prototype.getDefaultStyle = function () { return s(t.style) }, i.prototype.getDefaultShape = function () { return s(t.shape) }, i }(n)); for (const r in t) typeof t[r] === 'function' && (i.prototype[r] = t[r]); return i }, n.initDefaultProps = (function () { const t = n.prototype; t.type = 'path', t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = !1, t.autoBatch = !1, t.__dirty = sT | lT | uT }()), n }(sC)); const jC = c({ strokeFirst: !0, font: KS, x: 0, y: 0, textAlign: 'left', textBaseline: 'top', miterLimit: 2 }, XC); var qC = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.hasStroke = function () { const t = this.style; const e = t.stroke; return e != null && e !== 'none' && t.lineWidth > 0 }, n.prototype.hasFill = function () { const t = this.style; const e = t.fill; return e != null && e !== 'none' }, n.prototype.createStyle = function (t) { return q(jC, t) }, n.prototype.setBoundingRect = function (t) { this._rect = t }, n.prototype.getBoundingRect = function () { const t = this.style; if (!this._rect) { let e = t.text; e != null ? e += '' : e = ''; const n = Bi(e, t.font, t.textAlign, t.textBaseline); if (n.x += t.x || 0, n.y += t.y || 0, this.hasStroke()) { const i = t.lineWidth; n.x -= i / 2, n.y -= i / 2, n.width += i, n.height += i } this._rect = n } return this._rect }, n.initDefaultProps = (function () { const t = n.prototype; t.dirtyRectTolerance = 10 }()), n }(sC)); qC.prototype.type = 'tspan'; const KC = c({ x: 0, y: 0 }, iC); const $C = { style: c({ x: !0, y: !0, width: !0, height: !0, sx: !0, sy: !0, sWidth: !0, sHeight: !0 }, rC.style) }; var QC = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.createStyle = function (t) { return q(KC, t) }, n.prototype._getSize = function (t) { const e = this.style; const n = e[t]; if (n != null) return n; const i = $o(e.image) ? e.image : this.__image; if (!i) return 0; const r = t === 'width' ? 'height' : 'width'; const o = e[r]; return o == null ? i[t] : i[t] / i[r] * o }, n.prototype.getWidth = function () { return this._getSize('width') }, n.prototype.getHeight = function () { return this._getSize('height') }, n.prototype.getAnimationStyleProps = function () { return $C }, n.prototype.getBoundingRect = function () { const t = this.style; return this._rect || (this._rect = new $M(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect }, n }(sC)); QC.prototype.type = 'image'; var JC = Math.round; const tD = (function () { function t () { this.x = 0, this.y = 0, this.width = 0, this.height = 0 } return t }()); const eD = {}; var nD = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultShape = function () { return new tD() }, n.prototype.buildPath = function (t, e) { let n, i, r, o; if (this.subPixelOptimize) { const a = ta(eD, e, this.style); n = a.x, i = a.y, r = a.width, o = a.height, a.r = e.r, e = a } else n = e.x, i = e.y, r = e.width, o = e.height; e.r ? Qo(t, e) : t.rect(n, i, r, o) }, n.prototype.isZeroArea = function () { return !this.shape.width || !this.shape.height }, n }(ZC)); nD.prototype.type = 'rect'; const iD = { fill: '#000' }; const rD = 2; const oD = { style: c({ fill: !0, stroke: !0, fillOpacity: !0, strokeOpacity: !0, lineWidth: !0, fontSize: !0, lineHeight: !0, width: !0, height: !0, textShadowColor: !0, textShadowBlur: !0, textShadowOffsetX: !0, textShadowOffsetY: !0, backgroundColor: !0, padding: !0, borderColor: !0, borderWidth: !0, borderRadius: !0 }, rC.style) }; var aD = (function (t) {
    function n (e) { const n = t.call(this) || this; return n.type = 'text', n._children = [], n._defaultStyle = iD, n.attr(e), n } return e(n, t), n.prototype.childrenRef = function () { return this._children }, n.prototype.update = function () { t.prototype.update.call(this), this.styleChanged() && this._updateSubTexts(); for (let e = 0; e < this._children.length; e++) { const n = this._children[e]; n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible } }, n.prototype.updateTransform = function () { const e = this.innerTransformable; e ? (e.updateTransform(), e.transform && (this.transform = e.transform)) : t.prototype.updateTransform.call(this) }, n.prototype.getLocalTransform = function (e) { const n = this.innerTransformable; return n ? n.getLocalTransform(e) : t.prototype.getLocalTransform.call(this, e) }, n.prototype.getComputedTransform = function () { return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), t.prototype.getComputedTransform.call(this) }, n.prototype._updateSubTexts = function () { this._childCursor = 0, oa(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated() }, n.prototype.addSelfToZr = function (e) { t.prototype.addSelfToZr.call(this, e); for (let n = 0; n < this._children.length; n++) this._children[n].__zr = e }, n.prototype.removeSelfFromZr = function (e) {
      t.prototype.removeSelfFromZr.call(this, e); for (let n = 0; n < this._children.length; n++) this._children[n].__zr = null
    }, n.prototype.getBoundingRect = function () { if (this.styleChanged() && this._updateSubTexts(), !this._rect) { for (var t = new $M(0, 0, 0, 0), e = this._children, n = [], i = null, r = 0; r < e.length; r++) { const o = e[r]; const a = o.getBoundingRect(); const s = o.getLocalTransform(n); s ? (t.copy(a), t.applyTransform(s), i = i || t.clone(), i.union(t)) : (i = i || a.clone(), i.union(a)) } this._rect = i || t } return this._rect }, n.prototype.setDefaultTextStyle = function (t) { this._defaultStyle = t || iD }, n.prototype.setTextContent = function () {}, n.prototype._mergeStyle = function (t, e) { if (!e) return t; const n = e.rich; const i = t.rich || n && {}; return h(t, e), n && i ? (this._mergeRich(i, n), t.rich = i) : i && (t.rich = i), t }, n.prototype._mergeRich = function (t, e) { for (let n = w(e), i = 0; i < n.length; i++) { const r = n[i]; t[r] = t[r] || {}, h(t[r], e[r]) } }, n.prototype.getAnimationStyleProps = function () { return oD }, n.prototype._getOrCreateChild = function (t) { let e = this._children[this._childCursor]; return e && e instanceof t || (e = new t()), this._children[this._childCursor++] = e, e.__zr = this.__zr, e.parent = this, e }, n.prototype._updatePlainTexts = function () { const t = this.style; const e = t.font || KS; const n = t.padding; const i = ha(t); const r = So(i, t); const o = ca(t); const a = !!t.backgroundColor; const s = r.outerHeight; const l = r.outerWidth; const u = r.contentWidth; const h = r.lines; const c = r.lineHeight; const p = this._defaultStyle; const d = t.x || 0; const f = t.y || 0; const g = t.align || p.align || 'left'; const y = t.verticalAlign || p.verticalAlign || 'top'; let v = d; let m = Vi(f, r.contentHeight, y); if (o || n) { const _ = Ei(d, l, g); const x = Vi(f, s, y); o && this._renderBackground(t, t, _, x, l, s) }m += c / 2, n && (v = ua(d, g, n), y === 'top' ? m += n[0] : y === 'bottom' && (m -= n[2])); for (let w = 0, b = !1, S = (la('fill' in t ? t.fill : (b = !0, p.fill))), M = (sa('stroke' in t ? t.stroke : a || p.autoStroke && !b ? null : (w = rD, p.stroke))), T = t.textShadowBlur > 0, I = t.width != null && (t.overflow === 'truncate' || t.overflow === 'break' || t.overflow === 'breakAll'), C = r.calculatedLineHeight, D = 0; D < h.length; D++) { const k = this._getOrCreateChild(qC); const A = k.createStyle(); k.useStyle(A), A.text = h[D], A.x = v, A.y = m, g && (A.textAlign = g), A.textBaseline = 'middle', A.opacity = t.opacity, A.strokeFirst = !0, T && (A.shadowBlur = t.textShadowBlur || 0, A.shadowColor = t.textShadowColor || 'transparent', A.shadowOffsetX = t.textShadowOffsetX || 0, A.shadowOffsetY = t.textShadowOffsetY || 0), A.stroke = M, A.fill = S, M && (A.lineWidth = t.lineWidth || w, A.lineDash = t.lineDash, A.lineDashOffset = t.lineDashOffset || 0), A.font = e, ia(A, t), m += c, I && k.setBoundingRect(new $M(Ei(A.x, t.width, A.textAlign), Vi(A.y, C, A.textBaseline), u, C)) } }, n.prototype._updateRichTexts = function () { const t = this.style; const e = ha(t); const n = Mo(e, t); const i = n.width; const r = n.outerWidth; const o = n.outerHeight; const a = t.padding; const s = t.x || 0; const l = t.y || 0; const u = this._defaultStyle; const h = t.align || u.align; const c = t.verticalAlign || u.verticalAlign; const p = Ei(s, r, h); const d = Vi(l, o, c); let f = p; let g = d; a && (f += a[3], g += a[0]); const y = f + i; ca(t) && this._renderBackground(t, t, p, d, r, o); for (let v = !!t.backgroundColor, m = 0; m < n.lines.length; m++) { for (var _ = n.lines[m], x = _.tokens, w = x.length, b = _.lineHeight, S = _.width, M = 0, T = f, I = y, C = w - 1, D = void 0; w > M && (D = x[M], !D.align || D.align === 'left');) this._placeToken(D, t, b, g, T, 'left', v), S -= D.width, T += D.width, M++; for (;C >= 0 && (D = x[C], D.align === 'right');) this._placeToken(D, t, b, g, I, 'right', v), S -= D.width, I -= D.width, C--; for (T += (i - (T - f) - (y - I) - S) / 2; C >= M;)D = x[M], this._placeToken(D, t, b, g, T + D.width / 2, 'center', v), T += D.width, M++; g += b } }, n.prototype._placeToken = function (t, e, n, i, r, o, a) { const s = e.rich[t.styleName] || {}; s.text = t.text; const l = t.verticalAlign; let u = i + n / 2; l === 'top' ? u = i + t.height / 2 : l === 'bottom' && (u = i + n - t.height / 2); const h = !t.isLineHolder && ca(s); h && this._renderBackground(s, e, o === 'right' ? r - t.width : o === 'center' ? r - t.width / 2 : r, u - t.height / 2, t.width, t.height); const c = !!s.backgroundColor; const p = t.textPadding; p && (r = ua(r, o, p), u -= t.height / 2 - p[0] - t.innerHeight / 2); const d = this._getOrCreateChild(qC); const f = d.createStyle(); d.useStyle(f); const g = this._defaultStyle; let y = !1; let v = 0; const m = la('fill' in s ? s.fill : 'fill' in e ? e.fill : (y = !0, g.fill)); const _ = sa('stroke' in s ? s.stroke : 'stroke' in e ? e.stroke : c || a || g.autoStroke && !y ? null : (v = rD, g.stroke)); const x = s.textShadowBlur > 0 || e.textShadowBlur > 0; f.text = t.text, f.x = r, f.y = u, x && (f.shadowBlur = s.textShadowBlur || e.textShadowBlur || 0, f.shadowColor = s.textShadowColor || e.textShadowColor || 'transparent', f.shadowOffsetX = s.textShadowOffsetX || e.textShadowOffsetX || 0, f.shadowOffsetY = s.textShadowOffsetY || e.textShadowOffsetY || 0), f.textAlign = o, f.textBaseline = 'middle', f.font = t.font || KS, f.opacity = V(s.opacity, e.opacity, 1), ia(f, s), _ && (f.lineWidth = V(s.lineWidth, e.lineWidth, v), f.lineDash = E(s.lineDash, e.lineDash), f.lineDashOffset = e.lineDashOffset || 0, f.stroke = _), m && (f.fill = m); const w = t.contentWidth; const b = t.contentHeight; d.setBoundingRect(new $M(Ei(f.x, w, f.textAlign), Vi(f.y, b, f.textBaseline), w, b)) }, n.prototype._renderBackground = function (t, e, n, i, r, o) { let a; let s; const l = t.backgroundColor; const u = t.borderWidth; const h = t.borderColor; const c = l && l.image; const p = l && !c; const d = t.borderRadius; const f = this; if (p || t.lineHeight || u && h) { a = this._getOrCreateChild(nD), a.useStyle(a.createStyle()), a.style.fill = null; const g = a.shape; g.x = n, g.y = i, g.width = r, g.height = o, g.r = d, a.dirtyShape() } if (p) { var y = a.style; y.fill = l || null, y.fillOpacity = E(t.fillOpacity, 1) } else if (c) { s = this._getOrCreateChild(QC), s.onload = function () { f.dirtyStyle() }; const v = s.style; v.image = l.image, v.x = n, v.y = i, v.width = r, v.height = o } if (u && h) { var y = a.style; y.lineWidth = u, y.stroke = h, y.strokeOpacity = E(t.strokeOpacity, 1), y.lineDash = t.borderDash, y.lineDashOffset = t.borderDashOffset || 0, a.strokeContainThreshold = 0, a.hasFill() && a.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2) } const m = (a || s).style; m.shadowBlur = t.shadowBlur || 0, m.shadowColor = t.shadowColor || 'transparent', m.shadowOffsetX = t.shadowOffsetX || 0, m.shadowOffsetY = t.shadowOffsetY || 0, m.opacity = V(t.opacity, e.opacity, 1) }, n.makeFont = function (t) { let e = ''; return ra(t) && (e = [t.fontStyle, t.fontWeight, na(t.fontSize), t.fontFamily || 'sans-serif'].join(' ')), e && G(e) || t.textFont || t.font }, n
  }(sC)); var sD = { left: !0, right: 1, center: 1 }; var lD = { top: 1, bottom: 1, middle: 1 }; var uD = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily']; var hD = qr(); const cD = function (t, e, n, i) { if (i) { const r = hD(i); r.dataIndex = n, r.dataType = e, r.seriesIndex = t, i.type === 'group' && i.traverse(function (i) { const r = hD(i); r.seriesIndex = t, r.dataIndex = n, r.dataType = e }) } }; var pD = 1; var dD = {}; var fD = qr(); var gD = qr(); var yD = 0; var vD = 1; var mD = 2; var _D = ['emphasis', 'blur', 'select']; var xD = ['normal', 'emphasis', 'blur', 'select']; var wD = 10; var bD = 9; var SD = 'highlight'; var MD = 'downplay'; var TD = 'select'; var ID = 'unselect'; var CD = 'toggleSelect'; var DD = new CT(100); var kD = ['emphasis', 'blur', 'select']; var AD = { itemStyle: 'getItemStyle', lineStyle: 'getLineStyle', areaStyle: 'getAreaStyle' }; var LD = zC.CMD; var PD = [[], [], []]; var OD = Math.sqrt; var RD = Math.atan2; var ND = Math.sqrt; var zD = Math.sin; var BD = Math.cos; var ED = Math.PI; var VD = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi; var FD = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; var HD = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.applyTransform = function () {}, n }(ZC)); const WD = (function () { function t () { this.cx = 0, this.cy = 0, this.r = 0 } return t }()); const GD = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultShape = function () { return new WD() }, n.prototype.buildPath = function (t, e) { t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI) }, n }(ZC)); GD.prototype.type = 'circle'; const XD = (function () { function t () { this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0 } return t }()); const YD = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultShape = function () { return new XD() }, n.prototype.buildPath = function (t, e) { const n = 0.5522848; const i = e.cx; const r = e.cy; const o = e.rx; const a = e.ry; const s = o * n; const l = a * n; t.moveTo(i - o, r), t.bezierCurveTo(i - o, r - l, i - s, r - a, i, r - a), t.bezierCurveTo(i + s, r - a, i + o, r - l, i + o, r), t.bezierCurveTo(i + o, r + l, i + s, r + a, i, r + a), t.bezierCurveTo(i - s, r + a, i - o, r + l, i - o, r), t.closePath() }, n }(ZC)); YD.prototype.type = 'ellipse'; var UD = Math.PI; var ZD = 2 * UD; var jD = Math.sin; var qD = Math.cos; var KD = Math.acos; var $D = Math.atan2; var QD = Math.abs; var JD = Math.sqrt; var tk = Math.max; var ek = Math.min; var nk = 1e-4; const ik = (function () { function t () { this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = 2 * Math.PI, this.clockwise = !0, this.cornerRadius = 0 } return t }()); var rk = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultShape = function () { return new ik() }, n.prototype.buildPath = function (t, e) { xs(t, e) }, n.prototype.isZeroArea = function () { return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0 }, n }(ZC)); rk.prototype.type = 'sector'; const ok = (function () { function t () { this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0 } return t }()); const ak = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultShape = function () { return new ok() }, n.prototype.buildPath = function (t, e) { const n = e.cx; const i = e.cy; const r = 2 * Math.PI; t.moveTo(n + e.r, i), t.arc(n, i, e.r, 0, r, !1), t.moveTo(n + e.r0, i), t.arc(n, i, e.r0, 0, r, !0) }, n }(ZC)); ak.prototype.type = 'ring'; const sk = (function () { function t () { this.points = null, this.smooth = 0, this.smoothConstraint = null } return t }()); const lk = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultShape = function () { return new sk() }, n.prototype.buildPath = function (t, e) { bs(t, e, !0) }, n }(ZC)); lk.prototype.type = 'polygon'; const uk = (function () { function t () { this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null } return t }()); var hk = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultStyle = function () { return { stroke: '#000', fill: null } }, n.prototype.getDefaultShape = function () { return new uk() }, n.prototype.buildPath = function (t, e) { bs(t, e, !1) }, n }(ZC)); hk.prototype.type = 'polyline'; const ck = {}; const pk = (function () { function t () { this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1 } return t }()); var dk = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultStyle = function () { return { stroke: '#000', fill: null } }, n.prototype.getDefaultShape = function () { return new pk() }, n.prototype.buildPath = function (t, e) { let n, i, r, o; if (this.subPixelOptimize) { const a = Jo(ck, e, this.style); n = a.x1, i = a.y1, r = a.x2, o = a.y2 } else n = e.x1, i = e.y1, r = e.x2, o = e.y2; const s = e.percent; s !== 0 && (t.moveTo(n, i), s < 1 && (r = n * (1 - s) + r * s, o = i * (1 - s) + o * s), t.lineTo(r, o)) }, n.prototype.pointAt = function (t) { const e = this.shape; return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t] }, n }(ZC)); dk.prototype.type = 'line'; const fk = []; const gk = (function () { function t () { this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1 } return t }()); var yk = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultStyle = function () { return { stroke: '#000', fill: null } }, n.prototype.getDefaultShape = function () { return new gk() }, n.prototype.buildPath = function (t, e) { const n = e.x1; const i = e.y1; let r = e.x2; let o = e.y2; let a = e.cpx1; let s = e.cpy1; let l = e.cpx2; let u = e.cpy2; const h = e.percent; h !== 0 && (t.moveTo(n, i), l == null || u == null ? (h < 1 && (bn(n, a, r, h, fk), a = fk[1], r = fk[2], bn(i, s, o, h, fk), s = fk[1], o = fk[2]), t.quadraticCurveTo(a, s, r, o)) : (h < 1 && (gn(n, a, l, r, h, fk), a = fk[1], l = fk[2], r = fk[3], gn(i, s, u, o, h, fk), s = fk[1], u = fk[2], o = fk[3]), t.bezierCurveTo(a, s, l, u, r, o))) }, n.prototype.pointAt = function (t) { return Ss(this.shape, t, !1) }, n.prototype.tangentAt = function (t) { const e = Ss(this.shape, t, !0); return pe(e, e) }, n }(ZC)); yk.prototype.type = 'bezier-curve'; const vk = (function () { function t () { this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = 2 * Math.PI, this.clockwise = !0 } return t }()); var mk = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultStyle = function () { return { stroke: '#000', fill: null } }, n.prototype.getDefaultShape = function () { return new vk() }, n.prototype.buildPath = function (t, e) { const n = e.cx; const i = e.cy; const r = Math.max(e.r, 0); const o = e.startAngle; const a = e.endAngle; const s = e.clockwise; const l = Math.cos(o); const u = Math.sin(o); t.moveTo(l * r + n, u * r + i), t.arc(n, i, r, o, a, !s) }, n }(ZC)); mk.prototype.type = 'arc'; var _k = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = 'compound', e } return e(n, t), n.prototype._updatePathDirty = function () { for (var t = this.shape.paths, e = this.shapeChanged(), n = 0; n < t.length; n++)e = e || t[n].shapeChanged(); e && this.dirtyShape() }, n.prototype.beforeBrush = function () { this._updatePathDirty(); for (let t = this.shape.paths || [], e = this.getGlobalScale(), n = 0; n < t.length; n++)t[n].path || t[n].createPathProxy(), t[n].path.setScale(e[0], e[1], t[n].segmentIgnoreThreshold) }, n.prototype.buildPath = function (t, e) { for (let n = e.paths || [], i = 0; i < n.length; i++)n[i].buildPath(t, n[i].shape, !0) }, n.prototype.afterBrush = function () { for (let t = this.shape.paths || [], e = 0; e < t.length; e++)t[e].pathUpdated() }, n.prototype.getBoundingRect = function () { return this._updatePathDirty.call(this), ZC.prototype.getBoundingRect.call(this) }, n }(ZC)); const xk = (function () { function t (t) { this.colorStops = t || [] } return t.prototype.addColorStop = function (t, e) { this.colorStops.push({ offset: t, color: e }) }, t }()); const wk = (function (t) { function n (e, n, i, r, o, a) { const s = t.call(this, o) || this; return s.x = e == null ? 0 : e, s.y = n == null ? 0 : n, s.x2 = i == null ? 1 : i, s.y2 = r == null ? 0 : r, s.type = 'linear', s.global = a || !1, s } return e(n, t), n }(xk)); const bk = (function (t) { function n (e, n, i, r, o) { const a = t.call(this, r) || this; return a.x = e == null ? 0.5 : e, a.y = n == null ? 0.5 : n, a.r = i == null ? 0.5 : i, a.type = 'radial', a.global = o || !1, a } return e(n, t), n }(xk)); const Sk = [0, 0]; const Mk = [0, 0]; const Tk = new WM(); const Ik = new WM(); var Ck = (function () { function t (t, e) { this._corners = [], this._axes = [], this._origin = [0, 0]; for (var n = 0; n < 4; n++) this._corners[n] = new WM(); for (var n = 0; n < 2; n++) this._axes[n] = new WM(); t && this.fromBoundingRect(t, e) } return t.prototype.fromBoundingRect = function (t, e) { const n = this._corners; const i = this._axes; const r = t.x; const o = t.y; const a = r + t.width; const s = o + t.height; if (n[0].set(r, o), n[1].set(a, o), n[2].set(a, s), n[3].set(r, s), e) for (var l = 0; l < 4; l++)n[l].transform(e); WM.sub(i[0], n[1], n[0]), WM.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize(); for (var l = 0; l < 2; l++) this._origin[l] = i[l].dot(n[0]) }, t.prototype.intersect = function (t, e) { let n = !0; const i = !e; return Tk.set(1 / 0, 1 / 0), Ik.set(0, 0), !this._intersectCheckOneSide(this, t, Tk, Ik, i, 1) && (n = !1, i) ? n : !this._intersectCheckOneSide(t, this, Tk, Ik, i, -1) && (n = !1, i) ? n : (i || WM.copy(e, n ? Tk : Ik), n) }, t.prototype._intersectCheckOneSide = function (t, e, n, i, r, o) { for (var a = !0, s = 0; s < 2; s++) { const l = this._axes[s]; if (this._getProjMinMaxOnAxis(s, t._corners, Sk), this._getProjMinMaxOnAxis(s, e._corners, Mk), Sk[1] < Mk[0] || Sk[0] > Mk[1]) { if (a = !1, r) return a; var u = Math.abs(Mk[0] - Sk[1]); var h = Math.abs(Sk[0] - Mk[1]); Math.min(u, h) > i.len() && (h > u ? WM.scale(i, l, -u * o) : WM.scale(i, l, h * o)) } else if (n) { var u = Math.abs(Mk[0] - Sk[1]); var h = Math.abs(Sk[0] - Mk[1]); Math.min(u, h) < n.len() && (h > u ? WM.scale(n, l, u * o) : WM.scale(n, l, -h * o)) } } return a }, t.prototype._getProjMinMaxOnAxis = function (t, e, n) { for (var i = this._axes[t], r = this._origin, o = e[0].dot(i) + r[t], a = o, s = o, l = 1; l < e.length; l++) { const u = e[l].dot(i) + r[t]; a = Math.min(u, a), s = Math.max(u, s) }n[0] = a, n[1] = s }, t }()); const Dk = []; const kk = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.notClear = !0, e.incremental = !0, e._displayables = [], e._temporaryDisplayables = [], e._cursor = 0, e } return e(n, t), n.prototype.traverse = function (t, e) { t.call(e, this) }, n.prototype.useStyle = function () { this.style = {} }, n.prototype.getCursor = function () { return this._cursor }, n.prototype.innerAfterBrush = function () { this._cursor = this._displayables.length }, n.prototype.clearDisplaybles = function () { this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1 }, n.prototype.clearTemporalDisplayables = function () { this._temporaryDisplayables = [] }, n.prototype.addDisplayable = function (t, e) { e ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw() }, n.prototype.addDisplayables = function (t, e) { e = e || !1; for (let n = 0; n < t.length; n++) this.addDisplayable(t[n], e) }, n.prototype.getDisplayables = function () { return this._displayables }, n.prototype.getTemporalDisplayables = function () { return this._temporaryDisplayables }, n.prototype.eachPendingDisplayable = function (t) { for (var e = this._cursor; e < this._displayables.length; e++)t && t(this._displayables[e]); for (var e = 0; e < this._temporaryDisplayables.length; e++)t && t(this._temporaryDisplayables[e]) }, n.prototype.update = function () { this.updateTransform(); for (var t = this._cursor; t < this._displayables.length; t++) { var e = this._displayables[t]; e.parent = this, e.update(), e.parent = null } for (var t = 0; t < this._temporaryDisplayables.length; t++) { var e = this._temporaryDisplayables[t]; e.parent = this, e.update(), e.parent = null } }, n.prototype.getBoundingRect = function () { if (!this._rect) { for (var t = new $M(1 / 0, 1 / 0, -1 / 0, -1 / 0), e = 0; e < this._displayables.length; e++) { const n = this._displayables[e]; const i = n.getBoundingRect().clone(); n.needLocalTransform() && i.applyTransform(n.getLocalTransform(Dk)), t.union(i) } this._rect = t } return this._rect }, n.prototype.contain = function (t, e) { const n = this.transformCoordToLocal(t, e); const i = this.getBoundingRect(); if (i.contain(n[0], n[1])) for (let r = 0; r < this._displayables.length; r++) { const o = this._displayables[r]; if (o.contain(t, e)) return !0 } return !1 }, n }(sC)); var Ak = qr(); var Lk = Math.max; var Pk = Math.min; var Ok = {}; var Rk = gs; const Nk = ys; const zk = ea; Ns('circle', GD), Ns('ellipse', YD), Ns('sector', rk), Ns('ring', ak), Ns('polygon', lk), Ns('polyline', hk), Ns('rect', nD), Ns('line', dk), Ns('bezierCurve', yk), Ns('arc', mk); const Bk = (Object.freeze || Object)({ updateProps: Is, initProps: Cs, removeElement: ks, removeElementWithFadeOut: Ls, isElementRemoved: Ds, extendShape: Os, extendPath: Rs, registerShape: Ns, getShapeClass: zs, makePath: Bs, makeImage: Es, mergePath: Nk, resizePath: Fs, subPixelOptimizeLine: Hs, subPixelOptimizeRect: Ws, subPixelOptimize: zk, getTransform: Gs, applyTransform: Xs, transformDirection: Ys, groupTransition: js, clipPointsByRect: qs, clipRectByRect: Ks, createIcon: $s, linePolygonIntersect: Qs, lineLineIntersect: Js, setTooltipConfig: nl, traverseElements: rl, Group: CI, Image: QC, Text: aD, Circle: GD, Ellipse: YD, Sector: rk, Ring: ak, Polygon: lk, Polyline: hk, Rect: nD, Line: dk, BezierCurve: yk, Arc: mk, IncrementalDisplayable: kk, CompoundPath: _k, LinearGradient: wk, RadialGradient: bk, BoundingRect: $M, OrientedBoundingRect: Ck, Point: WM, Path: ZC }); var Ek = {}; var Vk = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY']; var Fk = ['align', 'lineHeight', 'width', 'height', 'tag', 'verticalAlign']; var Hk = ['padding', 'borderWidth', 'borderRadius', 'borderDashOffset', 'backgroundColor', 'borderColor', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']; var Wk = qr(); const Gk = ['textStyle', 'color']; const Xk = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'padding', 'lineHeight', 'rich', 'width', 'height', 'overflow']; const Yk = new aD(); const Uk = (function () { function t () {} return t.prototype.getTextColor = function (t) { const e = this.ecModel; return this.getShallow('color') || (!t && e ? e.get(Gk) : null) }, t.prototype.getFont = function () { return fl({ fontStyle: this.getShallow('fontStyle'), fontWeight: this.getShallow('fontWeight'), fontSize: this.getShallow('fontSize'), fontFamily: this.getShallow('fontFamily') }, this.ecModel) }, t.prototype.getTextRect = function (t) { for (var e = { text: t, verticalAlign: this.getShallow('verticalAlign') || this.getShallow('baseline') }, n = 0; n < Xk.length; n++)e[Xk[n]] = this.getShallow(Xk[n]); return Yk.useStyle(e), Yk.update(), Yk.getBoundingRect() }, t }()); const Zk = [['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'type'], ['lineDashOffset', 'dashOffset'], ['lineCap', 'cap'], ['lineJoin', 'join'], ['miterLimit']]; const jk = fo(Zk); const qk = (function () { function t () {} return t.prototype.getLineStyle = function (t) { return jk(this, t) }, t }()); const Kk = [['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'borderType'], ['lineDashOffset', 'borderDashOffset'], ['lineCap', 'borderCap'], ['lineJoin', 'borderJoin'], ['miterLimit', 'borderMiterLimit']]; const $k = fo(Kk); const Qk = (function () { function t () {} return t.prototype.getItemStyle = function (t, e) { return $k(this, t, e) }, t }()); var Jk = (function () { function t (t, e, n) { this.parentModel = e, this.ecModel = n, this.option = t } return t.prototype.init = function () { for (let t = [], e = 3; e < arguments.length; e++)t[e - 3] = arguments[e] }, t.prototype.mergeOption = function (t) { l(this.option, t, !0) }, t.prototype.get = function (t, e) { return t == null ? this.option : this._doGet(this.parsePath(t), !e && this.parentModel) }, t.prototype.getShallow = function (t, e) { const n = this.option; let i = n == null ? n : n[t]; if (i == null && !e) { const r = this.parentModel; r && (i = r.getShallow(t)) } return i }, t.prototype.getModel = function (e, n) { const i = e != null; const r = i ? this.parsePath(e) : null; const o = i ? this._doGet(r) : this.option; return n = n || this.parentModel && this.parentModel.getModel(this.resolveParentPath(r)), new t(o, n, this.ecModel) }, t.prototype.isEmpty = function () { return this.option == null }, t.prototype.restoreData = function () {}, t.prototype.clone = function () { const t = this.constructor; return new t(s(this.option)) }, t.prototype.parsePath = function (t) { return typeof t === 'string' ? t.split('.') : t }, t.prototype.resolveParentPath = function (t) { return t }, t.prototype.isAnimationEnabled = function () { if (!ZS.node && this.option) { if (this.option.animation != null) return !!this.option.animation; if (this.parentModel) return this.parentModel.isAnimationEnabled() } }, t.prototype._doGet = function (t, e) { let n = this.option; if (!t) return n; for (let i = 0; i < t.length && (!t[i] || (n = n && typeof n === 'object' ? n[t[i]] : null, n != null)); i++);return n == null && e && (n = e._doGet(this.resolveParentPath(t), e.parentModel)), n }, t }()); ao(Jk), uo(Jk), f(Jk, qk), f(Jk, Qk), f(Jk, qI), f(Jk, Uk); var tA = Math.round(10 * Math.random()); const eA = { time: { month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthAbbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], dayOfWeekAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] }, legend: { selector: { all: 'All', inverse: 'Inv' } }, toolbox: { brush: { title: { rect: 'Box Select', polygon: 'Lasso Select', lineX: 'Horizontally Select', lineY: 'Vertically Select', keep: 'Keep Selections', clear: 'Clear Selections' } }, dataView: { title: 'Data View', lang: ['Data View', 'Close', 'Refresh'] }, dataZoom: { title: { zoom: 'Zoom', back: 'Zoom Reset' } }, magicType: { title: { line: 'Switch to Line Chart', bar: 'Switch to Bar Chart', stack: 'Stack', tiled: 'Tile' } }, restore: { title: 'Restore' }, saveAsImage: { title: 'Save as Image', lang: ['Right Click to Save Image'] } }, series: { typeNames: { pie: 'Pie chart', bar: 'Bar chart', line: 'Line chart', scatter: 'Scatter plot', effectScatter: 'Ripple scatter plot', radar: 'Radar chart', tree: 'Tree', treemap: 'Treemap', boxplot: 'Boxplot', candlestick: 'Candlestick', k: 'K line chart', heatmap: 'Heat map', map: 'Map', parallel: 'Parallel coordinate map', lines: 'Line graph', graph: 'Relationship graph', sankey: 'Sankey diagram', funnel: 'Funnel chart', gauge: 'Gauge', pictorialBar: 'Pictorial bar', themeRiver: 'Theme River Map', sunburst: 'Sunburst' } }, aria: { general: { withTitle: 'This is a chart about "{title}"', withoutTitle: 'This is a chart' }, series: { single: { prefix: '', withName: ' with type {seriesType} named {seriesName}.', withoutName: ' with type {seriesType}.' }, multiple: { prefix: '. It consists of {seriesCount} series count.', withName: ' The {seriesId} series is a {seriesType} representing {seriesName}.', withoutName: ' The {seriesId} series is a {seriesType}.', separator: { middle: '', end: '' } } }, data: { allData: 'The data is as follows: ', partialData: 'The first {displayCnt} items are: ', withName: 'the data for {name} is {value}', withoutName: '{value}', separator: { middle: ', ', end: '. ' } } } }; const nA = { time: { month: ['ä¸€æœˆ', 'äºŒæœˆ', 'ä¸‰æœˆ', 'å››æœˆ', 'äº”æœˆ', 'å…­æœˆ', 'ä¸ƒæœˆ', 'å…«æœˆ', 'ä¹æœˆ', 'åæœˆ', 'åä¸€æœˆ', 'åäºŒæœˆ'], monthAbbr: ['1æœˆ', '2æœˆ', '3æœˆ', '4æœˆ', '5æœˆ', '6æœˆ', '7æœˆ', '8æœˆ', '9æœˆ', '10æœˆ', '11æœˆ', '12æœˆ'], dayOfWeek: ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'], dayOfWeekAbbr: ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­'] }, legend: { selector: { all: 'å…¨é€‰', inverse: 'åé€‰' } }, toolbox: { brush: { title: { rect: 'çŸ©å½¢é€‰æ‹©', polygon: 'åœˆé€‰', lineX: 'æ¨ªå‘é€‰æ‹©', lineY: 'çºµå‘é€‰æ‹©', keep: 'ä¿æŒé€‰æ‹©', clear: 'æ¸…é™¤é€‰æ‹©' } }, dataView: { title: 'æ•°æ®è§†å›¾', lang: ['æ•°æ®è§†å›¾', 'å…³é—­', 'åˆ·æ–°'] }, dataZoom: { title: { zoom: 'åŒºåŸŸç¼©æ”¾', back: 'åŒºåŸŸç¼©æ”¾è¿˜åŽŸ' } }, magicType: { title: { line: 'åˆ‡æ¢ä¸ºæŠ˜çº¿å›¾', bar: 'åˆ‡æ¢ä¸ºæŸ±çŠ¶å›¾', stack: 'åˆ‡æ¢ä¸ºå †å ', tiled: 'åˆ‡æ¢ä¸ºå¹³é“º' } }, restore: { title: 'è¿˜åŽŸ' }, saveAsImage: { title: 'ä¿å­˜ä¸ºå›¾ç‰‡', lang: ['å³é”®å¦å­˜ä¸ºå›¾ç‰‡'] } }, series: { typeNames: { pie: 'é¥¼å›¾', bar: 'æŸ±çŠ¶å›¾', line: 'æŠ˜çº¿å›¾', scatter: 'æ•£ç‚¹å›¾', effectScatter: 'æ¶Ÿæ¼ªæ•£ç‚¹å›¾', radar: 'é›·è¾¾å›¾', tree: 'æ ‘å›¾', treemap: 'çŸ©å½¢æ ‘å›¾', boxplot: 'ç®±åž‹å›¾', candlestick: 'Kçº¿å›¾', k: 'Kçº¿å›¾', heatmap: 'çƒ­åŠ›å›¾', map: 'åœ°å›¾', parallel: 'å¹³è¡Œåæ ‡å›¾', lines: 'çº¿å›¾', graph: 'å…³ç³»å›¾', sankey: 'æ¡‘åŸºå›¾', funnel: 'æ¼æ–—å›¾', gauge: 'ä»ªè¡¨ç›˜å›¾', pictorialBar: 'è±¡å½¢æŸ±å›¾', themeRiver: 'ä¸»é¢˜æ²³æµå›¾', sunburst: 'æ—­æ—¥å›¾' } }, aria: { general: { withTitle: 'è¿™æ˜¯ä¸€ä¸ªå…³äºŽâ€œ{title}â€çš„å›¾è¡¨ã€‚', withoutTitle: 'è¿™æ˜¯ä¸€ä¸ªå›¾è¡¨ï¼Œ' }, series: { single: { prefix: '', withName: 'å›¾è¡¨ç±»åž‹æ˜¯{seriesType}ï¼Œè¡¨ç¤º{seriesName}ã€‚', withoutName: 'å›¾è¡¨ç±»åž‹æ˜¯{seriesType}ã€‚' }, multiple: { prefix: 'å®ƒç”±{seriesCount}ä¸ªå›¾è¡¨ç³»åˆ—ç»„æˆã€‚', withName: 'ç¬¬{seriesId}ä¸ªç³»åˆ—æ˜¯ä¸€ä¸ªè¡¨ç¤º{seriesName}çš„{seriesType}ï¼Œ', withoutName: 'ç¬¬{seriesId}ä¸ªç³»åˆ—æ˜¯ä¸€ä¸ª{seriesType}ï¼Œ', separator: { middle: 'ï¼›', end: 'ã€‚' } } }, data: { allData: 'å…¶æ•°æ®æ˜¯â€”â€”', partialData: 'å…¶ä¸­ï¼Œå‰{displayCnt}é¡¹æ˜¯â€”â€”', withName: '{name}çš„æ•°æ®æ˜¯{value}', withoutName: '{value}', separator: { middle: 'ï¼Œ', end: '' } } } }; var iA = 'ZH'; var rA = 'EN'; var oA = rA; var aA = {}; var sA = {}; var lA = ZS.domSupported ? (function () { const t = (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase(); return t.indexOf(iA) > -1 ? iA : oA }()) : oA; xl(rA, eA), xl(iA, nA); var uA = 1e3; var hA = 60 * uA; var cA = 60 * hA; var pA = 24 * cA; const dA = 365 * pA; var fA = { year: '{yyyy}', month: '{MMM}', day: '{d}', hour: '{HH}:{mm}', minute: '{HH}:{mm}', second: '{HH}:{mm}:{ss}', millisecond: '{HH}:{mm}:{ss} {SSS}', none: '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}' }; const gA = '{yyyy}-{MM}-{dd}'; const yA = { year: '{yyyy}', month: '{yyyy}-{MM}', day: gA, hour: gA + ' ' + fA.hour, minute: gA + ' ' + fA.minute, second: gA + ' ' + fA.second, millisecond: fA.none }; var vA = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond']; var mA = ['year', 'half-year', 'quarter', 'month', 'week', 'half-week', 'day', 'half-day', 'quarter-day', 'hour', 'minute', 'second', 'millisecond']; var _A = H; var xA = ['a', 'b', 'c', 'd', 'e', 'f', 'g']; var wA = function (t, e) { return '{' + t + (e == null ? '' : e) + '}' }; var bA = y; var SA = ['left', 'right', 'top', 'bottom', 'width', 'height']; var MA = [['width', 'left', 'right'], ['height', 'top', 'bottom']]; var TA = iu; const IA = (S(iu, 'vertical'), S(iu, 'horizontal'), qr()); var CA = (function (t) { function n (e, n, i) { const r = t.call(this, e, n, i) || this; return r.uid = yl('ec_cpt_model'), r } return e(n, t), n.prototype.init = function (t, e, n) { this.mergeDefaultAndTheme(t, n) }, n.prototype.mergeDefaultAndTheme = function (t, e) { const n = su(this); const i = n ? uu(t) : {}; const r = e.getTheme(); l(t, r.get(this.mainType)), l(t, this.getDefaultOption()), n && lu(t, i, n) }, n.prototype.mergeOption = function (t) { l(this.option, t, !0); const e = su(this); e && lu(this.option, t, e) }, n.prototype.optionUpdated = function () {}, n.prototype.getDefaultOption = function () { const t = this.constructor; if (!oo(t)) return t.defaultOption; const e = IA(this); if (!e.defaultOption) { for (var n = [], i = t; i;) { const r = i.prototype.defaultOption; r && n.push(r), i = i.superClass } for (var o = {}, a = n.length - 1; a >= 0; a--)o = l(o, n[a], !0); e.defaultOption = o } return e.defaultOption }, n.prototype.getReferringComponents = function (t, e) { const n = t + 'Index'; const i = t + 'Id'; return Qr(this.ecModel, t, { index: this.get(n, !0), id: this.get(i, !0) }, e) }, n.prototype.getBoxLayoutParams = function () { const t = this; return { left: t.get('left'), top: t.get('top'), right: t.get('right'), bottom: t.get('bottom'), width: t.get('width'), height: t.get('height') } }, n.prototype.getZLevelKey = function () { return '' }, n.prototype.setZLevel = function (t) { this.option.zlevel = t }, n.protoInitialize = (function () { const t = n.prototype; t.type = 'component', t.id = '', t.name = '', t.mainType = '', t.subType = '', t.componentIndex = 0 }()), n }(Jk)); lo(CA, Jk), po(CA), vl(CA), ml(CA, cu); let DA = ''; typeof navigator !== 'undefined' && (DA = navigator.platform || ''); let kA; let AA; const LA = 'rgba(0, 0, 0, 0.2)'; const PA = { darkMode: 'auto', colorBy: 'series', color: ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'], gradientColor: ['#f6efa6', '#d88273', '#bf444c'], aria: { decal: { decals: [{ color: LA, dashArrayX: [1, 0], dashArrayY: [2, 5], symbolSize: 1, rotation: Math.PI / 6 }, { color: LA, symbol: 'circle', dashArrayX: [[8, 8], [0, 8, 8, 0]], dashArrayY: [6, 0], symbolSize: 0.8 }, { color: LA, dashArrayX: [1, 0], dashArrayY: [4, 3], rotation: -Math.PI / 4 }, { color: LA, dashArrayX: [[6, 6], [0, 6, 6, 0]], dashArrayY: [6, 0] }, { color: LA, dashArrayX: [[1, 0], [1, 6]], dashArrayY: [1, 0, 6, 0], rotation: Math.PI / 4 }, { color: LA, symbol: 'triangle', dashArrayX: [[9, 9], [0, 9, 9, 0]], dashArrayY: [7, 2], symbolSize: 0.75 }] } }, textStyle: { fontFamily: DA.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif', fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' }, blendMode: null, stateAnimation: { duration: 300, easing: 'cubicOut' }, animation: 'auto', animationDuration: 1e3, animationDurationUpdate: 500, animationEasing: 'cubicInOut', animationEasingUpdate: 'cubicInOut', animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: !1 }; var OA = Z(['tooltip', 'label', 'itemName', 'itemId', 'itemGroupId', 'seriesName']); var RA = 'original'; var NA = 'arrayRows'; var zA = 'objectRows'; var BA = 'keyedColumns'; var EA = 'typedArray'; var VA = 'unknown'; var FA = 'column'; var HA = 'row'; var WA = { Must: 1, Might: 2, Not: 3 }; var GA = qr(); var XA = Z(); const YA = qr(); const UA = (qr(), (function () { function t () {} return t.prototype.getColorFromPalette = function (t, e, n) { const i = kr(this.get('color', !0)); const r = this.get('colorLayer', !0); return wu(this, YA, i, r, t, e, n) }, t.prototype.clearColorPalette = function () { bu(this, YA) }, t }())); const ZA = '\x00_ec_inner'; const jA = 1; const qA = (function (t) {
    function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.init = function (t, e, n, i, r, o) { i = i || {}, this.option = null, this._theme = new Jk(i), this._locale = new Jk(r), this._optionManager = o }, n.prototype.setOption = function (t, e, n) { const i = Cu(e); this._optionManager.setOption(t, n, i), this._resetOption(null, i) }, n.prototype.resetOption = function (t, e) { return this._resetOption(t, Cu(e)) }, n.prototype._resetOption = function (t, e) { let n = !1; const i = this._optionManager; if (!t || t === 'recreate') { const r = i.mountOption(t === 'recreate'); this.option && t !== 'recreate' ? (this.restoreData(), this._mergeOption(r, e)) : AA(this, r), n = !0 } if ((t === 'timeline' || t === 'media') && this.restoreData(), !t || t === 'recreate' || t === 'timeline') { const o = i.getTimelineOption(this); o && (n = !0, this._mergeOption(o, e)) } if (!t || t === 'recreate' || t === 'media') { const a = i.getMediaOption(this); a.length && y(a, function (t) { n = !0, this._mergeOption(t, e) }, this) } return n }, n.prototype.mergeOption = function (t) { this._mergeOption(t, null) }, n.prototype._mergeOption = function (t, e) { function n (e) { const n = _u(this, e, kr(t[e])); const a = r.get(e); const s = a ? c && c.get(e) ? 'replaceMerge' : 'normalMerge' : 'replaceAll'; const l = Or(a, n, s); Ur(l, e, CA), i[e] = null, r.set(e, null), o.set(e, 0); let u; const p = []; const d = []; let f = 0; y(l, function (t, n) { let i = t.existing; const r = t.newOption; if (r) { const o = e === 'series'; const a = CA.getClass(e, t.keyInfo.subType, !o); if (!a) return; if (e === 'tooltip') { if (u) return; u = !0 } if (i && i.constructor === a)i.name = t.keyInfo.name, i.mergeOption(r, this), i.optionUpdated(r, !1); else { const s = h({ componentIndex: n }, t.keyInfo); i = new a(r, this, this, s), h(i, s), t.brandNew && (i.__requireNewView = !0), i.init(r, this, this), i.optionUpdated(null, !0) } } else i && (i.mergeOption({}, this), i.optionUpdated({}, !1)); i ? (p.push(i.option), d.push(i), f++) : (p.push(void 0), d.push(void 0)) }, this), i[e] = p, r.set(e, d), o.set(e, f), e === 'series' && kA(this) } var i = this.option; var r = this._componentsMap; var o = this._componentsCount; const a = []; const u = Z(); var c = e && e.replaceMergeMainTypeMap; pu(this), y(t, function (t, e) { t != null && (CA.hasClass(e) ? e && (a.push(e), u.set(e, !0)) : i[e] = i[e] == null ? s(t) : l(i[e], t, !0)) }), c && c.each(function (t, e) { CA.hasClass(e) && !u.get(e) && (a.push(e), u.set(e, !0)) }), CA.topologicalTravel(a, CA.getAllClassMainTypes(), n, this), this._seriesIndices || kA(this) }, n.prototype.getOption = function () { const t = s(this.option); return y(t, function (e, n) { if (CA.hasClass(n)) { for (var i = kr(e), r = i.length, o = !1, a = r - 1; a >= 0; a--)i[a] && !Xr(i[a]) ? o = !0 : (i[a] = null, !o && r--); i.length = r, t[n] = i } }), delete t[ZA], t }, n.prototype.getTheme = function () { return this._theme }, n.prototype.getLocaleModel = function () { return this._locale }, n.prototype.setUpdatePayload = function (t) { this._payload = t }, n.prototype.getUpdatePayload = function () { return this._payload }, n.prototype.getComponent = function (t, e) { const n = this._componentsMap.get(t); if (n) { const i = n[e || 0]; if (i) return i; if (e == null) for (let r = 0; r < n.length; r++) if (n[r]) return n[r] } }, n.prototype.queryComponents = function (t) { const e = t.mainType; if (!e) return []; const n = t.index; const i = t.id; const r = t.name; const o = this._componentsMap.get(e); if (!o || !o.length) return []; let a; return n != null ? (a = [], y(kr(n), function (t) { o[t] && a.push(o[t]) })) : a = i != null ? Tu('id', i, o) : r != null ? Tu('name', r, o) : _(o, function (t) { return !!t }), Iu(a, t) }, n.prototype.findComponents = function (t) { function e (t) { const e = r + 'Index'; const n = r + 'Id'; const i = r + 'Name'; return !t || t[e] == null && t[n] == null && t[i] == null ? null : { mainType: r, index: t[e], id: t[n], name: t[i] } } function n (e) { return t.filter ? _(e, t.filter) : e } const i = t.query; var r = t.mainType; const o = e(i); const a = o ? this.queryComponents(o) : _(this._componentsMap.get(r), function (t) { return !!t }); return n(Iu(a, t)) }, n.prototype.eachComponent = function (t, e, n) { const i = this._componentsMap; if (T(t)) { const r = e; const o = t; i.each(function (t, e) { for (let n = 0; t && n < t.length; n++) { const i = t[n]; i && o.call(r, e, i, i.componentIndex) } }) } else for (let a = I(t) ? i.get(t) : k(t) ? this.findComponents(t) : null, s = 0; a && s < a.length; s++) { const l = a[s]; l && e.call(n, l, l.componentIndex) } }, n.prototype.getSeriesByName = function (t) { const e = Wr(t, null); return _(this._componentsMap.get('series'), function (t) { return !!t && e != null && t.name === e }) }, n.prototype.getSeriesByIndex = function (t) {
      return this._componentsMap.get('series')[t]
    }, n.prototype.getSeriesByType = function (t) { return _(this._componentsMap.get('series'), function (e) { return !!e && e.subType === t }) }, n.prototype.getSeries = function () { return _(this._componentsMap.get('series'), function (t) { return !!t }) }, n.prototype.getSeriesCount = function () { return this._componentsCount.get('series') }, n.prototype.eachSeries = function (t, e) { y(this._seriesIndices, function (n) { const i = this._componentsMap.get('series')[n]; t.call(e, i, n) }, this) }, n.prototype.eachRawSeries = function (t, e) { y(this._componentsMap.get('series'), function (n) { n && t.call(e, n, n.componentIndex) }) }, n.prototype.eachSeriesByType = function (t, e, n) { y(this._seriesIndices, function (i) { const r = this._componentsMap.get('series')[i]; r.subType === t && e.call(n, r, i) }, this) }, n.prototype.eachRawSeriesByType = function (t, e, n) { return y(this.getSeriesByType(t), e, n) }, n.prototype.isSeriesFiltered = function (t) { return this._seriesIndicesMap.get(t.componentIndex) == null }, n.prototype.getCurrentSeriesIndices = function () { return (this._seriesIndices || []).slice() }, n.prototype.filterSeries = function (t, e) { const n = []; y(this._seriesIndices, function (i) { const r = this._componentsMap.get('series')[i]; t.call(e, r, i) && n.push(i) }, this), this._seriesIndices = n, this._seriesIndicesMap = Z(n) }, n.prototype.restoreData = function (t) { kA(this); const e = this._componentsMap; const n = []; e.each(function (t, e) { CA.hasClass(e) && n.push(e) }), CA.topologicalTravel(n, CA.getAllClassMainTypes(), function (n) { y(e.get(n), function (e) { !e || n === 'series' && Su(e, t) || e.restoreData() }) }) }, n.internalField = (function () { kA = function (t) { const e = t._seriesIndices = []; y(t._componentsMap.get('series'), function (t) { t && e.push(t.componentIndex) }), t._seriesIndicesMap = Z(e) }, AA = function (t, e) { t.option = {}, t.option[ZA] = jA, t._componentsMap = Z({ series: [] }), t._componentsCount = Z(); const n = e.aria; k(n) && n.enabled == null && (n.enabled = !0), Mu(e, t._theme.option), l(e, PA, !1), t._mergeOption(e, null) } }()), n
  }(Jk)); f(qA, UA); let KA; let $A; let QA; let JA; let tL; let eL; const nL = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isSSR', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getOption', 'getId', 'updateLabelLayout']; const iL = (function () { function t (t) { y(nL, function (e) { this[e] = gM(t[e], t) }, this) } return t }()); const rL = {}; var oL = (function () { function t () { this._coordinateSystems = [] } return t.prototype.create = function (t, e) { let n = []; y(rL, function (i) { const r = i.create(t, e); n = n.concat(r || []) }), this._coordinateSystems = n }, t.prototype.update = function (t, e) { y(this._coordinateSystems, function (n) { n.update && n.update(t, e) }) }, t.prototype.getCoordinateSystems = function () { return this._coordinateSystems.slice() }, t.register = function (t, e) { rL[t] = e }, t.get = function (t) { return rL[t] }, t }()); var aL = /^(min|max)?(.+)$/; const sL = (function () { function t (t) { this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t } return t.prototype.setOption = function (t, e) { t && (y(kr(t.series), function (t) { t && t.data && L(t.data) && X(t.data) }), y(kr(t.dataset), function (t) { t && t.source && L(t.source) && X(t.source) })), t = s(t); const n = this._optionBackup; const i = Du(t, e, !n); this._newBaseOption = i.baseOption, n ? (i.timelineOptions.length && (n.timelineOptions = i.timelineOptions), i.mediaList.length && (n.mediaList = i.mediaList), i.mediaDefault && (n.mediaDefault = i.mediaDefault)) : this._optionBackup = i }, t.prototype.mountOption = function (t) { const e = this._optionBackup; return this._timelineOptions = e.timelineOptions, this._mediaList = e.mediaList, this._mediaDefault = e.mediaDefault, this._currentMediaIndices = [], s(t ? e.baseOption : this._newBaseOption) }, t.prototype.getTimelineOption = function (t) { let e; const n = this._timelineOptions; if (n.length) { const i = t.getComponent('timeline'); i && (e = s(n[i.getCurrentIndex()])) } return e }, t.prototype.getMediaOption = function () { const t = this._api.getWidth(); const e = this._api.getHeight(); const n = this._mediaList; const i = this._mediaDefault; let r = []; let o = []; if (!n.length && !i) return o; for (let a = 0, l = n.length; l > a; a++)ku(n[a].query, t, e) && r.push(a); return !r.length && i && (r = [-1]), r.length && !Lu(r, this._currentMediaIndices) && (o = v(r, function (t) { return s(t === -1 ? i.option : n[t].option) })), this._currentMediaIndices = r, o }, t }()); var lL = y; var uL = k; var hL = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine']; var cL = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']]; var pL = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline']; var dL = [['borderRadius', 'barBorderRadius'], ['borderColor', 'barBorderColor'], ['borderWidth', 'barBorderWidth']]; var fL = (function () { function t (t) { this.data = t.data || (t.sourceFormat === BA ? {} : []), this.sourceFormat = t.sourceFormat || VA, this.seriesLayoutBy = t.seriesLayoutBy || FA, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption; const e = this.dimensionsDefine = t.dimensionsDefine; if (e) for (let n = 0; n < e.length; n++) { const i = e[n]; i.type == null && yu(this, n) === WA.Must && (i.type = 'ordinal') } } return t }()); const gL = (function () { function t (t, e) { const n = Qu(t) ? t : th(t); this._source = n; const i = this._data = n.data; n.sourceFormat === EA && (this._offset = 0, this._dimSize = e, this._data = i), tL(this, i, n) } return t.prototype.getSource = function () { return this._source }, t.prototype.count = function () { return 0 }, t.prototype.getItem = function () {}, t.prototype.appendData = function () {}, t.prototype.clean = function () {}, t.protoInitialize = (function () { const e = t.prototype; e.pure = !1, e.persistent = !0 }()), t.internalField = (function () { function t (t) { for (let e = 0; e < t.length; e++) this._data.push(t[e]) } let e; tL = function (t, e, o) { const a = o.sourceFormat; const s = o.seriesLayoutBy; const l = o.startIndex; const u = o.dimensionsDefine; const c = JA[ch(a, s)]; if (h(t, c), a === EA)t.getItem = n, t.count = r, t.fillStorage = i; else { const p = lh(a, s); t.getItem = gM(p, null, e, l, u); const d = uh(a, s); t.count = gM(d, null, e, l, u) } }; var n = function (t, e) { t -= this._offset, e = e || []; for (let n = this._data, i = this._dimSize, r = i * t, o = 0; i > o; o++)e[o] = n[r + o]; return e }; var i = function (t, e, n, i) { for (let r = this._data, o = this._dimSize, a = 0; o > a; a++) { for (var s = i[a], l = s[0] == null ? 1 / 0 : s[0], u = s[1] == null ? -1 / 0 : s[1], h = e - t, c = n[a], p = 0; h > p; p++) { const d = r[p * o + a]; c[t + p] = d, l > d && (l = d), d > u && (u = d) }s[0] = l, s[1] = u } }; var r = function () { return this._data ? this._data.length / this._dimSize : 0 }; e = {}, e[NA + '_' + FA] = { pure: !0, appendData: t }, e[NA + '_' + HA] = { pure: !0, appendData: function () { throw new Error('Do not support appendData when set seriesLayoutBy: "row".') } }, e[zA] = { pure: !0, appendData: t }, e[BA] = { pure: !0, appendData: function (t) { const e = this._data; y(t, function (t, n) { for (let i = e[n] || (e[n] = []), r = 0; r < (t || []).length; r++)i.push(t[r]) }) } }, e[RA] = { appendData: t }, e[EA] = { persistent: !1, pure: !0, appendData: function (t) { this._data = t }, clean: function () { this._offset += this.count(), this._data = null } }, JA = e }()), t }()); const yL = function (t, e, n, i) { return t[i] }; var vL = (KA = {}, KA[NA + '_' + FA] = function (t, e, n, i) { return t[i + e] }, KA[NA + '_' + HA] = function (t, e, n, i, r) { i += e; for (var o = r || [], a = t, s = 0; s < a.length; s++) { const l = a[s]; o[s] = l ? l[i] : null } return o }, KA[zA] = yL, KA[BA] = function (t, e, n, i, r) { for (var o = r || [], a = 0; a < n.length; a++) { const s = n[a].name; const l = t[s]; o[a] = l ? l[i] : null } return o }, KA[RA] = yL, KA); const mL = function (t) { return t.length }; var _L = ($A = {}, $A[NA + '_' + FA] = function (t, e) { return Math.max(0, t.length - e) }, $A[NA + '_' + HA] = function (t, e) { const n = t[0]; return n ? Math.max(0, n.length - e) : 0 }, $A[zA] = mL, $A[BA] = function (t, e, n) { const i = n[0].name; const r = t[i]; return r ? r.length : 0 }, $A[RA] = mL, $A); const xL = function (t, e) { return t[e] }; var wL = (QA = {}, QA[NA] = xL, QA[zA] = function (t, e, n) { return t[n] }, QA[BA] = xL, QA[RA] = function (t, e) { const n = Lr(t); return n instanceof Array ? n[e] : n }, QA[EA] = xL, QA); const bL = /\{@(.+?)\}/g; const SL = (function () { function t () {} return t.prototype.getDataParams = function (t, e) { const n = this.getData(e); const i = this.getRawValue(t, e); const r = n.getRawIndex(t); const o = n.getName(t); const a = n.getRawDataItem(t); const s = n.getItemVisual(t, 'style'); const l = s && s[n.getItemVisual(t, 'drawType') || 'fill']; const u = s && s.stroke; const h = this.mainType; const c = h === 'series'; const p = n.userOutput && n.userOutput.get(); return { componentType: h, componentSubType: this.subType, componentIndex: this.componentIndex, seriesType: c ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: c ? this.id : null, seriesName: c ? this.name : null, name: o, dataIndex: r, data: a, dataType: e, value: i, color: l, borderColor: u, dimensionNames: p ? p.fullDimensions : null, encode: p ? p.encode : null, $vars: ['seriesName', 'name', 'value'] } }, t.prototype.getFormattedLabel = function (t, e, n, i, r, o) { e = e || 'normal'; const a = this.getData(n); const s = this.getDataParams(t, n); if (o && (s.value = o.interpolatedValue), i != null && M(s.value) && (s.value = s.value[i]), !r) { const l = a.getItemModel(t); r = l.get(e === 'normal' ? ['label', 'formatter'] : [e, 'label', 'formatter']) } if (T(r)) return s.status = e, s.dimensionIndex = i, r(s); if (I(r)) { const u = Kl(r, s); return u.replace(bL, function (e, n) { const i = n.length; let r = n; r.charAt(0) === '[' && r.charAt(i - 1) === ']' && (r = +r.slice(1, i - 1)); let s = ph(a, t, r); if (o && M(o.interpolatedValue)) { const l = a.getDimensionIndex(r); l >= 0 && (s = o.interpolatedValue[l]) } return s != null ? s + '' : '' }) } }, t.prototype.getRawValue = function (t, e) { return ph(this.getData(e), t) }, t.prototype.formatTooltip = function () {}, t }()); var ML = (function () { function t (t) { t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0 } return t.prototype.perform = function (t) { function e (t) { return !(t >= 1) && (t = 1), t } const n = this._upstream; const i = t && t.skip; if (this._dirty && n) { const r = this.context; r.data = r.outputData = n.context.outputData } this.__pipeline && (this.__pipeline.currentTask = this); let o; this._plan && !i && (o = this._plan(this.context)); const a = e(this._modBy); const s = this._modDataCount || 0; const l = e(t && t.modBy); const u = t && t.modDataCount || 0; (a !== l || s !== u) && (o = 'reset'); let h; (this._dirty || o === 'reset') && (this._dirty = !1, h = this._doReset(i)), this._modBy = l, this._modDataCount = u; const c = t && t.step; if (this._dueEnd = n ? n._outputDueEnd : this._count ? this._count(this.context) : 1 / 0, this._progress) { const p = this._dueIndex; const d = Math.min(c != null ? this._dueIndex + c : 1 / 0, this._dueEnd); if (!i && (h || d > p)) { const f = this._progress; if (M(f)) for (let g = 0; g < f.length; g++) this._doProgress(f[g], p, d, l, u); else this._doProgress(f, p, d, l, u) } this._dueIndex = d; const y = this._settedOutputEnd != null ? this._settedOutputEnd : d; this._outputDueEnd = y } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd; return this.unfinished() }, t.prototype.dirty = function () { this._dirty = !0, this._onDirty && this._onDirty(this.context) }, t.prototype._doProgress = function (t, e, n, i, r) { TL.reset(e, n, i, r), this._callingProgress = t, this._callingProgress({ start: e, end: n, count: n - e, next: TL.next }, this.context) }, t.prototype._doReset = function (t) { this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null; let e, n; !t && this._reset && (e = this._reset(this.context), e && e.progress && (n = e.forceFirstProgress, e = e.progress), M(e) && !e.length && (e = null)), this._progress = e, this._modBy = this._modDataCount = null; const i = this._downstream; return i && i.dirty(), n }, t.prototype.unfinished = function () { return this._progress && this._dueIndex < this._dueEnd }, t.prototype.pipe = function (t) { (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty()) }, t.prototype.dispose = function () { this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0) }, t.prototype.getUpstream = function () { return this._upstream }, t.prototype.getDownstream = function () { return this._downstream }, t.prototype.setOutputEnd = function (t) { this._outputDueEnd = this._settedOutputEnd = t }, t }()); var TL = (function () { function t () { return n > i ? i++ : null } function e () { const t = i % a * r + Math.ceil(i / a); const e = i >= n ? null : o > t ? t : i; return i++, e } let n; let i; let r; let o; let a; var s = { reset: function (l, u, h, c) { i = l, n = u, r = h, o = c, a = Math.ceil(o / r), s.next = r > 1 && o > 0 ? e : t } }; return s }()); const IL = (Z({ number: function (t) { return parseFloat(t) }, time: function (t) { return +yr(t) }, trim: function (t) { return I(t) ? G(t) : t } }), { lt: function (t, e) { return e > t }, lte: function (t, e) { return e >= t }, gt: function (t, e) { return t > e }, gte: function (t, e) { return t >= e } }); var CL = ((function () { function t (t, e) { if (!D(e)) { const n = ''; Cr(n) } this._opFn = IL[t], this._rvalFloat = br(e) } return t.prototype.evaluate = function (t) { return D(t) ? this._opFn(t, this._rvalFloat) : this._opFn(br(t), this._rvalFloat) }, t }()), (function () { function t (t, e) { const n = t === 'desc'; this._resultLT = n ? 1 : -1, e == null && (e = n ? 'min' : 'max'), this._incomparable = e === 'min' ? -1 / 0 : 1 / 0 } return t.prototype.evaluate = function (t, e) { let n = D(t) ? t : br(t); let i = D(e) ? e : br(e); const r = isNaN(n); const o = isNaN(i); if (r && (n = this._incomparable), o && (i = this._incomparable), r && o) { const a = I(t); const s = I(e); a && (n = s ? t : 0), s && (i = a ? e : 0) } return i > n ? this._resultLT : n > i ? -this._resultLT : 0 }, t }())); var DL = ((function () { function t (t, e) { this._rval = e, this._isEQ = t, this._rvalTypeof = typeof e, this._rvalFloat = br(e) } return t.prototype.evaluate = function (t) { let e = t === this._rval; if (!e) { const n = typeof t; n === this._rvalTypeof || n !== 'number' && this._rvalTypeof !== 'number' || (e = br(t) === this._rvalFloat) } return this._isEQ ? e : !e }, t }()), (function () { function t () {} return t.prototype.getRawData = function () { throw new Error('not supported') }, t.prototype.getRawDataItem = function () { throw new Error('not supported') }, t.prototype.cloneRawData = function () {}, t.prototype.getDimensionInfo = function () {}, t.prototype.cloneAllDimensionInfo = function () {}, t.prototype.count = function () {}, t.prototype.retrieveValue = function () {}, t.prototype.retrieveValueFromItem = function () {}, t.prototype.convertValue = function (t, e) { return gh(t, e) }, t }())); var kL = Z(); const AL = 'undefined'; var LL = typeof Uint32Array === AL ? Array : Uint32Array; var PL = typeof Uint16Array === AL ? Array : Uint16Array; var OL = typeof Int32Array === AL ? Array : Int32Array; const RL = typeof Float64Array === AL ? Array : Float64Array; var NL = { float: RL, int: OL, ordinal: Array, number: Array, time: RL }; const zL = (function () { function t () { this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = Z() } return t.prototype.initData = function (t, e, n) { this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity; const i = t.getSource(); const r = this.defaultDimValueGetter = eL[i.sourceFormat]; this._dimValueGetter = n || r, this._rawExtent = []; sh(i); this._dimensions = v(e, function (t) { return { type: t.type, property: t.property } }), this._initDataFromProvider(0, t.count()) }, t.prototype.getProvider = function () { return this._provider }, t.prototype.getSource = function () { return this._provider.getSource() }, t.prototype.ensureCalculationDimension = function (t, e) { const n = this._calcDimNameToIdx; const i = this._dimensions; let r = n.get(t); if (r != null) { if (i[r].type === e) return r } else r = i.length; return i[r] = { type: e }, n.set(t, r), this._chunks[r] = new NL[e || 'float'](this._rawCount), this._rawExtent[r] = Ih(), r }, t.prototype.collectOrdinalMeta = function (t, e) { const n = this._chunks[t]; const i = this._dimensions[t]; const r = this._rawExtent; const o = i.ordinalOffset || 0; const a = n.length; o === 0 && (r[t] = Ih()); for (let s = r[t], l = o; a > l; l++) { const u = n[l] = e.parseAndCollect(n[l]); isNaN(u) || (s[0] = Math.min(u, s[0]), s[1] = Math.max(u, s[1])) }i.ordinalMeta = e, i.ordinalOffset = a, i.type = 'ordinal' }, t.prototype.getOrdinalMeta = function (t) { const e = this._dimensions[t]; const n = e.ordinalMeta; return n }, t.prototype.getDimensionProperty = function (t) { const e = this._dimensions[t]; return e && e.property }, t.prototype.appendData = function (t) { const e = this._provider; const n = this.count(); e.appendData(t); let i = e.count(); return e.persistent || (i += n), i > n && this._initDataFromProvider(n, i, !0), [n, i] }, t.prototype.appendValues = function (t, e) { for (var n = this._chunks, i = this._dimensions, r = i.length, o = this._rawExtent, a = this.count(), s = a + Math.max(t.length, e || 0), l = 0; r > l; l++) { var u = i[l]; Dh(n, l, u.type, s, !0) } for (let h = [], c = a; s > c; c++) for (let p = c - a, d = 0; r > d; d++) { var u = i[d]; const f = eL.arrayRows.call(this, t[p] || h, u.property, p, d); n[d][c] = f; const g = o[d]; f < g[0] && (g[0] = f), f > g[1] && (g[1] = f) } return this._rawCount = this._count = s, { start: a, end: s } }, t.prototype._initDataFromProvider = function (t, e, n) { for (var i = this._provider, r = this._chunks, o = this._dimensions, a = o.length, s = this._rawExtent, l = v(o, function (t) { return t.property }), u = 0; a > u; u++) { const h = o[u]; s[u] || (s[u] = Ih()), Dh(r, u, h.type, e, n) } if (i.fillStorage)i.fillStorage(t, e, r, s); else for (let c = [], p = t; e > p; p++) { c = i.getItem(p, c); for (let d = 0; a > d; d++) { const f = r[d]; const g = this._dimValueGetter(c, l[d], p, d); f[p] = g; const y = s[d]; g < y[0] && (y[0] = g), g > y[1] && (y[1] = g) } }!i.persistent && i.clean && i.clean(), this._rawCount = this._count = e, this._extent = [] }, t.prototype.count = function () { return this._count }, t.prototype.get = function (t, e) { if (!(e >= 0 && e < this._count)) return 0 / 0; const n = this._chunks[t]; return n ? n[this.getRawIndex(e)] : 0 / 0 }, t.prototype.getValues = function (t, e) { const n = []; let i = []; if (e == null) { e = t, t = []; for (var r = 0; r < this._dimensions.length; r++)i.push(r) } else i = t; for (var r = 0, o = i.length; o > r; r++)n.push(this.get(i[r], e)); return n }, t.prototype.getByRawIndex = function (t, e) { if (!(e >= 0 && e < this._rawCount)) return 0 / 0; const n = this._chunks[t]; return n ? n[e] : 0 / 0 }, t.prototype.getSum = function (t) { const e = this._chunks[t]; let n = 0; if (e) for (let i = 0, r = this.count(); r > i; i++) { const o = this.get(t, i); isNaN(o) || (n += o) } return n }, t.prototype.getMedian = function (t) { const e = []; this.each([t], function (t) { isNaN(t) || e.push(t) }); const n = e.sort(function (t, e) { return t - e }); const i = this.count(); return i === 0 ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2 }, t.prototype.indexOfRawIndex = function (t) { if (t >= this._rawCount || t < 0) return -1; if (!this._indices) return t; const e = this._indices; const n = e[t]; if (n != null && n < this._count && n === t) return t; for (let i = 0, r = this._count - 1; r >= i;) { const o = (i + r) / 2 | 0; if (e[o] < t)i = o + 1; else { if (!(e[o] > t)) return o; r = o - 1 } } return -1 }, t.prototype.indicesOfNearest = function (t, e, n) { const i = this._chunks; const r = i[t]; const o = []; if (!r) return o; n == null && (n = 1 / 0); for (var a = 1 / 0, s = -1, l = 0, u = 0, h = this.count(); h > u; u++) { const c = this.getRawIndex(u); const p = e - r[c]; const d = Math.abs(p); n >= d && ((a > d || d === a && p >= 0 && s < 0) && (a = d, s = p, l = 0), p === s && (o[l++] = u)) } return o.length = l, o }, t.prototype.getIndices = function () { let t; const e = this._indices; if (e) { var n = e.constructor; const i = this._count; if (n === Array) { t = new n(i); for (var r = 0; i > r; r++)t[r] = e[r] } else t = new n(e.buffer, 0, i) } else { var n = Th(this._rawCount); t = new n(this.count()); for (var r = 0; r < t.length; r++)t[r] = r } return t }, t.prototype.filter = function (t, e) { if (!this._count) return this; for (var n = this.clone(), i = n.count(), r = Th(n._rawCount), o = new r(i), a = [], s = t.length, l = 0, u = t[0], h = n._chunks, c = 0; i > c; c++) { let p = void 0; const d = n.getRawIndex(c); if (s === 0)p = e(c); else if (s === 1) { const f = h[u][d]; p = e(f, c) } else { for (var g = 0; s > g; g++)a[g] = h[t[g]][d]; a[g] = c, p = e.apply(null, a) }p && (o[l++] = d) } return i > l && (n._indices = o), n._count = l, n._extent = [], n._updateGetRawIdx(), n }, t.prototype.selectRange = function (t) { const e = this.clone(); const n = e._count; if (!n) return this; const i = w(t); const r = i.length; if (!r) return this; const o = e.count(); const a = Th(e._rawCount); const s = new a(o); let l = 0; const u = i[0]; const h = t[u][0]; const c = t[u][1]; const p = e._chunks; let d = !1; if (!e._indices) { let f = 0; if (r === 1) { for (var g = p[i[0]], y = 0; n > y; y++) { var v = g[y]; (v >= h && c >= v || isNaN(v)) && (s[l++] = f), f++ }d = !0 } else if (r === 2) { for (var g = p[i[0]], m = p[i[1]], _ = t[i[1]][0], x = t[i[1]][1], y = 0; n > y; y++) { var v = g[y]; const b = m[y]; (v >= h && c >= v || isNaN(v)) && (b >= _ && x >= b || isNaN(b)) && (s[l++] = f), f++ }d = !0 } } if (!d) if (r === 1) for (var y = 0; o > y; y++) { var S = e.getRawIndex(y); var v = p[i[0]][S]; (v >= h && c >= v || isNaN(v)) && (s[l++] = S) } else for (var y = 0; o > y; y++) { for (var M = !0, S = e.getRawIndex(y), T = 0; r > T; T++) { const I = i[T]; var v = p[I][S]; (v < t[I][0] || v > t[I][1]) && (M = !1) }M && (s[l++] = e.getRawIndex(y)) } return o > l && (e._indices = s), e._count = l, e._extent = [], e._updateGetRawIdx(), e }, t.prototype.map = function (t, e) { const n = this.clone(t); return this._updateDims(n, t, e), n }, t.prototype.modify = function (t, e) { this._updateDims(this, t, e) }, t.prototype._updateDims = function (t, e, n) { for (var i = t._chunks, r = [], o = e.length, a = t.count(), s = [], l = t._rawExtent, u = 0; u < e.length; u++)l[e[u]] = Ih(); for (let h = 0; a > h; h++) { for (var c = t.getRawIndex(h), p = 0; o > p; p++)s[p] = i[e[p]][c]; s[o] = h; let d = n && n.apply(null, s); if (d != null) { typeof d !== 'object' && (r[0] = d, d = r); for (var u = 0; u < d.length; u++) { const f = e[u]; const g = d[u]; const y = l[f]; const v = i[f]; v && (v[c] = g), g < y[0] && (y[0] = g), g > y[1] && (y[1] = g) } } } }, t.prototype.lttbDownSample = function (t, e) { let n; let i; let r; const o = this.clone([t], !0); const a = o._chunks; const s = a[t]; const l = this.count(); let u = 0; const h = Math.floor(1 / e); let c = this.getRawIndex(0); const p = new (Th(this._rawCount))(Math.min(2 * (Math.ceil(l / h) + 2), l)); p[u++] = c; for (let d = 1; l - 1 > d; d += h) { for (var f = Math.min(d + h, l - 1), g = Math.min(d + 2 * h, l), y = (g + f) / 2, v = 0, m = f; g > m; m++) { var _ = this.getRawIndex(m); var x = s[_]; isNaN(x) || (v += x) }v /= g - f; const w = d; const b = Math.min(d + h, l); const S = d - 1; const M = s[c]; n = -1, r = w; for (var T = -1, I = 0, m = w; b > m; m++) { var _ = this.getRawIndex(m); var x = s[_]; isNaN(x) ? (I++, T < 0 && (T = _)) : (i = Math.abs((S - y) * (x - M) - (S - m) * (v - M)), i > n && (n = i, r = _)) }I > 0 && b - w > I && (p[u++] = Math.min(T, r), r = Math.max(T, r)), p[u++] = r, c = r } return p[u++] = this.getRawIndex(l - 1), o._count = u, o._indices = p, o.getRawIndex = this._getRawIdx, o }, t.prototype.downSample = function (t, e, n, i) { for (var r = this.clone([t], !0), o = r._chunks, a = [], s = Math.floor(1 / e), l = o[t], u = this.count(), h = r._rawExtent[t] = Ih(), c = new (Th(this._rawCount))(Math.ceil(u / s)), p = 0, d = 0; u > d; d += s) { s > u - d && (s = u - d, a.length = s); for (let f = 0; s > f; f++) { const g = this.getRawIndex(d + f); a[f] = l[g] } const y = n(a); const v = this.getRawIndex(Math.min(d + i(a, y) || 0, u - 1)); l[v] = y, y < h[0] && (h[0] = y), y > h[1] && (h[1] = y), c[p++] = v } return r._count = p, r._indices = c, r._updateGetRawIdx(), r }, t.prototype.each = function (t, e) { if (this._count) for (let n = t.length, i = this._chunks, r = 0, o = this.count(); o > r; r++) { const a = this.getRawIndex(r); switch (n) { case 0:e(r); break; case 1:e(i[t[0]][a], r); break; case 2:e(i[t[0]][a], i[t[1]][a], r); break; default:for (var s = 0, l = []; n > s; s++)l[s] = i[t[s]][a]; l[s] = r, e.apply(null, l) } } }, t.prototype.getDataExtent = function (t) { const e = this._chunks[t]; const n = Ih(); if (!e) return n; let i; const r = this.count(); const o = !this._indices; if (o) return this._rawExtent[t].slice(); if (i = this._extent[t]) return i.slice(); i = n; for (var a = i[0], s = i[1], l = 0; r > l; l++) { const u = this.getRawIndex(l); const h = e[u]; a > h && (a = h), h > s && (s = h) } return i = [a, s], this._extent[t] = i, i }, t.prototype.getRawDataItem = function (t) { const e = this.getRawIndex(t); if (this._provider.persistent) return this._provider.getItem(e); for (var n = [], i = this._chunks, r = 0; r < i.length; r++)n.push(i[r][e]); return n }, t.prototype.clone = function (e, n) { const i = new t(); const r = this._chunks; const o = e && m(e, function (t, e) { return t[e] = !0, t }, {}); if (o) for (let a = 0; a < r.length; a++)i._chunks[a] = o[a] ? Ch(r[a]) : r[a]; else i._chunks = r; return this._copyCommonProps(i), n || (i._indices = this._cloneIndices()), i._updateGetRawIdx(), i }, t.prototype._copyCommonProps = function (t) { t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = s(this._extent), t._rawExtent = s(this._rawExtent) }, t.prototype._cloneIndices = function () { if (this._indices) { const t = this._indices.constructor; let e = void 0; if (t === Array) { const n = this._indices.length; e = new t(n); for (let i = 0; n > i; i++)e[i] = this._indices[i] } else e = new t(this._indices); return e } return null }, t.prototype._getRawIdxIdentity = function (t) { return t }, t.prototype._getRawIdx = function (t) { return t < this._count && t >= 0 ? this._indices[t] : -1 }, t.prototype._updateGetRawIdx = function () { this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity }, t.internalField = (function () { function t (t, e, n, i) { return gh(t[i], this._dimensions[i]) }eL = { arrayRows: t, objectRows: function (t, e, n, i) { return gh(t[e], this._dimensions[i]) }, keyedColumns: t, original: function (t, e, n, i) { const r = t && (t.value == null ? t : t.value); return gh(r instanceof Array ? r[i] : r, this._dimensions[i]) }, typedArray: function (t, e, n, i) { return t[i] } } }()), t }()); const BL = (function () { function t (t) { this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t } return t.prototype.dirty = function () { this._setLocalSource([], []), this._storeList = [], this._dirty = !0 }, t.prototype._setLocalSource = function (t, e) { this._sourceList = t, this._upstreamSignList = e, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0) }, t.prototype._getVersionSign = function () { return this._sourceHost.uid + '_' + this._versionSignBase }, t.prototype.prepareSource = function () { this._isDirty() && (this._createSource(), this._dirty = !1) }, t.prototype._createSource = function () { this._setLocalSource([], []); let t; let e; const n = this._sourceHost; const i = this._getUpstreamSourceManagers(); const r = !!i.length; if (Ah(n)) { const o = n; let a = void 0; let s = void 0; let l = void 0; if (r) { const u = i[0]; u.prepareSource(), l = u.getSource(), a = l.data, s = l.sourceFormat, e = [u._getVersionSign()] } else a = o.get('data', !0), s = L(a) ? EA : RA, e = []; const h = this._getSourceMetaRawOption() || {}; const c = l && l.metaRawOption || {}; const p = E(h.seriesLayoutBy, c.seriesLayoutBy) || null; const d = E(h.sourceHeader, c.sourceHeader); const f = E(h.dimensions, c.dimensions); const g = p !== c.seriesLayoutBy || !!d != !!c.sourceHeader || f; t = g ? [Ju(a, { seriesLayoutBy: p, sourceHeader: d, dimensions: f }, s)] : [] } else { const y = n; if (r) { const v = this._applyTransform(i); t = v.sourceList, e = v.upstreamSignList } else { const m = y.get('source', !0); t = [Ju(m, this._getSourceMetaRawOption(), null)], e = [] } } this._setLocalSource(t, e) }, t.prototype._applyTransform = function (t) { const e = this._sourceHost; const n = e.get('transform', !0); const i = e.get('fromTransformResult', !0); if (i != null) { const r = ''; t.length !== 1 && Lh(r) } let o; const a = []; const s = []; return y(t, function (t) { t.prepareSource(); const e = t.getSource(i || 0); const n = ''; i == null || e || Lh(n), a.push(e), s.push(t._getVersionSign()) }), n ? o = bh(n, a, { datasetIndex: e.componentIndex }) : i != null && (o = [eh(a[0])]), { sourceList: o, upstreamSignList: s } }, t.prototype._isDirty = function () { if (this._dirty) return !0; for (let t = this._getUpstreamSourceManagers(), e = 0; e < t.length; e++) { const n = t[e]; if (n._isDirty() || this._upstreamSignList[e] !== n._getVersionSign()) return !0 } }, t.prototype.getSource = function (t) { t = t || 0; const e = this._sourceList[t]; if (!e) { const n = this._getUpstreamSourceManagers(); return n[0] && n[0].getSource(t) } return e }, t.prototype.getSharedDataStore = function (t) { const e = t.makeStoreSchema(); return this._innerGetDataStore(e.dimensions, t.source, e.hash) }, t.prototype._innerGetDataStore = function (t, e, n) { const i = 0; const r = this._storeList; let o = r[i]; o || (o = r[i] = {}); let a = o[n]; if (!a) { const s = this._getUpstreamSourceManagers()[0]; Ah(this._sourceHost) && s ? a = s._innerGetDataStore(t, e, n) : (a = new zL(), a.initData(new gL(e, t.length), t)), o[n] = a } return a }, t.prototype._getUpstreamSourceManagers = function () { const t = this._sourceHost; if (Ah(t)) { const e = fu(t); return e ? [e.getSourceManager()] : [] } return v(gu(t), function (t) { return t.getSourceManager() }) }, t.prototype._getSourceMetaRawOption = function () { let t; let e; let n; const i = this._sourceHost; if (Ah(i))t = i.get('seriesLayoutBy', !0), e = i.get('sourceHeader', !0), n = i.get('dimensions', !0); else if (!this._getUpstreamSourceManagers().length) { const r = i; t = r.get('seriesLayoutBy', !0), e = r.get('sourceHeader', !0), n = r.get('dimensions', !0) } return { seriesLayoutBy: t, sourceHeader: e, dimensions: n } }, t }()); var EL = 'line-height:1'; var VL = [0, 10, 20, 30]; var FL = ['', '\n', '\n\n', '\n\n\n']; const HL = (function () { function t () { this.richTextStyles = {}, this._nextStyleNameId = Mr() } return t.prototype._generateStyleName = function () { return '__EC_aUTo_' + this._nextStyleNameId++ }, t.prototype.makeTooltipMarker = function (t, e, n) { const i = n === 'richText' ? this._generateStyleName() : null; const r = Ql({ color: e, type: t, renderMode: n, markerId: i }); return I(r) ? r : (this.richTextStyles[i] = r.style, r.content) }, t.prototype.wrapRichTextStyle = function (t, e) { const n = {}; M(e) ? y(e, function (t) { return h(n, t) }) : h(n, e); const i = this._generateStyleName(); return this.richTextStyles[i] = n, '{' + i + '|' + t + '}' }, t }()); const WL = qr(); const GL = '__universalTransitionEnabled'; var XL = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e._selectedDataIndicesMap = {}, e } return e(n, t), n.prototype.init = function (t, e, n) { this.seriesIndex = this.componentIndex, this.dataTask = fh({ count: Jh, reset: tc }), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(t, n); const i = WL(this).sourceManager = new BL(this); i.prepareSource(); const r = this.getInitialData(t, n); nc(r, this), this.dataTask.context.data = r, WL(this).dataBeforeProcessed = r, $h(this), this._initSelectedMapFromData(r) }, n.prototype.mergeDefaultAndTheme = function (t, e) { const n = su(this); const i = n ? uu(t) : {}; let r = this.subType; CA.hasClass(r) && (r += 'Series'), l(t, e.getTheme().get(this.subType)), l(t, this.getDefaultOption()), Ar(t, 'label', ['show']), this.fillDataTextStyle(t.data), n && lu(t, i, n) }, n.prototype.mergeOption = function (t, e) { t = l(this.option, t, !0), this.fillDataTextStyle(t.data); const n = su(this); n && lu(this.option, t, n); const i = WL(this).sourceManager; i.dirty(), i.prepareSource(); const r = this.getInitialData(t, e); nc(r, this), this.dataTask.dirty(), this.dataTask.context.data = r, WL(this).dataBeforeProcessed = r, $h(this), this._initSelectedMapFromData(r) }, n.prototype.fillDataTextStyle = function (t) { if (t && !L(t)) for (let e = ['show'], n = 0; n < t.length; n++)t[n] && t[n].label && Ar(t[n], 'label', e) }, n.prototype.getInitialData = function () {}, n.prototype.appendData = function (t) { const e = this.getRawData(); e.appendData(t.data) }, n.prototype.getData = function (t) { const e = rc(this); if (e) { const n = e.context.data; return t == null ? n : n.getLinkedData(t) } return WL(this).data }, n.prototype.getAllData = function () { const t = this.getData(); return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{ data: t }] }, n.prototype.setData = function (t) { const e = rc(this); if (e) { const n = e.context; n.outputData = t, e !== this.dataTask && (n.data = t) }WL(this).data = t }, n.prototype.getEncode = function () { const t = this.get('encode', !0); return t ? Z(t) : void 0 }, n.prototype.getSourceManager = function () { return WL(this).sourceManager }, n.prototype.getSource = function () { return this.getSourceManager().getSource() }, n.prototype.getRawData = function () { return WL(this).dataBeforeProcessed }, n.prototype.getColorBy = function () { const t = this.get('colorBy'); return t || 'series' }, n.prototype.isColorBySeries = function () { return this.getColorBy() === 'series' }, n.prototype.getBaseAxis = function () { const t = this.coordinateSystem; return t && t.getBaseAxis && t.getBaseAxis() }, n.prototype.formatTooltip = function (t, e) { return jh({ series: this, dataIndex: t, multipleSeries: e }) }, n.prototype.isAnimationEnabled = function () { const t = this.ecModel; if (ZS.node && (!t || !t.ssr)) return !1; let e = this.getShallow('animation'); return e && this.getData().count() > this.getShallow('animationThreshold') && (e = !1), !!e }, n.prototype.restoreData = function () { this.dataTask.dirty() }, n.prototype.getColorFromPalette = function (t, e, n) { const i = this.ecModel; let r = UA.prototype.getColorFromPalette.call(this, t, e, n); return r || (r = i.getColorFromPalette(t, e, n)), r }, n.prototype.coordDimToDataDim = function (t) { return this.getRawData().mapDimensionsAll(t) }, n.prototype.getProgressive = function () { return this.get('progressive') }, n.prototype.getProgressiveThreshold = function () { return this.get('progressiveThreshold') }, n.prototype.select = function (t, e) { this._innerSelect(this.getData(e), t) }, n.prototype.unselect = function (t, e) { const n = this.option.selectedMap; if (n) { const i = this.option.selectedMode; const r = this.getData(e); if (i === 'series' || n === 'all') return this.option.selectedMap = {}, void (this._selectedDataIndicesMap = {}); for (let o = 0; o < t.length; o++) { const a = t[o]; const s = Kh(r, a); n[s] = !1, this._selectedDataIndicesMap[s] = -1 } } }, n.prototype.toggleSelect = function (t, e) { for (let n = [], i = 0; i < t.length; i++)n[0] = t[i], this.isSelected(t[i], e) ? this.unselect(n, e) : this.select(n, e) }, n.prototype.getSelectedDataIndices = function () { if (this.option.selectedMap === 'all') return [].slice.call(this.getData().getIndices()); for (var t = this._selectedDataIndicesMap, e = w(t), n = [], i = 0; i < e.length; i++) { const r = t[e[i]]; r >= 0 && n.push(r) } return n }, n.prototype.isSelected = function (t, e) { const n = this.option.selectedMap; if (!n) return !1; const i = this.getData(e); return (n === 'all' || n[Kh(i, t)]) && !i.getItemModel(t).get(['select', 'disabled']) }, n.prototype.isUniversalTransitionEnabled = function () { if (this[GL]) return !0; const t = this.option.universalTransition; return t ? t === !0 ? !0 : t && t.enabled : !1 }, n.prototype._innerSelect = function (t, e) { let n; let i; const r = this.option; const o = r.selectedMode; const a = e.length; if (o && a) if (o === 'series')r.selectedMap = 'all'; else if (o === 'multiple') { k(r.selectedMap) || (r.selectedMap = {}); for (let s = r.selectedMap, l = 0; a > l; l++) { const u = e[l]; var h = Kh(t, u); s[h] = !0, this._selectedDataIndicesMap[h] = t.getRawIndex(u) } } else if (o === 'single' || o === !0) { const c = e[a - 1]; var h = Kh(t, c); r.selectedMap = (n = {}, n[h] = !0, n), this._selectedDataIndicesMap = (i = {}, i[h] = t.getRawIndex(c), i) } }, n.prototype._initSelectedMapFromData = function (t) { if (!this.option.selectedMap) { const e = []; t.hasItemOption && t.each(function (n) { const i = t.getRawDataItem(n); i && i.selected && e.push(n) }), e.length > 0 && this._innerSelect(t, e) } }, n.registerClass = function (t) { return CA.registerClass(t) }, n.protoInitialize = (function () { const t = n.prototype; t.type = 'series.__base__', t.seriesIndex = 0, t.ignoreStyleOnData = !1, t.hasSymbolVisual = !1, t.defaultSymbol = 'circle', t.visualStyleAccessPath = 'itemStyle', t.visualDrawType = 'fill' }()), n }(CA)); f(XL, SL), f(XL, UA), lo(XL, CA); var YL = (function () { function t () { this.group = new CI(), this.uid = yl('viewComponent') } return t.prototype.init = function () {}, t.prototype.render = function () {}, t.prototype.dispose = function () {}, t.prototype.updateView = function () {}, t.prototype.updateLayout = function () {}, t.prototype.updateVisual = function () {}, t.prototype.toggleBlurSeries = function () {}, t.prototype.eachRendered = function (t) { const e = this.group; e && e.traverse(t) }, t }()); ao(YL), po(YL); var UL = qr(); var ZL = oc(); var jL = (function () {
    function t () {
      this.group = new CI(), this.uid = yl('viewChart'), this.renderTask = fh({ plan: lc, reset: uc }), this.renderTask.context = { view: this }
    } return t.prototype.init = function () {}, t.prototype.render = function () {}, t.prototype.highlight = function (t, e, n, i) { const r = t.getData(i && i.dataType); r && sc(r, i, 'emphasis') }, t.prototype.downplay = function (t, e, n, i) { const r = t.getData(i && i.dataType); r && sc(r, i, 'normal') }, t.prototype.remove = function () { this.group.removeAll() }, t.prototype.dispose = function () {}, t.prototype.updateView = function (t, e, n, i) { this.render(t, e, n, i) }, t.prototype.updateLayout = function (t, e, n, i) { this.render(t, e, n, i) }, t.prototype.updateVisual = function (t, e, n, i) { this.render(t, e, n, i) }, t.prototype.eachRendered = function (t) { rl(this.group, t) }, t.markUpdateMethod = function (t, e) { UL(t).updateMethod = e }, t.protoInitialize = (function () { const e = t.prototype; e.type = 'chart' }()), t
  }()); ao(jL, ['dispose']), po(jL); let qL; var KL = { incrementalPrepareRender: { progress: function (t, e) { e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload) } }, render: { forceFirstProgress: !0, progress: function (t, e) { e.view.render(e.model, e.ecModel, e.api, e.payload) } } }; var $L = '\x00__throttleOriginMethod'; var QL = '\x00__throttleRate'; var JL = '\x00__throttleType'; const tP = qr(); var eP = { itemStyle: fo(Kk, !0), lineStyle: fo(Zk, !0) }; var nP = { lineStyle: 'stroke', itemStyle: 'fill' }; const iP = { createOnAllSeries: !0, performRawSeries: !0, reset: function (t, e) { const n = t.getData(); const i = t.visualStyleAccessPath || 'itemStyle'; const r = t.getModel(i); const o = dc(t, i); const a = o(r); const s = r.getShallow('decal'); s && (n.setVisual('decal', s), s.dirty = !0); const l = fc(t, i); const u = a[l]; const c = T(u) ? u : null; const p = a.fill === 'auto' || a.stroke === 'auto'; if (!a[l] || c || p) { const d = t.getColorFromPalette(t.name, null, e.getSeriesCount()); a[l] || (a[l] = d, n.setVisual('colorFromPalette', !0)), a.fill = a.fill === 'auto' || T(a.fill) ? d : a.fill, a.stroke = a.stroke === 'auto' || T(a.stroke) ? d : a.stroke } return n.setVisual('style', a), n.setVisual('drawType', l), !e.isSeriesFiltered(t) && c ? (n.setVisual('colorFromPalette', !1), { dataEach: function (e, n) { const i = t.getDataParams(n); const r = h({}, a); r[l] = c(i), e.setItemVisual(n, 'style', r) } }) : void 0 } }; const rP = new Jk(); const oP = { createOnAllSeries: !0, performRawSeries: !0, reset: function (t, e) { if (!t.ignoreStyleOnData && !e.isSeriesFiltered(t)) { const n = t.getData(); const i = t.visualStyleAccessPath || 'itemStyle'; const r = dc(t, i); const o = n.getVisual('drawType'); return { dataEach: n.hasItemOption ? function (t, e) { const n = t.getRawDataItem(e); if (n && n[i]) { rP.option = n[i]; const a = r(rP); const s = t.ensureUniqueItemVisual(e, 'style'); h(s, a), rP.option.decal && (t.setItemVisual(e, 'decal', rP.option.decal), rP.option.decal.dirty = !0), o in a && t.setItemVisual(e, 'colorFromPalette', !1) } } : null } } } }; const aP = { performRawSeries: !0, overallReset: function (t) { const e = Z(); t.eachSeries(function (t) { const n = t.getColorBy(); if (!t.isColorBySeries()) { const i = t.type + '-' + n; let r = e.get(i); r || (r = {}, e.set(i, r)), tP(t).scope = r } }), t.eachSeries(function (e) { if (!e.isColorBySeries() && !t.isSeriesFiltered(e)) { const n = e.getRawData(); const i = {}; const r = e.getData(); const o = tP(e).scope; const a = e.visualStyleAccessPath || 'itemStyle'; const s = fc(e, a); r.each(function (t) { const e = r.getRawIndex(t); i[e] = t }), n.each(function (t) { const a = i[t]; const l = r.getItemVisual(a, 'colorFromPalette'); if (l) { const u = r.ensureUniqueItemVisual(a, 'style'); const h = n.getName(t) || t + ''; const c = n.count(); u[s] = e.getColorFromPalette(h, o, c) } }) } }) } }; var sP = Math.PI; var lP = (function () { function t (t, e, n, i) { this._stageTaskMap = Z(), this.ecInstance = t, this.api = e, n = this._dataProcessorHandlers = n.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i) } return t.prototype.restoreData = function (t, e) { t.restoreData(e), this._stageTaskMap.each(function (t) { const e = t.overallTask; e && e.dirty() }) }, t.prototype.getPerformArgs = function (t, e) { if (t.__pipeline) { const n = this._pipelineMap.get(t.__pipeline.id); const i = n.context; const r = !e && n.progressiveEnabled && (!i || i.progressiveRender) && t.__idxInPipeline > n.blockIndex; const o = r ? n.step : null; const a = i && i.modDataCount; const s = a != null ? Math.ceil(a / o) : null; return { step: o, modBy: s, modDataCount: a } } }, t.prototype.getPipeline = function (t) { return this._pipelineMap.get(t) }, t.prototype.updateStreamModes = function (t, e) { const n = this._pipelineMap.get(t.uid); const i = t.getData(); const r = i.count(); const o = n.progressiveEnabled && e.incrementalPrepareRender && r >= n.threshold; const a = t.get('large') && r >= t.get('largeThreshold'); const s = t.get('progressiveChunkMode') === 'mod' ? r : null; t.pipelineContext = n.context = { progressiveRender: o, modDataCount: s, large: a } }, t.prototype.restorePipelines = function (t) { const e = this; const n = e._pipelineMap = Z(); t.eachSeries(function (t) { const i = t.getProgressive(); const r = t.uid; n.set(r, { id: r, head: null, tail: null, threshold: t.getProgressiveThreshold(), progressiveEnabled: i && !(t.preventIncremental && t.preventIncremental()), blockIndex: -1, step: Math.round(i || 700), count: 0 }), e._pipe(t, t.dataTask) }) }, t.prototype.prepareStageTasks = function () { const t = this._stageTaskMap; const e = this.api.getModel(); const n = this.api; y(this._allHandlers, function (i) { const r = t.get(i.uid) || t.set(i.uid, {}); const o = ''; W(!(i.reset && i.overallReset), o), i.reset && this._createSeriesStageTask(i, r, e, n), i.overallReset && this._createOverallStageTask(i, r, e, n) }, this) }, t.prototype.prepareView = function (t, e, n, i) { const r = t.renderTask; const o = r.context; o.model = e, o.ecModel = n, o.api = i, r.__block = !t.incrementalPrepareRender, this._pipe(e, r) }, t.prototype.performDataProcessorTasks = function (t, e) { this._performStageTasks(this._dataProcessorHandlers, t, e, { block: !0 }) }, t.prototype.performVisualTasks = function (t, e, n) { this._performStageTasks(this._visualHandlers, t, e, n) }, t.prototype._performStageTasks = function (t, e, n, i) { function r (t, e) { return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id)) }i = i || {}; let o = !1; const a = this; y(t, function (t) { if (!i.visualType || i.visualType === t.visualType) { const s = a._stageTaskMap.get(t.uid); const l = s.seriesTaskMap; const u = s.overallTask; if (u) { let h; const c = u.agentStubMap; c.each(function (t) { r(i, t) && (t.dirty(), h = !0) }), h && u.dirty(), a.updatePayload(u, n); const p = a.getPerformArgs(u, i.block); c.each(function (t) { t.perform(p) }), u.perform(p) && (o = !0) } else l && l.each(function (s) { r(i, s) && s.dirty(); const l = a.getPerformArgs(s, i.block); l.skip = !t.performRawSeries && e.isSeriesFiltered(s.context.model), a.updatePayload(s, n), s.perform(l) && (o = !0) }) } }), this.unfinished = o || this.unfinished }, t.prototype.performSeriesTasks = function (t) { let e; t.eachSeries(function (t) { e = t.dataTask.perform() || e }), this.unfinished = e || this.unfinished }, t.prototype.plan = function () { this._pipelineMap.each(function (t) { let e = t.tail; do { if (e.__block) { t.blockIndex = e.__idxInPipeline; break }e = e.getUpstream() } while (e) }) }, t.prototype.updatePayload = function (t, e) { e !== 'remain' && (t.context.payload = e) }, t.prototype._createSeriesStageTask = function (t, e, n, i) { function r (e) { const r = e.uid; const l = s.set(r, a && a.get(r) || fh({ plan: xc, reset: wc, count: Sc })); l.context = { model: e, ecModel: n, api: i, useClearVisual: t.isVisual && !t.isLayout, plan: t.plan, reset: t.reset, scheduler: o }, o._pipe(e, l) } var o = this; var a = e.seriesTaskMap; var s = e.seriesTaskMap = Z(); const l = t.seriesType; const u = t.getTargetSeries; t.createOnAllSeries ? n.eachRawSeries(r) : l ? n.eachRawSeriesByType(l, r) : u && u(n, i).each(r) }, t.prototype._createOverallStageTask = function (t, e, n, i) { function r (t) { const e = t.uid; const n = l.set(e, s && s.get(e) || (p = !0, fh({ reset: vc, onDirty: _c }))); n.context = { model: t, overallProgress: c }, n.agent = a, n.__block = c, o._pipe(t, n) } var o = this; var a = e.overallTask = e.overallTask || fh({ reset: yc }); a.context = { ecModel: n, api: i, overallReset: t.overallReset, scheduler: o }; var s = a.agentStubMap; var l = a.agentStubMap = Z(); const u = t.seriesType; const h = t.getTargetSeries; var c = !0; var p = !1; const d = ''; W(!t.createOnAllSeries, d), u ? n.eachRawSeriesByType(u, r) : h ? h(n, i).each(r) : (c = !1, y(n.getSeries(), r)), p && a.dirty() }, t.prototype._pipe = function (t, e) { const n = t.uid; const i = this._pipelineMap.get(n); !i.head && (i.head = e), i.tail && i.tail.pipe(e), i.tail = e, e.__idxInPipeline = i.count++, e.__pipeline = i }, t.wrapStageHandler = function (t, e) { return T(t) && (t = { overallReset: t, seriesType: Mc(t) }), t.uid = yl('stageHandler'), e && (t.visualType = e), t }, t }()); var uP = bc(0); var hP = {}; var cP = {}; Tc(hP, qA), Tc(cP, iL), hP.eachSeriesByType = hP.eachRawSeriesByType = function (t) { qL = t }, hP.eachComponent = function (t) { t.mainType === 'series' && t.subType && (qL = t.subType) }; const pP = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF']; const dP = { color: pP, colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], pP] }; const fP = '#B9B8CE'; const gP = '#100C2A'; const yP = function () { return { axisLine: { lineStyle: { color: fP } }, splitLine: { lineStyle: { color: '#484753' } }, splitArea: { areaStyle: { color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)'] } }, minorSplitLine: { lineStyle: { color: '#20203B' } } } }; const vP = ['#4992ff', '#7cffb2', '#fddd60', '#ff6e76', '#58d9f9', '#05c091', '#ff8a45', '#8d48e3', '#dd79ff']; const mP = { darkMode: !0, color: vP, backgroundColor: gP, axisPointer: { lineStyle: { color: '#817f91' }, crossStyle: { color: '#817f91' }, label: { color: '#fff' } }, legend: { textStyle: { color: fP } }, textStyle: { color: fP }, title: { textStyle: { color: '#EEF1FA' }, subtextStyle: { color: '#B9B8CE' } }, toolbox: { iconStyle: { borderColor: fP } }, dataZoom: { borderColor: '#71708A', textStyle: { color: fP }, brushStyle: { color: 'rgba(135,163,206,0.3)' }, handleStyle: { color: '#353450', borderColor: '#C5CBE3' }, moveHandleStyle: { color: '#B0B6C3', opacity: 0.3 }, fillerColor: 'rgba(135,163,206,0.2)', emphasis: { handleStyle: { borderColor: '#91B7F2', color: '#4D587D' }, moveHandleStyle: { color: '#636D9A', opacity: 0.7 } }, dataBackground: { lineStyle: { color: '#71708A', width: 1 }, areaStyle: { color: '#71708A' } }, selectedDataBackground: { lineStyle: { color: '#87A3CE' }, areaStyle: { color: '#87A3CE' } } }, visualMap: { textStyle: { color: fP } }, timeline: { lineStyle: { color: fP }, label: { color: fP }, controlStyle: { color: fP, borderColor: fP } }, calendar: { itemStyle: { color: gP }, dayLabel: { color: fP }, monthLabel: { color: fP }, yearLabel: { color: fP } }, timeAxis: yP(), logAxis: yP(), valueAxis: yP(), categoryAxis: yP(), line: { symbol: 'circle' }, graph: { color: vP }, gauge: { title: { color: fP }, axisLine: { lineStyle: { color: [[1, 'rgba(207,212,219,0.2)']] } }, axisLabel: { color: fP }, detail: { color: '#EEF1FA' } }, candlestick: { itemStyle: { color: '#f64e56', color0: '#54ea92', borderColor: '#f64e56', borderColor0: '#54ea92' } } }; mP.categoryAxis.splitLine.show = !1; const _P = (function () { function t () {} return t.prototype.normalizeQuery = function (t) { const e = {}; const n = {}; const i = {}; if (I(t)) { const r = io(t); e.mainType = r.main || null, e.subType = r.sub || null } else { const o = ['Index', 'Name', 'Id']; const a = { name: 1, dataIndex: 1, dataType: 1 }; y(t, function (t, r) { for (var s = !1, l = 0; l < o.length; l++) { const u = o[l]; const h = r.lastIndexOf(u); if (h > 0 && h === r.length - u.length) { const c = r.slice(0, h); c !== 'data' && (e.mainType = c, e[u.toLowerCase()] = t, s = !0) } }a.hasOwnProperty(r) && (n[r] = t, s = !0), s || (i[r] = t) }) } return { cptQuery: e, dataQuery: n, otherQuery: i } }, t.prototype.filter = function (t, e) { function n (t, e, n, i) { return t[n] == null || e[i || n] === t[n] } const i = this.eventInfo; if (!i) return !0; const r = i.targetEl; const o = i.packedEvent; const a = i.model; const s = i.view; if (!a || !s) return !0; const l = e.cptQuery; const u = e.dataQuery; return n(l, a, 'mainType') && n(l, a, 'subType') && n(l, a, 'index', 'componentIndex') && n(l, a, 'name') && n(l, a, 'id') && n(u, o, 'name') && n(u, o, 'dataIndex') && n(u, o, 'dataType') && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, r, o)) }, t.prototype.afterTrigger = function () { this.eventInfo = null }, t }()); const xP = ['symbol', 'symbolSize', 'symbolRotate', 'symbolOffset']; const wP = xP.concat(['symbolKeepAspect']); const bP = { createOnAllSeries: !0, performRawSeries: !0, reset: function (t, e) { function n (e, n) { for (let i = t.getRawValue(n), r = t.getDataParams(n), a = 0; a < c.length; a++) { const s = c[a]; e.setItemVisual(n, s, o[s](i, r)) } } const i = t.getData(); if (t.legendIcon && i.setVisual('legendIcon', t.legendIcon), t.hasSymbolVisual) { for (var r = {}, o = {}, a = !1, s = 0; s < xP.length; s++) { const l = xP[s]; const u = t.get(l); T(u) ? (a = !0, o[l] = u) : r[l] = u } if (r.symbol = r.symbol || t.defaultSymbol, i.setVisual(h({ legendIcon: t.legendIcon || r.symbol, symbolKeepAspect: t.get('symbolKeepAspect') }, r)), !e.isSeriesFiltered(t)) { var c = w(o); return { dataEach: a ? n : null } } } } }; const SP = { createOnAllSeries: !0, performRawSeries: !0, reset: function (t, e) { function n (t, e) { for (let n = t.getItemModel(e), i = 0; i < wP.length; i++) { const r = wP[i]; const o = n.getShallow(r, !0); o != null && t.setItemVisual(e, r, o) } } if (t.hasSymbolVisual && !e.isSeriesFiltered(t)) { const i = t.getData(); return { dataEach: i.hasItemOption ? n : null } } } }; let MP = Math.round(9 * Math.random()); const TP = typeof Object.defineProperty === 'function'; const IP = (function () { function t () { this._id = '__ec_inner_' + MP++ } return t.prototype.get = function (t) { return this._guard(t)[this._id] }, t.prototype.set = function (t, e) { const n = this._guard(t); return TP ? Object.defineProperty(n, this._id, { value: e, enumerable: !1, configurable: !0 }) : n[this._id] = e, this }, t.prototype.delete = function (t) { return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1 }, t.prototype.has = function (t) { return !!this._guard(t)[this._id] }, t.prototype._guard = function (t) { if (t !== Object(t)) throw TypeError('Value of WeakMap is not a non-null object.'); return t }, t }()); const CP = ZC.extend({ type: 'triangle', shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (t, e) { const n = e.cx; const i = e.cy; const r = e.width / 2; const o = e.height / 2; t.moveTo(n, i - o), t.lineTo(n + r, i + o), t.lineTo(n - r, i + o), t.closePath() } }); const DP = ZC.extend({ type: 'diamond', shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (t, e) { const n = e.cx; const i = e.cy; const r = e.width / 2; const o = e.height / 2; t.moveTo(n, i - o), t.lineTo(n + r, i), t.lineTo(n, i + o), t.lineTo(n - r, i), t.closePath() } }); const kP = ZC.extend({ type: 'pin', shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (t, e) { const n = e.x; const i = e.y; const r = e.width / 5 * 3; const o = Math.max(r, e.height); const a = r / 2; const s = a * a / (o - a); const l = i - o + a + s; const u = Math.asin(s / a); const h = Math.cos(u) * a; const c = Math.sin(u); const p = Math.cos(u); const d = 0.6 * a; const f = 0.7 * a; t.moveTo(n - h, l + s), t.arc(n, l, a, Math.PI - u, 2 * Math.PI + u), t.bezierCurveTo(n + h - c * d, l + s + p * d, n, i - f, n, i), t.bezierCurveTo(n, i - f, n - h + c * d, l + s + p * d, n - h, l + s), t.closePath() } }); const AP = ZC.extend({ type: 'arrow', shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (t, e) { const n = e.height; const i = e.width; const r = e.x; const o = e.y; const a = i / 3 * 2; t.moveTo(r, o), t.lineTo(r + a, o + n), t.lineTo(r, o + n / 4 * 3), t.lineTo(r - a, o + n), t.lineTo(r, o), t.closePath() } }); const LP = { line: dk, rect: nD, roundRect: nD, square: nD, circle: GD, diamond: DP, pin: kP, arrow: AP, triangle: CP }; const PP = { line: function (t, e, n, i, r) { r.x1 = t, r.y1 = e + i / 2, r.x2 = t + n, r.y2 = e + i / 2 }, rect: function (t, e, n, i, r) { r.x = t, r.y = e, r.width = n, r.height = i }, roundRect: function (t, e, n, i, r) { r.x = t, r.y = e, r.width = n, r.height = i, r.r = Math.min(n, i) / 4 }, square: function (t, e, n, i, r) { const o = Math.min(n, i); r.x = t, r.y = e, r.width = o, r.height = o }, circle: function (t, e, n, i, r) { r.cx = t + n / 2, r.cy = e + i / 2, r.r = Math.min(n, i) / 2 }, diamond: function (t, e, n, i, r) { r.cx = t + n / 2, r.cy = e + i / 2, r.width = n, r.height = i }, pin: function (t, e, n, i, r) { r.x = t + n / 2, r.y = e + i / 2, r.width = n, r.height = i }, arrow: function (t, e, n, i, r) { r.x = t + n / 2, r.y = e + i / 2, r.width = n, r.height = i }, triangle: function (t, e, n, i, r) { r.cx = t + n / 2, r.cy = e + i / 2, r.width = n, r.height = i } }; const OP = {}; y(LP, function (t, e) { OP[e] = new t() }); var RP = ZC.extend({ type: 'symbol', shape: { symbolType: '', x: 0, y: 0, width: 0, height: 0 }, calculateTextPosition: function (t, e, n) { const i = Wi(t, e, n); const r = this.shape; return r && r.symbolType === 'pin' && e.position === 'inside' && (i.y = n.y + 0.4 * n.height), i }, buildPath: function (t, e, n) { let i = e.symbolType; if (i !== 'none') { let r = OP[i]; r || (i = 'rect', r = OP[i]), PP[i](e.x, e.y, e.width, e.height, r.shape), r.buildPath(t, r.shape, n) } } }); var NP = new zC(!0); var zP = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY']; var BP = [['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; var EP = 1; var VP = 2; var FP = 3; var HP = 4; var WP = new IP(); var GP = new CT(100); var XP = ['symbol', 'symbolSize', 'symbolKeepAspect', 'color', 'backgroundColor', 'dashArrayX', 'dashArrayY', 'maxTileWidth', 'maxTileHeight']; var YP = new kM(); var UP = {}; const ZP = '5.4.2'; const jP = { zrender: '5.4.3' }; const qP = 1; const KP = 800; const $P = 900; const QP = 1e3; var JP = 2e3; const tO = 5e3; var eO = 1e3; const nO = 1100; const iO = 2e3; var rO = 3e3; const oO = 4e3; const aO = 4500; const sO = 4600; const lO = 5e3; const uO = 6e3; const hO = 7e3; const cO = { PROCESSOR: { FILTER: QP, SERIES_FILTER: KP, STATISTIC: tO }, VISUAL: { LAYOUT: eO, PROGRESSIVE_LAYOUT: nO, GLOBAL: iO, CHART: rO, POST_CHART_LAYOUT: sO, COMPONENT: oO, BRUSH: lO, CHART_ITEM: aO, ARIA: uO, DECAL: hO } }; const pO = '__flagInMainProcess'; const dO = '__pendingUpdate'; const fO = '__needsUpdateStatus'; var gO = /^[a-zA-Z0-9_]+$/; const yO = '__connectUpdateStatus'; const vO = 0; const mO = 1; const _O = 2; const xO = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n }(kM)); const wO = xO.prototype; wO.on = bp('on'), wO.off = bp('off'); let bO; let SO; let MO; let TO; let IO; let CO; let DO; let kO; let AO; let LO; let PO; let OO; let RO; let NO; let zO; let BO; let EO; let VO; var FO = (function (t) {
    function n (e, n, i) { function r (t, e) { return t.__prio - e.__prio } const o = t.call(this, new _P()) || this; o._chartsViews = [], o._chartsMap = {}, o._componentsViews = [], o._componentsMap = {}, o._pendingActions = [], i = i || {}, I(n) && (n = jO[n]), o._dom = e; const a = 'canvas'; const l = 'auto'; const u = !1; const h = o._zr = Qi(e, { renderer: i.renderer || a, devicePixelRatio: i.devicePixelRatio, width: i.width, height: i.height, ssr: i.ssr, useDirtyRect: E(i.useDirtyRect, u), useCoarsePointer: E(i.useCoarsePointer, l), pointerSize: i.pointerSize }); o._ssr = i.ssr, o._throttledZrFlush = hc(gM(h.flush, h), 17), n = s(n), n && qu(n, !0), o._theme = n, o._locale = wl(i.locale || lA), o._coordSysMgr = new oL(); const c = o._api = zO(o); return an(ZO, r), an(YO, r), o._scheduler = new lP(o, c, YO, ZO), o._messageCenter = new xO(), o._initEvents(), o.resize = gM(o.resize, o), h.animation.on('frame', o._onframe, o), LO(h, o), PO(h, o), X(o), o } return e(n, t), n.prototype._onframe = function () { if (!this._disposed) { VO(this); const t = this._scheduler; if (this[dO]) { const e = this[dO].silent; this[pO] = !0; try { bO(this), TO.update.call(this, null, this[dO].updateParams) } catch (n) { throw this[pO] = !1, this[dO] = null, n } this._zr.flush(), this[pO] = !1, this[dO] = null, kO.call(this, e), AO.call(this, e) } else if (t.unfinished) { let i = qP; const r = this._model; const o = this._api; t.unfinished = !1; do { const a = +new Date(); t.performSeriesTasks(r), t.performDataProcessorTasks(r), CO(this, r), t.performVisualTasks(r), NO(this, this._model, o, 'remain', {}), i -= +new Date() - a } while (i > 0 && t.unfinished); t.unfinished || this._zr.flush() } } }, n.prototype.getDom = function () { return this._dom }, n.prototype.getId = function () { return this.id }, n.prototype.getZr = function () { return this._zr }, n.prototype.isSSR = function () { return this._ssr }, n.prototype.setOption = function (t, e, n) { if (!this[pO] && !this._disposed) { let i, r, o; if (k(e) && (n = e.lazyUpdate, i = e.silent, r = e.replaceMerge, o = e.transition, e = e.notMerge), this[pO] = !0, !this._model || e) { const a = new sL(this._api); const s = this._theme; const l = this._model = new qA(); l.scheduler = this._scheduler, l.ssr = this._ssr, l.init(null, null, null, s, this._locale, a) } this._model.setOption(t, { replaceMerge: r }, UO); const u = { seriesTransition: o, optionChanged: !0 }; if (n) this[dO] = { silent: i, updateParams: u }, this[pO] = !1, this.getZr().wakeUp(); else { try { bO(this), TO.update.call(this, null, u) } catch (h) { throw this[dO] = null, this[pO] = !1, h } this._ssr || this._zr.flush(), this[dO] = null, this[pO] = !1, kO.call(this, i), AO.call(this, i) } } }, n.prototype.setTheme = function () {}, n.prototype.getModel = function () { return this._model }, n.prototype.getOption = function () { return this._model && this._model.getOption() }, n.prototype.getWidth = function () { return this._zr.getWidth() }, n.prototype.getHeight = function () { return this._zr.getHeight() }, n.prototype.getDevicePixelRatio = function () { return this._zr.painter.dpr || ZS.hasGlobalWindow && window.devicePixelRatio || 1 }, n.prototype.getRenderedCanvas = function (t) { return this.renderToCanvas(t) }, n.prototype.renderToCanvas = function (t) { t = t || {}; const e = this._zr.painter; return e.getRenderedCanvas({ backgroundColor: t.backgroundColor || this._model.get('backgroundColor'), pixelRatio: t.pixelRatio || this.getDevicePixelRatio() }) }, n.prototype.renderToSVGString = function (t) { t = t || {}; const e = this._zr.painter; return e.renderToString({ useViewBox: t.useViewBox }) }, n.prototype.getSvgDataURL = function () { if (ZS.svgSupported) { const t = this._zr; const e = t.storage.getDisplayList(); return y(e, function (t) { t.stopAnimation(null, !0) }), t.painter.toDataURL() } }, n.prototype.getDataURL = function (t) { if (!this._disposed) { t = t || {}; const e = t.excludeComponents; const n = this._model; const i = []; const r = this; y(e, function (t) { n.eachComponent({ mainType: t }, function (t) { const e = r._componentsMap[t.__viewId]; e.group.ignore || (i.push(e), e.group.ignore = !0) }) }); const o = this._zr.painter.getType() === 'svg' ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL('image/' + (t && t.type || 'png')); return y(i, function (t) { t.group.ignore = !1 }), o } }, n.prototype.getConnectedDataURL = function (t) { if (!this._disposed) { const e = t.type === 'svg'; const n = this.group; const i = Math.min; const r = Math.max; const o = 1 / 0; if ($O[n]) { let a = o; let l = o; let u = -o; let h = -o; const c = []; const p = t && t.pixelRatio || this.getDevicePixelRatio(); y(KO, function (o) { if (o.group === n) { const p = e ? o.getZr().painter.getSvgDom().innerHTML : o.renderToCanvas(s(t)); const d = o.getDom().getBoundingClientRect(); a = i(d.left, a), l = i(d.top, l), u = r(d.right, u), h = r(d.bottom, h), c.push({ dom: p, left: d.left, top: d.top }) } }), a *= p, l *= p, u *= p, h *= p; const d = u - a; const f = h - l; const g = eM.createCanvas(); const v = Qi(g, { renderer: e ? 'svg' : 'canvas' }); if (v.resize({ width: d, height: f }), e) { let m = ''; return y(c, function (t) { const e = t.left - a; const n = t.top - l; m += '<g transform="translate(' + e + ',' + n + ')">' + t.dom + '</g>' }), v.painter.getSvgRoot().innerHTML = m, t.connectedBackgroundColor && v.painter.setBackgroundColor(t.connectedBackgroundColor), v.refreshImmediately(), v.painter.toDataURL() } return t.connectedBackgroundColor && v.add(new nD({ shape: { x: 0, y: 0, width: d, height: f }, style: { fill: t.connectedBackgroundColor } })), y(c, function (t) { const e = new QC({ style: { x: t.left * p - a, y: t.top * p - l, image: t.dom } }); v.add(e) }), v.refreshImmediately(), g.toDataURL('image/' + (t && t.type || 'png')) } return this.getDataURL(t) } }, n.prototype.convertToPixel = function (t, e) { return IO(this, 'convertToPixel', t, e) }, n.prototype.convertFromPixel = function (t, e) { return IO(this, 'convertFromPixel', t, e) }, n.prototype.containPixel = function (t, e) { if (!this._disposed) { let n; const i = this._model; const r = Kr(i, t); return y(r, function (t, i) { i.indexOf('Models') >= 0 && y(t, function (t) { const r = t.coordinateSystem; if (r && r.containPoint)n = n || !!r.containPoint(e); else if (i === 'seriesModels') { const o = this._chartsMap[t.__viewId]; o && o.containPoint && (n = n || o.containPoint(e, t)) } }, this) }, this), !!n } }, n.prototype.getVisual = function (t, e) { const n = this._model; const i = Kr(n, t, { defaultMainType: 'series' }); const r = i.seriesModel; const o = r.getData(); const a = i.hasOwnProperty('dataIndexInside') ? i.dataIndexInside : i.hasOwnProperty('dataIndex') ? o.indexOfRawIndex(i.dataIndex) : null; return a != null ? Ic(o, a, e) : Cc(o, e) }, n.prototype.getViewOfComponentModel = function (t) { return this._componentsMap[t.__viewId] }, n.prototype.getViewOfSeriesModel = function (t) { return this._chartsMap[t.__viewId] }, n.prototype._initEvents = function () { const t = this; y(WO, function (e) { const n = function (n) { let i; const r = t.getModel(); const o = n.target; const a = e === 'globalout'; if (a ? i = {} : o && Lc(o, function (t) { const e = hD(t); if (e && e.dataIndex != null) { const n = e.dataModel || r.getSeriesByIndex(e.seriesIndex); return i = n && n.getDataParams(e.dataIndex, e.dataType) || {}, !0 } return e.eventData ? (i = h({}, e.eventData), !0) : void 0 }, !0), i) { let s = i.componentType; let l = i.componentIndex; (s === 'markLine' || s === 'markPoint' || s === 'markArea') && (s = 'series', l = i.seriesIndex); const u = s && l != null && r.getComponent(s, l); const c = u && t[u.mainType === 'series' ? '_chartsMap' : '_componentsMap'][u.__viewId]; i.event = n, i.type = e, t._$eventProcessor.eventInfo = { targetEl: o, packedEvent: i, model: u, view: c }, t.trigger(e, i) } }; n.zrEventfulCallAtLast = !0, t._zr.on(e, n, t) }), y(XO, function (e, n) { t._messageCenter.on(n, function (t) { this.trigger(n, t) }, t) }), y(['selectchanged'], function (e) { t._messageCenter.on(e, function (t) { this.trigger(e, t) }, t) }), Ac(this._messageCenter, this, this._api) }, n.prototype.isDisposed = function () { return this._disposed }, n.prototype.clear = function () { this._disposed || this.setOption({ series: [] }, !0) }, n.prototype.dispose = function () { if (!this._disposed) { this._disposed = !0; const t = this.getDom(); t && Jr(this.getDom(), tR, ''); const e = this; const n = e._api; const i = e._model; y(e._componentsViews, function (t) { t.dispose(i, n) }), y(e._chartsViews, function (t) { t.dispose(i, n) }), e._zr.dispose(), e._dom = e._model = e._chartsMap = e._componentsMap = e._chartsViews = e._componentsViews = e._scheduler = e._api = e._zr = e._throttledZrFlush = e._theme = e._coordSysMgr = e._messageCenter = null, delete KO[e.id] } }, n.prototype.resize = function (t) { if (!this[pO] && !this._disposed) { this._zr.resize(t); const e = this._model; if (this._loadingFX && this._loadingFX.resize(), e) { let n = e.resetOption('media'); let i = t && t.silent; this[dO] && (i == null && (i = this[dO].silent), n = !0, this[dO] = null), this[pO] = !0; try { n && bO(this), TO.update.call(this, { type: 'resize', animation: h({ duration: 0 }, t && t.animation) }) } catch (r) { throw this[pO] = !1, r } this[pO] = !1, kO.call(this, i), AO.call(this, i) } } }, n.prototype.showLoading = function (t, e) { if (!this._disposed && (k(t) && (e = t, t = ''), t = t || 'default', this.hideLoading(), qO[t])) { const n = qO[t](this._api, e); const i = this._zr; this._loadingFX = n, i.add(n) } }, n.prototype.hideLoading = function () { this._disposed || (this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null) }, n.prototype.makeActionFromEvent = function (t) { const e = h({}, t); return e.type = XO[t.type], e }, n.prototype.dispatchAction = function (t, e) { if (!this._disposed && (k(e) || (e = { silent: !!e }), GO[t.type] && this._model)) { if (this[pO]) return void this._pendingActions.push(t); const n = e.silent; DO.call(this, t, n); const i = e.flush; i ? this._zr.flush() : i !== !1 && ZS.browser.weChat && this._throttledZrFlush(), kO.call(this, n), AO.call(this, n) } }, n.prototype.updateLabelLayout = function () { YP.trigger('series:layoutlabels', this._model, this._api, { updatedSeries: [] }) }, n.prototype.appendData = function (t) { if (!this._disposed) { const e = t.seriesIndex; const n = this.getModel(); const i = n.getSeriesByIndex(e); i.appendData(t), this._scheduler.unfinished = !0, this.getZr().wakeUp() } }, n.internalField = (function () {
      function t (t) { t.clearColorPalette(), t.eachSeries(function (t) { t.clearColorPalette() }) } function n (t) { const e = []; const n = []; let i = !1; if (t.eachComponent(function (t, r) { const o = r.get('zlevel') || 0; const a = r.get('z') || 0; const s = r.getZLevelKey(); i = i || !!s, (t === 'series' ? n : e).push({ zlevel: o, z: a, idx: r.componentIndex, type: t, key: s }) }), i) { let r; let o; const a = e.concat(n); an(a, function (t, e) { return t.zlevel === e.zlevel ? t.z - e.z : t.zlevel - e.zlevel }), y(a, function (e) { const n = t.getComponent(e.type, e.idx); let i = e.zlevel; const a = e.key; r != null && (i = Math.max(r, i)), a ? (i === r && a !== o && i++, o = a) : o && (i === r && i++, o = ''), r = i, n.setZLevel(i) }) } } function i (t) { for (var e = [], n = t.currentStates, i = 0; i < n.length; i++) { const r = n[i]; r !== 'emphasis' && r !== 'blur' && r !== 'select' && e.push(r) }t.selected && t.states.select && e.push('select'), t.hoverState === mD && t.states.emphasis ? e.push('emphasis') : t.hoverState === vD && t.states.blur && e.push('blur'), t.useStates(e) } function r (t, e) { const n = t._zr; const i = n.storage; let r = 0; i.traverse(function (t) { t.isGroup || r++ }), r > e.get('hoverLayerThreshold') && !ZS.node && !ZS.worker && e.eachSeries(function (e) { if (!e.preventUsingHoverLayer) { const n = t._chartsMap[e.__viewId]; n.__alive && n.eachRendered(function (t) { t.states.emphasis && (t.states.emphasis.hoverLayer = !0) }) } }) } function o (t, e) { const n = t.get('blendMode') || null; e.eachRendered(function (t) { t.isGroup || (t.style.blend = n) }) } function a (t, e) { if (!t.preventAutoZ) { const n = t.get('z') || 0; const i = t.get('zlevel') || 0; e.eachRendered(function (t) { return s(t, n, i, -1 / 0), !0 }) } } function s (t, e, n, i) { const r = t.getTextContent(); const o = t.getTextGuideLine(); const a = t.isGroup; if (a) for (let l = t.childrenRef(), u = 0; u < l.length; u++)i = Math.max(s(l[u], e, n, i), i); else t.z = e, t.zlevel = n, i = Math.max(t.z2, i); if (r && (r.z = e, r.zlevel = n, isFinite(i) && (r.z2 = i + 2)), o) { const h = t.textGuideLineConfig; o.z = e, o.zlevel = n, isFinite(i) && (o.z2 = i + (h && h.showAbove ? 1 : -1)) } return i } function l (t, e) { e.eachRendered(function (t) { if (!Ds(t)) { const e = t.getTextContent(); const n = t.getTextGuideLine(); t.stateTransition && (t.stateTransition = null), e && e.stateTransition && (e.stateTransition = null), n && n.stateTransition && (n.stateTransition = null), t.hasState() ? (t.prevStates = t.currentStates, t.clearStates()) : t.prevStates && (t.prevStates = null) } }) } function u (t, e) { const n = t.getModel('stateAnimation'); const r = t.isAnimationEnabled(); const o = n.get('duration'); const a = o > 0 ? { duration: o, delay: n.get('delay'), easing: n.get('easing') } : null; e.eachRendered(function (t) { if (t.states && t.states.emphasis) { if (Ds(t)) return; if (t instanceof ZC && os(t), t.__dirty) { const e = t.prevStates; e && t.useStates(e) } if (r) { t.stateTransition = a; const n = t.getTextContent(); const o = t.getTextGuideLine(); n && (n.stateTransition = a), o && (o.stateTransition = a) }t.__dirty && i(t) } }) }bO = function (t) { const e = t._scheduler; e.restorePipelines(t._model), e.prepareStageTasks(), SO(t, !0), SO(t, !1), e.plan() }, SO = function (t, e) { function n (t) { const n = t.__requireNewView; t.__requireNewView = !1; const u = '_ec_' + t.id + '_' + t.type; let h = !n && a[u]; if (!h) { const c = io(t.type); const p = e ? YL.getClass(c.main, c.sub) : jL.getClass(c.sub); h = new p(), h.init(i, l), a[u] = h, o.push(h), s.add(h.group) }t.__viewId = h.__id = u, h.__alive = !0, h.__model = t, h.group.__ecComponentInfo = { mainType: t.mainType, index: t.componentIndex }, !e && r.prepareView(h, t, i, l) } for (var i = t._model, r = t._scheduler, o = e ? t._componentsViews : t._chartsViews, a = e ? t._componentsMap : t._chartsMap, s = t._zr, l = t._api, u = 0; u < o.length; u++)o[u].__alive = !1; e ? i.eachComponent(function (t, e) { t !== 'series' && n(e) }) : i.eachSeries(n); for (var u = 0; u < o.length;) { const h = o[u]; h.__alive ? u++ : (!e && h.renderTask.dispose(), s.remove(h.group), h.dispose(i, l), o.splice(u, 1), a[h.__id] === h && delete a[h.__id], h.__id = h.group.__ecComponentInfo = null) } }, MO = function (t, e, n, i, r) { function o (i) { i && i.__alive && i[e] && i[e](i.__model, a, t._api, n) } var a = t._model; if (a.setUpdatePayload(n), !i) return void y([].concat(t._componentsViews).concat(t._chartsViews), o); const s = {}; s[i + 'Id'] = n[i + 'Id'], s[i + 'Index'] = n[i + 'Index'], s[i + 'Name'] = n[i + 'Name']; const l = { mainType: i, query: s }; r && (l.subType = r); let u; const h = n.excludeSeriesId; h != null && (u = Z(), y(kr(h), function (t) { const e = Wr(t, null); e != null && u.set(e, !0) })), a && a.eachComponent(l, function (e) { const i = u && u.get(e.id) != null; if (!i) if (rs(n)) if (e instanceof XL)n.type !== SD || n.notBlur || e.get(['emphasis', 'disabled']) || Wa(e, n, t._api); else { const r = Ga(e.mainType, e.componentIndex, n.name, t._api); const o = r.focusSelf; const a = r.dispatchers; n.type === SD && o && !n.notBlur && Ha(e.mainType, e.componentIndex, t._api), a && y(a, function (t) { n.type === SD ? Pa(t) : Oa(t) }) } else is(n) && e instanceof XL && (Ua(e, n, t._api), Za(e), EO(t)) }, t), a && a.eachComponent(l, function (e) { const n = u && u.get(e.id) != null; n || o(t[i === 'series' ? '_chartsMap' : '_componentsMap'][e.__viewId]) }, t) }, TO = { prepareAndUpdate: function (t) { bO(this), TO.update.call(this, t, { optionChanged: t.newOption != null }) }, update: function (e, n) { const i = this._model; const r = this._api; const o = this._zr; const a = this._coordSysMgr; const s = this._scheduler; if (i) { i.setUpdatePayload(e), s.restoreData(i, e), s.performSeriesTasks(i), a.create(i, r), s.performDataProcessorTasks(i, e), CO(this, i), a.update(i, r), t(i), s.performVisualTasks(i, e), OO(this, i, r, e, n); const l = i.get('backgroundColor') || 'transparent'; const u = i.get('darkMode'); o.setBackgroundColor(l), u != null && u !== 'auto' && o.setDarkMode(u), YP.trigger('afterupdate', i, r) } }, updateTransform: function (e) { const n = this; const i = this._model; const r = this._api; if (i) { i.setUpdatePayload(e); const o = []; i.eachComponent(function (t, a) { if (t !== 'series') { const s = n.getViewOfComponentModel(a); if (s && s.__alive) if (s.updateTransform) { const l = s.updateTransform(a, i, r, e); l && l.update && o.push(s) } else o.push(s) } }); const a = Z(); i.eachSeries(function (t) { const o = n._chartsMap[t.__viewId]; if (o.updateTransform) { const s = o.updateTransform(t, i, r, e); s && s.update && a.set(t.uid, 1) } else a.set(t.uid, 1) }), t(i), this._scheduler.performVisualTasks(i, e, { setDirty: !0, dirtyMap: a }), NO(this, i, r, e, {}, a), YP.trigger('afterupdate', i, r) } }, updateView: function (e) { const n = this._model; n && (n.setUpdatePayload(e), jL.markUpdateMethod(e, 'updateView'), t(n), this._scheduler.performVisualTasks(n, e, { setDirty: !0 }), OO(this, n, this._api, e, {}), YP.trigger('afterupdate', n, this._api)) }, updateVisual: function (e) { const n = this; const i = this._model; i && (i.setUpdatePayload(e), i.eachSeries(function (t) { t.getData().clearAllVisual() }), jL.markUpdateMethod(e, 'updateVisual'), t(i), this._scheduler.performVisualTasks(i, e, { visualType: 'visual', setDirty: !0 }), i.eachComponent(function (t, r) { if (t !== 'series') { const o = n.getViewOfComponentModel(r); o && o.__alive && o.updateVisual(r, i, n._api, e) } }), i.eachSeries(function (t) { const r = n._chartsMap[t.__viewId]; r.updateVisual(t, i, n._api, e) }), YP.trigger('afterupdate', i, this._api)) }, updateLayout: function (t) { TO.update.call(this, t) } }, IO = function (t, e, n, i) { if (!t._disposed) for (var r, o = t._model, a = t._coordSysMgr.getCoordinateSystems(), s = Kr(o, n), l = 0; l < a.length; l++) { const u = a[l]; if (u[e] && (r = u[e](o, s, i)) != null) return r } }, CO = function (t, e) { const n = t._chartsMap; const i = t._scheduler; e.eachSeries(function (t) { i.updateStreamModes(t, n[t.__viewId]) }) }, DO = function (t, e) {
        const n = this; const i = this.getModel(); const r = t.type; const o = t.escapeConnect; const a = GO[r]; const s = a.actionInfo; const l = (s.update || 'update').split(':'); const u = l.pop(); const p = l[0] != null && io(l[0]); this[pO] = !0; let d = [t]; let f = !1; t.batch && (f = !0, d = v(t.batch, function (e) { return e = c(h({}, e), t), e.batch = null, e })); let g; const m = []; const _ = is(t); const x = rs(t); if (x && Va(this._api), y(d, function (e) { if (g = a.action(e, n._model, n._api), g = g || h({}, e), g.type = s.event || g.type, m.push(g), x) { const i = $r(t); const r = i.queryOptionMap; const o = i.mainTypeSpecified; const l = o ? r.keys()[0] : 'series'; MO(n, u, e, l), EO(n) } else _ ? (MO(n, u, e, 'series'), EO(n)) : p && MO(n, u, e, p.main, p.sub) }), u !== 'none' && !x && !_ && !p) try { this[dO] ? (bO(this), TO.update.call(this, t), this[dO] = null) : TO[u].call(this, t) } catch (w) { throw this[pO] = !1, w } if (g = f ? { type: s.event || r, escapeConnect: o, batch: m } : m[0], this[pO] = !1, !e) {
          const b = this._messageCenter; if (b.trigger(g.type, g), _) {
            const S = { type: 'selectchanged', escapeConnect: o, selected: ja(i), isFromClick: t.isFromClick || !1, fromAction: t.type, fromActionPayload: t }
            b.trigger(S.type, S)
          }
        }
      }, kO = function (t) { for (let e = this._pendingActions; e.length;) { const n = e.shift(); DO.call(this, n, t) } }, AO = function (t) { !t && this.trigger('updated') }, LO = function (t, e) { t.on('rendered', function (n) { e.trigger('rendered', n), !t.animation.isFinished() || e[dO] || e._scheduler.unfinished || e._pendingActions.length || e.trigger('finished') }) }, PO = function (t, e) { t.on('mouseover', function (t) { const n = t.target; const i = Lc(n, es); i && (Xa(i, t, e._api), EO(e)) }).on('mouseout', function (t) { const n = t.target; const i = Lc(n, es); i && (Ya(i, t, e._api), EO(e)) }).on('click', function (t) { const n = t.target; const i = Lc(n, function (t) { return hD(t).dataIndex != null }, !0); if (i) { const r = i.selected ? 'unselect' : 'select'; const o = hD(i); e._api.dispatchAction({ type: r, dataType: o.dataType, dataIndexInside: o.dataIndex, seriesIndex: o.seriesIndex, isFromClick: !0 }) } }) }, OO = function (t, e, i, r, o) { n(e), RO(t, e, i, r, o), y(t._chartsViews, function (t) { t.__alive = !1 }), NO(t, e, i, r, o), y(t._chartsViews, function (t) { t.__alive || t.remove(e, i) }) }, RO = function (t, e, n, i, r, o) { y(o || t._componentsViews, function (t) { const r = t.__model; l(r, t), t.render(r, e, n, i), a(r, t), u(r, t) }) }, NO = function (t, e, n, i, s, c) { const p = t._scheduler; s = h(s || {}, { updatedSeries: e.getSeries() }), YP.trigger('series:beforeupdate', e, n, s); let d = !1; e.eachSeries(function (e) { const n = t._chartsMap[e.__viewId]; n.__alive = !0; const r = n.renderTask; p.updatePayload(r, i), l(e, n), c && c.get(e.uid) && r.dirty(), r.perform(p.getPerformArgs(r)) && (d = !0), n.group.silent = !!e.get('silent'), o(e, n), Za(e) }), p.unfinished = d || p.unfinished, YP.trigger('series:layoutlabels', e, n, s), YP.trigger('series:transition', e, n, s), e.eachSeries(function (e) { const n = t._chartsMap[e.__viewId]; a(e, n), u(e, n) }), r(t, e), YP.trigger('series:afterupdate', e, n, s) }, EO = function (t) { t[fO] = !0, t.getZr().wakeUp() }, VO = function (t) { t[fO] && (t.getZr().storage.traverse(function (t) { Ds(t) || i(t) }), t[fO] = !1) }, zO = function (t) { return new (function (n) { function i () { return n !== null && n.apply(this, arguments) || this } return e(i, n), i.prototype.getCoordinateSystems = function () { return t._coordSysMgr.getCoordinateSystems() }, i.prototype.getComponentByElement = function (e) { for (;e;) { const n = e.__ecComponentInfo; if (n != null) return t._model.getComponent(n.mainType, n.index); e = e.parent } }, i.prototype.enterEmphasis = function (e, n) { Pa(e, n), EO(t) }, i.prototype.leaveEmphasis = function (e, n) { Oa(e, n), EO(t) }, i.prototype.enterBlur = function (e) { Ra(e), EO(t) }, i.prototype.leaveBlur = function (e) { Na(e), EO(t) }, i.prototype.enterSelect = function (e) { za(e), EO(t) }, i.prototype.leaveSelect = function (e) { Ba(e), EO(t) }, i.prototype.getModel = function () { return t.getModel() }, i.prototype.getViewOfComponentModel = function (e) { return t.getViewOfComponentModel(e) }, i.prototype.getViewOfSeriesModel = function (e) { return t.getViewOfSeriesModel(e) }, i }(iL))(t) }, BO = function (t) { function e (t, e) { for (let n = 0; n < t.length; n++) { const i = t[n]; i[yO] = e } }y(XO, function (n, i) { t._messageCenter.on(i, function (n) { if ($O[t.group] && t[yO] !== vO) { if (n && n.escapeConnect) return; const i = t.makeActionFromEvent(n); const r = []; y(KO, function (e) { e !== t && e.group === t.group && r.push(e) }), e(r, vO), y(r, function (t) { t[yO] !== mO && t.dispatchAction(i) }), e(r, _O) } }) }) }
    }()), n
  }(kM)); const HO = FO.prototype; HO.on = wp('on'), HO.off = wp('off'), HO.one = function (t, e, n) { function i () { for (var n = [], o = 0; o < arguments.length; o++)n[o] = arguments[o]; e && e.apply && e.apply(this, n), r.off(t, i) } var r = this; this.on.call(this, t, i, n) }; var WO = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu']; var GO = {}; var XO = {}; var YO = []; var UO = []; var ZO = []; var jO = {}; var qO = {}; var KO = {}; var $O = {}; var QO = +new Date() - 0; var JO = +new Date() - 0; var tR = '_echarts_instance_'; const eR = Ip; var nR = []; const iR = wh; Fp(iO, iP), Fp(aO, oP), Fp(aO, aP), Fp(iO, bP), Fp(aO, SP), Fp(hO, mp), Lp(qu), Pp($P, Ku), Wp('default', gc), zp({ type: SD, event: SD, update: SD }, Q), zp({ type: MD, event: MD, update: MD }, Q), zp({ type: TD, event: TD, update: TD }, Q), zp({ type: ID, event: ID, update: ID }, Q), zp({ type: CD, event: CD, update: CD }, Q), Ap('light', dP), Ap('dark', mP); let rR; let oR; let aR; let sR; let lR; let uR; let hR; const cR = {}; var pR = (function () { function t (t, e, n, i, r, o) { this._old = t, this._new = e, this._oldKeyGetter = n || Zp, this._newKeyGetter = i || Zp, this.context = r, this._diffModeMultiple = o === 'multiple' } return t.prototype.add = function (t) { return this._add = t, this }, t.prototype.update = function (t) { return this._update = t, this }, t.prototype.updateManyToOne = function (t) { return this._updateManyToOne = t, this }, t.prototype.updateOneToMany = function (t) { return this._updateOneToMany = t, this }, t.prototype.updateManyToMany = function (t) { return this._updateManyToMany = t, this }, t.prototype.remove = function (t) { return this._remove = t, this }, t.prototype.execute = function () { this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']() }, t.prototype._executeOneToOne = function () { const t = this._old; const e = this._new; const n = {}; const i = new Array(t.length); const r = new Array(e.length); this._initIndexMap(t, null, i, '_oldKeyGetter'), this._initIndexMap(e, n, r, '_newKeyGetter'); for (let o = 0; o < t.length; o++) { const a = i[o]; const s = n[a]; const l = Up(s); if (l > 1) { const u = s.shift(); s.length === 1 && (n[a] = s[0]), this._update && this._update(u, o) } else l === 1 ? (n[a] = null, this._update && this._update(s, o)) : this._remove && this._remove(o) } this._performRestAdd(r, n) }, t.prototype._executeMultiple = function () { const t = this._old; const e = this._new; const n = {}; const i = {}; const r = []; const o = []; this._initIndexMap(t, n, r, '_oldKeyGetter'), this._initIndexMap(e, i, o, '_newKeyGetter'); for (let a = 0; a < r.length; a++) { const s = r[a]; const l = n[s]; const u = i[s]; const h = Up(l); const c = Up(u); if (h > 1 && c === 1) this._updateManyToOne && this._updateManyToOne(u, l), i[s] = null; else if (h === 1 && c > 1) this._updateOneToMany && this._updateOneToMany(u, l), i[s] = null; else if (h === 1 && c === 1) this._update && this._update(u, l), i[s] = null; else if (h > 1 && c > 1) this._updateManyToMany && this._updateManyToMany(u, l), i[s] = null; else if (h > 1) for (let p = 0; h > p; p++) this._remove && this._remove(l[p]); else this._remove && this._remove(l) } this._performRestAdd(o, i) }, t.prototype._performRestAdd = function (t, e) { for (let n = 0; n < t.length; n++) { const i = t[n]; const r = e[i]; const o = Up(r); if (o > 1) for (let a = 0; o > a; a++) this._add && this._add(r[a]); else o === 1 && this._add && this._add(r); e[i] = null } }, t.prototype._initIndexMap = function (t, e, n, i) { for (let r = this._diffModeMultiple, o = 0; o < t.length; o++) { const a = '_ec_' + this[i](t[o], o); if (r || (n[o] = a), e) { const s = e[a]; const l = Up(s); l === 0 ? (e[a] = o, r && n.push(a)) : l === 1 ? e[a] = [s, o] : s.push(o) } } }, t }()); var dR = (function () { function t (t, e) { this._encode = t, this._schema = e } return t.prototype.get = function () { return { fullDimensions: this._getFullDimensionNames(), encode: this._encode } }, t.prototype._getFullDimensionNames = function () { return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames }, t }()); var fR = (function () { function t (t) { this.otherDims = {}, t != null && h(this, t) } return t }()); var gR = qr(); const yR = { float: 'f', int: 'i', ordinal: 'o', number: 'n', time: 't' }; var vR = (function () { function t (t) { this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted) } return t.prototype.isDimensionOmitted = function () { return this._dimOmitted }, t.prototype._updateDimOmitted = function (t) { this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = td(this.source))) }, t.prototype.getSourceDimensionIndex = function (t) { return E(this._dimNameMap.get(t), -1) }, t.prototype.getSourceDimension = function (t) { const e = this.source.dimensionsDefine; return e ? e[t] : void 0 }, t.prototype.makeStoreSchema = function () { for (var t = this._fullDimCount, e = sh(this.source), n = !ed(t), i = '', r = [], o = 0, a = 0; t > o; o++) { let s = void 0; let l = void 0; let u = void 0; const h = this.dimensions[a]; if (h && h.storeDimIndex === o)s = e ? h.name : null, l = h.type, u = h.ordinalMeta, a++; else { const c = this.getSourceDimension(o); c && (s = e ? c.name : null, l = c.type) }r.push({ property: s, type: l, ordinalMeta: u }), !e || s == null || h && h.isCalculationCoord || (i += n ? s.replace(/\`/g, '`1').replace(/\$/g, '`2') : s), i += '$', i += yR[l] || 'f', u && (i += u.uid), i += '$' } const p = this.source; const d = [p.seriesLayoutBy, p.startIndex, i].join('$$'); return { dimensions: r, hash: d } }, t.prototype.makeOutputDimensionNames = function () { for (var t = [], e = 0, n = 0; e < this._fullDimCount; e++) { let i = void 0; const r = this.dimensions[n]; if (r && r.storeDimIndex === e)r.isCalculationCoord || (i = r.name), n++; else { const o = this.getSourceDimension(e); o && (i = o.name) }t.push(i) } return t }, t.prototype.appendCalculationDimension = function (t) { this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0) }, t }()); const mR = k; const _R = v; const xR = typeof Int32Array === 'undefined' ? Array : Int32Array; const wR = 'e\x00\x00'; const bR = -1; const SR = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount']; const MR = ['_approximateExtent']; var TR = (function () { function t (t, e) { this.type = 'list', this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'], this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'], this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample']; let n; let i = !1; Qp(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (i = !0, n = t), n = n || ['x', 'y']; for (var r = {}, o = [], a = {}, s = !1, l = {}, u = 0; u < n.length; u++) { const h = n[u]; const c = I(h) ? new fR({ name: h }) : h instanceof fR ? h : new fR(h); const p = c.name; c.type = c.type || 'float', c.coordDim || (c.coordDim = p, c.coordDimIndex = 0); const d = c.otherDims = c.otherDims || {}; o.push(p), r[p] = c, l[p] != null && (s = !0), c.createInvertedIndices && (a[p] = []), d.itemName === 0 && (this._nameDimIdx = u), d.itemId === 0 && (this._idDimIdx = u), i && (c.storeDimIndex = u) } if (this.dimensions = o, this._dimInfos = r, this._initGetDimensionInfo(s), this.hostModel = e, this._invertedIndicesMap = a, this._dimOmitted) { const f = this._dimIdxToName = Z(); y(o, function (t) { f.set(r[t].storeDimIndex, t) }) } } return t.prototype.getDimension = function (t) { let e = this._recognizeDimIndex(t); if (e == null) return t; if (e = t, !this._dimOmitted) return this.dimensions[e]; const n = this._dimIdxToName.get(e); if (n != null) return n; const i = this._schema.getSourceDimension(e); return i ? i.name : void 0 }, t.prototype.getDimensionIndex = function (t) { const e = this._recognizeDimIndex(t); if (e != null) return e; if (t == null) return -1; const n = this._getDimInfo(t); return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1 }, t.prototype._recognizeDimIndex = function (t) { return D(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0) ? +t : void 0 }, t.prototype._getStoreDimIndex = function (t) { const e = this.getDimensionIndex(t); return e }, t.prototype.getDimensionInfo = function (t) { return this._getDimInfo(this.getDimension(t)) }, t.prototype._initGetDimensionInfo = function (t) { const e = this._dimInfos; this._getDimInfo = t ? function (t) { return e.hasOwnProperty(t) ? e[t] : void 0 } : function (t) { return e[t] } }, t.prototype.getDimensionsOnCoord = function () { return this._dimSummary.dataDimsOnCoord.slice() }, t.prototype.mapDimension = function (t, e) { const n = this._dimSummary; if (e == null) return n.encodeFirstDimNotExtra[t]; const i = n.encode[t]; return i ? i[e] : null }, t.prototype.mapDimensionsAll = function (t) { const e = this._dimSummary; const n = e.encode[t]; return (n || []).slice() }, t.prototype.getStore = function () { return this._store }, t.prototype.initData = function (t, e, n) { let i; const r = this; if (t instanceof zL && (i = t), !i) { const o = this.dimensions; const a = Qu(t) || g(t) ? new gL(t, o.length) : t; i = new zL(); const s = _R(o, function (t) { return { type: r._dimInfos[t].type, property: t } }); i.initData(a, s, n) } this._store = i, this._nameList = (e || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, i.count()), this._dimSummary = jp(this, this._schema), this.userOutput = this._dimSummary.userOutput }, t.prototype.appendData = function (t) { const e = this._store.appendData(t); this._doInit(e[0], e[1]) }, t.prototype.appendValues = function (t, e) { const n = this._store.appendValues(t, e.length); const i = n.start; const r = n.end; const o = this._shouldMakeIdFromName(); if (this._updateOrdinalMeta(), e) for (let a = i; r > a; a++) { const s = a - i; this._nameList[a] = e[s], o && hR(this, a) } }, t.prototype._updateOrdinalMeta = function () { for (let t = this._store, e = this.dimensions, n = 0; n < e.length; n++) { const i = this._dimInfos[e[n]]; i.ordinalMeta && t.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta) } }, t.prototype._shouldMakeIdFromName = function () { const t = this._store.getProvider(); return this._idDimIdx == null && t.getSource().sourceFormat !== EA && !t.fillStorage }, t.prototype._doInit = function (t, e) { if (!(t >= e)) { const n = this._store; const i = n.getProvider(); this._updateOrdinalMeta(); const r = this._nameList; const o = this._idList; const a = i.getSource().sourceFormat; const s = a === RA; if (s && !i.pure) for (var l = [], u = t; e > u; u++) { const h = i.getItem(u, l); if (!this.hasItemOption && Pr(h) && (this.hasItemOption = !0), h) { const c = h.name; r[u] == null && c != null && (r[u] = Wr(c, null)); const p = h.id; o[u] == null && p != null && (o[u] = Wr(p, null)) } } if (this._shouldMakeIdFromName()) for (var u = t; e > u; u++)hR(this, u); rR(this) } }, t.prototype.getApproximateExtent = function (t) { return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t)) }, t.prototype.setApproximateExtent = function (t, e) { e = this.getDimension(e), this._approximateExtent[e] = t.slice() }, t.prototype.getCalculationInfo = function (t) { return this._calculationInfo[t] }, t.prototype.setCalculationInfo = function (t, e) { mR(t) ? h(this._calculationInfo, t) : this._calculationInfo[t] = e }, t.prototype.getName = function (t) { const e = this.getRawIndex(t); let n = this._nameList[e]; return n == null && this._nameDimIdx != null && (n = aR(this, this._nameDimIdx, e)), n == null && (n = ''), n }, t.prototype._getCategory = function (t, e) { const n = this._store.get(t, e); const i = this._store.getOrdinalMeta(t); return i ? i.categories[n] : n }, t.prototype.getId = function (t) { return oR(this, this.getRawIndex(t)) }, t.prototype.count = function () { return this._store.count() }, t.prototype.get = function (t, e) { const n = this._store; const i = this._dimInfos[t]; return i ? n.get(i.storeDimIndex, e) : void 0 }, t.prototype.getByRawIndex = function (t, e) { const n = this._store; const i = this._dimInfos[t]; return i ? n.getByRawIndex(i.storeDimIndex, e) : void 0 }, t.prototype.getIndices = function () { return this._store.getIndices() }, t.prototype.getDataExtent = function (t) { return this._store.getDataExtent(this._getStoreDimIndex(t)) }, t.prototype.getSum = function (t) { return this._store.getSum(this._getStoreDimIndex(t)) }, t.prototype.getMedian = function (t) { return this._store.getMedian(this._getStoreDimIndex(t)) }, t.prototype.getValues = function (t, e) { const n = this; const i = this._store; return M(t) ? i.getValues(_R(t, function (t) { return n._getStoreDimIndex(t) }), e) : i.getValues(t) }, t.prototype.hasValue = function (t) { for (let e = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = e.length; i > n; n++) if (isNaN(this._store.get(e[n], t))) return !1; return !0 }, t.prototype.indexOfName = function (t) { for (let e = 0, n = this._store.count(); n > e; e++) if (this.getName(e) === t) return e; return -1 }, t.prototype.getRawIndex = function (t) { return this._store.getRawIndex(t) }, t.prototype.indexOfRawIndex = function (t) { return this._store.indexOfRawIndex(t) }, t.prototype.rawIndexOf = function (t, e) { const n = t && this._invertedIndicesMap[t]; const i = n[e]; return i == null || isNaN(i) ? bR : i }, t.prototype.indicesOfNearest = function (t, e, n) { return this._store.indicesOfNearest(this._getStoreDimIndex(t), e, n) }, t.prototype.each = function (t, e, n) { T(t) && (n = e, e = t, t = []); const i = n || this; const r = _R(sR(t), this._getStoreDimIndex, this); this._store.each(r, i ? gM(e, i) : e) }, t.prototype.filterSelf = function (t, e, n) { T(t) && (n = e, e = t, t = []); const i = n || this; const r = _R(sR(t), this._getStoreDimIndex, this); return this._store = this._store.filter(r, i ? gM(e, i) : e), this }, t.prototype.selectRange = function (t) { const e = this; const n = {}; const i = w(t); const r = []; return y(i, function (i) { const o = e._getStoreDimIndex(i); n[o] = t[i], r.push(o) }), this._store = this._store.selectRange(n), this }, t.prototype.mapArray = function (t, e, n) { T(t) && (n = e, e = t, t = []), n = n || this; const i = []; return this.each(t, function () { i.push(e && e.apply(this, arguments)) }, n), i }, t.prototype.map = function (t, e, n, i) { const r = n || i || this; const o = _R(sR(t), this._getStoreDimIndex, this); const a = uR(this); return a._store = this._store.map(o, r ? gM(e, r) : e), a }, t.prototype.modify = function (t, e, n, i) { const r = n || i || this; const o = _R(sR(t), this._getStoreDimIndex, this); this._store.modify(o, r ? gM(e, r) : e) }, t.prototype.downSample = function (t, e, n, i) { const r = uR(this); return r._store = this._store.downSample(this._getStoreDimIndex(t), e, n, i), r }, t.prototype.lttbDownSample = function (t, e) { const n = uR(this); return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), e), n }, t.prototype.getRawDataItem = function (t) { return this._store.getRawDataItem(t) }, t.prototype.getItemModel = function (t) { const e = this.hostModel; const n = this.getRawDataItem(t); return new Jk(n, e, e && e.ecModel) }, t.prototype.diff = function (t) { const e = this; return new pR(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function (e) { return oR(t, e) }, function (t) { return oR(e, t) }) }, t.prototype.getVisual = function (t) { const e = this._visual; return e && e[t] }, t.prototype.setVisual = function (t, e) { this._visual = this._visual || {}, mR(t) ? h(this._visual, t) : this._visual[t] = e }, t.prototype.getItemVisual = function (t, e) { const n = this._itemVisuals[t]; const i = n && n[e]; return i == null ? this.getVisual(e) : i }, t.prototype.hasItemVisual = function () { return this._itemVisuals.length > 0 }, t.prototype.ensureUniqueItemVisual = function (t, e) { const n = this._itemVisuals; let i = n[t]; i || (i = n[t] = {}); let r = i[e]; return r == null && (r = this.getVisual(e), M(r) ? r = r.slice() : mR(r) && (r = h({}, r)), i[e] = r), r }, t.prototype.setItemVisual = function (t, e, n) { const i = this._itemVisuals[t] || {}; this._itemVisuals[t] = i, mR(e) ? h(i, e) : i[e] = n }, t.prototype.clearAllVisual = function () { this._visual = {}, this._itemVisuals = [] }, t.prototype.setLayout = function (t, e) { mR(t) ? h(this._layout, t) : this._layout[t] = e }, t.prototype.getLayout = function (t) { return this._layout[t] }, t.prototype.getItemLayout = function (t) { return this._itemLayouts[t] }, t.prototype.setItemLayout = function (t, e, n) { this._itemLayouts[t] = n ? h(this._itemLayouts[t] || {}, e) : e }, t.prototype.clearItemLayouts = function () { this._itemLayouts.length = 0 }, t.prototype.setItemGraphicEl = function (t, e) { const n = this.hostModel && this.hostModel.seriesIndex; cD(n, this.dataType, t, e), this._graphicEls[t] = e }, t.prototype.getItemGraphicEl = function (t) { return this._graphicEls[t] }, t.prototype.eachItemGraphicEl = function (t, e) { y(this._graphicEls, function (n, i) { n && t && t.call(e, n, i) }) }, t.prototype.cloneShallow = function (e) { return e || (e = new t(this._schema ? this._schema : _R(this.dimensions, this._getDimInfo, this), this.hostModel)), lR(e, this), e._store = this._store, e }, t.prototype.wrapMethod = function (t, e) { const n = this[t]; T(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function () { const t = n.apply(this, arguments); return e.apply(this, [t].concat(F(arguments))) }) }, t.internalField = (function () { rR = function (t) { const e = t._invertedIndicesMap; y(e, function (n, i) { const r = t._dimInfos[i]; const o = r.ordinalMeta; const a = t._store; if (o) { n = e[i] = new xR(o.categories.length); for (var s = 0; s < n.length; s++)n[s] = bR; for (var s = 0; s < a.count(); s++)n[a.get(r.storeDimIndex, s)] = s } }) }, aR = function (t, e, n) { return Wr(t._getCategory(e, n), null) }, oR = function (t, e) { let n = t._idList[e]; return n == null && t._idDimIdx != null && (n = aR(t, t._idDimIdx, e)), n == null && (n = wR + e), n }, sR = function (t) { return M(t) || (t = t != null ? [t] : []), t }, uR = function (e) { const n = new t(e._schema ? e._schema : _R(e.dimensions, e._getDimInfo, e), e.hostModel); return lR(n, e), n }, lR = function (t, e) { y(SR.concat(e.__wrappedMethods || []), function (n) { e.hasOwnProperty(n) && (t[n] = e[n]) }), t.__wrappedMethods = e.__wrappedMethods, y(MR, function (n) { t[n] = s(e[n]) }), t._calculationInfo = h({}, e._calculationInfo) }, hR = function (t, e) { const n = t._nameList; const i = t._idList; const r = t._nameDimIdx; const o = t._idDimIdx; let a = n[e]; let s = i[e]; if (a == null && r != null && (n[e] = a = aR(t, r, e)), s == null && o != null && (i[e] = s = aR(t, o, e)), s == null && a != null) { const l = t._nameRepeatCount; const u = l[a] = (l[a] || 0) + 1; s = a, u > 1 && (s += '__ec__' + u), i[e] = s } } }()), t }()); var IR = (function () { function t (t) { this.coordSysDims = [], this.axisMap = Z(), this.categoryAxisMap = Z(), this.coordSysName = t } return t }()); var CR = { cartesian2d: function (t, e, n, i) { const r = t.getReferringComponents('xAxis', HI).models[0]; const o = t.getReferringComponents('yAxis', HI).models[0]; e.coordSysDims = ['x', 'y'], n.set('x', r), n.set('y', o), ld(r) && (i.set('x', r), e.firstCategoryDimIndex = 0), ld(o) && (i.set('y', o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1)) }, singleAxis: function (t, e, n, i) { const r = t.getReferringComponents('singleAxis', HI).models[0]; e.coordSysDims = ['single'], n.set('single', r), ld(r) && (i.set('single', r), e.firstCategoryDimIndex = 0) }, polar: function (t, e, n, i) { const r = t.getReferringComponents('polar', HI).models[0]; const o = r.findAxisModel('radiusAxis'); const a = r.findAxisModel('angleAxis'); e.coordSysDims = ['radius', 'angle'], n.set('radius', o), n.set('angle', a), ld(o) && (i.set('radius', o), e.firstCategoryDimIndex = 0), ld(a) && (i.set('angle', a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1)) }, geo: function (t, e) { e.coordSysDims = ['lng', 'lat'] }, parallel: function (t, e, n, i) { const r = t.ecModel; const o = r.getComponent('parallel', t.get('parallelIndex')); const a = e.coordSysDims = o.dimensions.slice(); y(o.parallelAxisIndex, function (t, o) { const s = r.getComponent('parallelAxis', t); const l = a[o]; n.set(l, s), ld(s) && (i.set(l, s), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = o)) }) } }; var DR = (function () { function t (t) { this._setting = t || {}, this._extent = [1 / 0, -1 / 0] } return t.prototype.getSetting = function (t) { return this._setting[t] }, t.prototype.unionExtent = function (t) { const e = this._extent; t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]) }, t.prototype.unionExtentFromData = function (t, e) { this.unionExtent(t.getApproximateExtent(e)) }, t.prototype.getExtent = function () { return this._extent.slice() }, t.prototype.setExtent = function (t, e) { const n = this._extent; isNaN(t) || (n[0] = t), isNaN(e) || (n[1] = e) }, t.prototype.isInExtentRange = function (t) { return this._extent[0] <= t && this._extent[1] >= t }, t.prototype.isBlank = function () { return this._isBlank }, t.prototype.setBlank = function (t) { this._isBlank = t }, t }()); po(DR); let kR = 0; var AR = (function () { function t (t) { this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++kR } return t.createByAxisModel = function (e) { const n = e.option; const i = n.data; const r = i && v(i, md); return new t({ categories: r, needCollect: !r, deduplication: n.dedplication !== !1 }) }, t.prototype.getOrdinal = function (t) { return this._getOrCreateMap().get(t) }, t.prototype.parseAndCollect = function (t) { let e; const n = this._needCollect; if (!I(t) && !n) return t; if (n && !this._deduplication) return e = this.categories.length, this.categories[e] = t, e; const i = this._getOrCreateMap(); return e = i.get(t), e == null && (n ? (e = this.categories.length, this.categories[e] = t, i.set(t, e)) : e = 0 / 0), e }, t.prototype._getOrCreateMap = function () { return this._map || (this._map = Z(this.categories)) }, t }()); var LR = (function (t) { function n (e) { const n = t.call(this, e) || this; n.type = 'ordinal'; let i = n.getSetting('ordinalMeta'); return i || (i = new AR({})), M(i) && (i = new AR({ categories: v(i, function (t) { return k(t) ? t.value : t }) })), n._ordinalMeta = i, n._extent = n.getSetting('extent') || [0, i.categories.length - 1], n } return e(n, t), n.prototype.parse = function (t) { return t == null ? 0 / 0 : I(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t) }, n.prototype.contain = function (t) { return t = this.parse(t), Td(t, this._extent) && this._ordinalMeta.categories[t] != null }, n.prototype.normalize = function (t) { return t = this._getTickNumber(this.parse(t)), Id(t, this._extent) }, n.prototype.scale = function (t) { return t = Math.round(Cd(t, this._extent)), this.getRawOrdinalNumber(t) }, n.prototype.getTicks = function () { for (var t = [], e = this._extent, n = e[0]; n <= e[1];)t.push({ value: n }), n++; return t }, n.prototype.getMinorTicks = function () {}, n.prototype.setSortInfo = function (t) { if (t == null) return void (this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null); for (var e = t.ordinalNumbers, n = this._ordinalNumbersByTick = [], i = this._ticksByOrdinalNumber = [], r = 0, o = this._ordinalMeta.categories.length, a = Math.min(o, e.length); a > r; ++r) { const s = e[r]; n[r] = s, i[s] = r } for (let l = 0; o > r; ++r) { for (;i[l] != null;)l++; n.push(l), i[l] = r } }, n.prototype._getTickNumber = function (t) { const e = this._ticksByOrdinalNumber; return e && t >= 0 && t < e.length ? e[t] : t }, n.prototype.getRawOrdinalNumber = function (t) { const e = this._ordinalNumbersByTick; return e && t >= 0 && t < e.length ? e[t] : t }, n.prototype.getLabel = function (t) { if (!this.isBlank()) { const e = this.getRawOrdinalNumber(t.value); const n = this._ordinalMeta.categories[e]; return n == null ? '' : n + '' } }, n.prototype.count = function () { return this._extent[1] - this._extent[0] + 1 }, n.prototype.unionExtentFromData = function (t, e) { this.unionExtent(t.getApproximateExtent(e)) }, n.prototype.isInExtentRange = function (t) { return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t }, n.prototype.getOrdinalMeta = function () { return this._ordinalMeta }, n.prototype.calcNiceTicks = function () {}, n.prototype.calcNiceExtent = function () {}, n.type = 'ordinal', n }(DR)); DR.registerClass(LR); const PR = ar; var OR = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = 'interval', e._interval = 0, e._intervalPrecision = 2, e } return e(n, t), n.prototype.parse = function (t) { return t }, n.prototype.contain = function (t) { return Td(t, this._extent) }, n.prototype.normalize = function (t) { return Id(t, this._extent) }, n.prototype.scale = function (t) { return Cd(t, this._extent) }, n.prototype.setExtent = function (t, e) { const n = this._extent; isNaN(t) || (n[0] = parseFloat(t)), isNaN(e) || (n[1] = parseFloat(e)) }, n.prototype.unionExtent = function (t) { const e = this._extent; t[0] < e[0] && (e[0] = t[0]), t[1] > e[1] && (e[1] = t[1]), this.setExtent(e[0], e[1]) }, n.prototype.getInterval = function () { return this._interval }, n.prototype.setInterval = function (t) { this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = bd(t) }, n.prototype.getTicks = function (t) { const e = this._interval; const n = this._extent; const i = this._niceExtent; const r = this._intervalPrecision; const o = []; if (!e) return o; const a = 1e4; n[0] < i[0] && o.push(t ? { value: PR(i[0] - e, r) } : { value: n[0] }); for (let s = i[0]; s <= i[1] && (o.push({ value: s }), s = PR(s + e, r), s !== o[o.length - 1].value);) if (o.length > a) return []; const l = o.length ? o[o.length - 1].value : i[1]; return n[1] > l && o.push(t ? { value: PR(l + e, r) } : { value: n[1] }), o }, n.prototype.getMinorTicks = function (t) { for (var e = this.getTicks(!0), n = [], i = this.getExtent(), r = 1; r < e.length; r++) { for (var o = e[r], a = e[r - 1], s = 0, l = [], u = o.value - a.value, h = u / t; t - 1 > s;) { const c = PR(a.value + (s + 1) * h); c > i[0] && c < i[1] && l.push(c), s++ }n.push(l) } return n }, n.prototype.getLabel = function (t, e) { if (t == null) return ''; let n = e && e.precision; n == null ? n = lr(t.value) || 0 : n === 'auto' && (n = this._intervalPrecision); const i = PR(t.value, n, !0); return Zl(i) }, n.prototype.calcNiceTicks = function (t, e, n) { t = t || 5; const i = this._extent; let r = i[1] - i[0]; if (isFinite(r)) { r < 0 && (r = -r, i.reverse()); const o = xd(i, t, e, n); this._intervalPrecision = o.intervalPrecision, this._interval = o.interval, this._niceExtent = o.niceTickExtent } }, n.prototype.calcNiceExtent = function (t) { const e = this._extent; if (e[0] === e[1]) if (e[0] !== 0) { const n = Math.abs(e[0]); t.fixMax ? e[0] -= n / 2 : (e[1] += n / 2, e[0] -= n / 2) } else e[1] = 1; const i = e[1] - e[0]; isFinite(i) || (e[0] = 0, e[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval); const r = this._interval; t.fixMin || (e[0] = PR(Math.floor(e[0] / r) * r)), t.fixMax || (e[1] = PR(Math.ceil(e[1] / r) * r)) }, n.prototype.setNiceExtent = function (t, e) { this._niceExtent = [t, e] }, n.type = 'interval', n }(DR)); DR.registerClass(OR); var RR = typeof Float32Array !== 'undefined'; var NR = RR ? Float32Array : Array; var zR = '__ec_stack_'; const BR = function (t, e, n, i) { for (;i > n;) { const r = n + i >>> 1; t[r][1] < e ? n = r + 1 : i = r } return n }; var ER = (function (t) { function n (e) { const n = t.call(this, e) || this; return n.type = 'time', n } return e(n, t), n.prototype.getLabel = function (t) { const e = this.getSetting('useUTC'); return Dl(t.value, yA[Cl(Tl(this._minLevelUnit))] || yA.second, e, this.getSetting('locale')) }, n.prototype.getFormattedLabel = function (t, e, n) { const i = this.getSetting('useUTC'); const r = this.getSetting('locale'); return kl(t, e, n, r, i) }, n.prototype.getTicks = function () { const t = this._interval; const e = this._extent; let n = []; if (!t) return n; n.push({ value: e[0], level: 0 }); const i = this.getSetting('useUTC'); const r = Ud(this._minLevelUnit, this._approxInterval, i, e); return n = n.concat(r), n.push({ value: e[1], level: 0 }), n }, n.prototype.calcNiceExtent = function (t) { const e = this._extent; if (e[0] === e[1] && (e[0] -= pA, e[1] += pA), e[1] === -1 / 0 && 1 / 0 === e[0]) { const n = new Date(); e[1] = +new Date(n.getFullYear(), n.getMonth(), n.getDate()), e[0] = e[1] - pA } this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval) }, n.prototype.calcNiceTicks = function (t, e, n) { t = t || 10; const i = this._extent; const r = i[1] - i[0]; this._approxInterval = r / t, e != null && this._approxInterval < e && (this._approxInterval = e), n != null && this._approxInterval > n && (this._approxInterval = n); const o = VR.length; const a = Math.min(BR(VR, this._approxInterval, 0, o), o - 1); this._interval = VR[a][1], this._minLevelUnit = VR[Math.max(a - 1, 0)][0] }, n.prototype.parse = function (t) { return D(t) ? t : +yr(t) }, n.prototype.contain = function (t) { return Td(this.parse(t), this._extent) }, n.prototype.normalize = function (t) { return Id(this.parse(t), this._extent) }, n.prototype.scale = function (t) { return Cd(t, this._extent) }, n.type = 'time', n }(OR)); var VR = [['second', uA], ['minute', hA], ['hour', cA], ['quarter-day', 6 * cA], ['half-day', 12 * cA], ['day', 1.2 * pA], ['half-week', 3.5 * pA], ['week', 7 * pA], ['month', 31 * pA], ['quarter', 95 * pA], ['half-year', dA / 2], ['year', dA]]; DR.registerClass(ER); const FR = DR.prototype; const HR = OR.prototype; var WR = ar; const GR = Math.floor; const XR = Math.ceil; const YR = Math.pow; const UR = Math.log; var ZR = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = 'log', e.base = 10, e._originalScale = new OR(), e._interval = 0, e } return e(n, t), n.prototype.getTicks = function (t) { const e = this._originalScale; const n = this._extent; const i = e.getExtent(); const r = HR.getTicks.call(this, t); return v(r, function (t) { const e = t.value; let r = ar(YR(this.base, e)); return r = e === n[0] && this._fixMin ? Zd(r, i[0]) : r, r = e === n[1] && this._fixMax ? Zd(r, i[1]) : r, { value: r } }, this) }, n.prototype.setExtent = function (t, e) { const n = UR(this.base); t = UR(Math.max(0, t)) / n, e = UR(Math.max(0, e)) / n, HR.setExtent.call(this, t, e) }, n.prototype.getExtent = function () { const t = this.base; const e = FR.getExtent.call(this); e[0] = YR(t, e[0]), e[1] = YR(t, e[1]); const n = this._originalScale; const i = n.getExtent(); return this._fixMin && (e[0] = Zd(e[0], i[0])), this._fixMax && (e[1] = Zd(e[1], i[1])), e }, n.prototype.unionExtent = function (t) { this._originalScale.unionExtent(t); const e = this.base; t[0] = UR(t[0]) / UR(e), t[1] = UR(t[1]) / UR(e), FR.unionExtent.call(this, t) }, n.prototype.unionExtentFromData = function (t, e) { this.unionExtent(t.getApproximateExtent(e)) }, n.prototype.calcNiceTicks = function (t) { t = t || 10; const e = this._extent; const n = e[1] - e[0]; if (!(1 / 0 === n || n <= 0)) { let i = vr(n); const r = t / n * i; for (r <= 0.5 && (i *= 10); !isNaN(i) && Math.abs(i) < 1 && Math.abs(i) > 0;)i *= 10; const o = [ar(XR(e[0] / i) * i), ar(GR(e[1] / i) * i)]; this._interval = i, this._niceExtent = o } }, n.prototype.calcNiceExtent = function (t) { HR.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax }, n.prototype.parse = function (t) { return t }, n.prototype.contain = function (t) { return t = UR(t) / UR(this.base), Td(t, this._extent) }, n.prototype.normalize = function (t) { return t = UR(t) / UR(this.base), Id(t, this._extent) }, n.prototype.scale = function (t) { return t = Cd(t, this._extent), YR(this.base, t) }, n.type = 'log', n }(DR)); const jR = ZR.prototype; jR.getMinorTicks = HR.getMinorTicks, jR.getLabel = HR.getLabel, DR.registerClass(ZR); var qR = (function () { function t (t, e, n) { this._prepareParams(t, e, n) } return t.prototype._prepareParams = function (t, e, n) { n[1] < n[0] && (n = [0 / 0, 0 / 0]), this._dataMin = n[0], this._dataMax = n[1]; const i = this._isOrdinal = t.type === 'ordinal'; this._needCrossZero = t.type === 'interval' && e.getNeedCrossZero && e.getNeedCrossZero(); const r = this._modelMinRaw = e.get('min', !0); T(r) ? this._modelMinNum = qd(t, r({ min: n[0], max: n[1] })) : r !== 'dataMin' && (this._modelMinNum = qd(t, r)); const o = this._modelMaxRaw = e.get('max', !0); if (T(o) ? this._modelMaxNum = qd(t, o({ min: n[0], max: n[1] })) : o !== 'dataMax' && (this._modelMaxNum = qd(t, o)), i) this._axisDataLen = e.getCategories().length; else { const a = e.get('boundaryGap'); const s = M(a) ? a : [a || 0, a || 0]; this._boundaryGapInner = typeof s[0] === 'boolean' || typeof s[1] === 'boolean' ? [0, 0] : [Hi(s[0], 1), Hi(s[1], 1)] } }, t.prototype.calculate = function () { const t = this._isOrdinal; const e = this._dataMin; const n = this._dataMax; const i = this._axisDataLen; const r = this._boundaryGapInner; const o = t ? null : n - e || Math.abs(e); let a = this._modelMinRaw === 'dataMin' ? e : this._modelMinNum; let s = this._modelMaxRaw === 'dataMax' ? n : this._modelMaxNum; let l = a != null; let u = s != null; a == null && (a = t ? i ? 0 : 0 / 0 : e - r[0] * o), s == null && (s = t ? i ? i - 1 : 0 / 0 : n + r[1] * o), (a == null || !isFinite(a)) && (a = 0 / 0), (s == null || !isFinite(s)) && (s = 0 / 0); const h = z(a) || z(s) || t && !i; this._needCrossZero && (a > 0 && s > 0 && !l && (a = 0), a < 0 && s < 0 && !u && (s = 0)); const c = this._determinedMin; const p = this._determinedMax; return c != null && (a = c, l = !0), p != null && (s = p, u = !0), { min: a, max: s, minFixed: l, maxFixed: u, isBlank: h } }, t.prototype.modifyDataMinMax = function (t, e) { this[$R[t]] = e }, t.prototype.setDeterminedMinMax = function (t, e) { const n = KR[t]; this[n] = e }, t.prototype.freeze = function () { this.frozen = !0 }, t }()); var KR = { min: '_determinedMin', max: '_determinedMax' }; var $R = { min: '_dataMin', max: '_dataMax' }; var QR = (function () {
    function t () {} return t.prototype.getNeedCrossZero = function () {
      const t = this.option
      return !t.scale
    }, t.prototype.getCoordSysModel = function () {}, t
  }()); const JR = { isDimensionStacked: cd, enableDataStack: ud, getStackedDimension: pd }; const tN = (Object.freeze || Object)({ createList: hf, getLayoutRect: ru, dataStack: JR, createScale: cf, mixinAxisModelCommonMethods: pf, getECData: hD, createTextStyle: df, createDimensions: nd, createSymbol: Oc, enableHoverEmphasis: qa }); var eN = []; var nN = { registerPreprocessor: Lp, registerProcessor: Pp, registerPostInit: Op, registerPostUpdate: Rp, registerUpdateLifecycle: Np, registerAction: zp, registerCoordinateSystem: Bp, registerLayout: Vp, registerVisual: Fp, registerTransform: iR, registerLoading: Wp, registerMap: Xp, registerImpl: _p, PRIORITY: cO, ComponentModel: CA, ComponentView: YL, SeriesModel: XL, ChartView: jL, registerComponentModel: function (t) { CA.registerClass(t) }, registerComponentView: function (t) { YL.registerClass(t) }, registerSeriesModel: function (t) { XL.registerClass(t) }, registerChartView: function (t) { jL.registerClass(t) }, registerSubTypeDefaulter: function (t, e) { CA.registerSubTypeDefaulter(t, e) }, registerPainter: function (t, e) { nr(t, e) } }; var iN = 1e-8; const rN = []; const oN = (function () { function t (t) { this.name = t } return t.prototype.setCenter = function (t) { this._center = t }, t.prototype.getCenter = function () { let t = this._center; return t || (t = this._center = this.calcCenter()), t }, t }()); var aN = (function () { function t (t, e) { this.type = 'polygon', this.exterior = t, this.interiors = e } return t }()); var sN = (function () { function t (t) { this.type = 'linestring', this.points = t } return t }()); var lN = (function (t) { function n (e, n, i) { const r = t.call(this, e) || this; return r.type = 'geoJSON', r.geometries = n, r._center = i && [i[0], i[1]], r } return e(n, t), n.prototype.calcCenter = function () { for (var t, e = this.geometries, n = 0, i = 0; i < e.length; i++) { const r = e[i]; const o = r.exterior; const a = o && o.length; a > n && (t = r, n = a) } if (t) return _f(t.exterior); const s = this.getBoundingRect(); return [s.x + s.width / 2, s.y + s.height / 2] }, n.prototype.getBoundingRect = function (t) { let e = this._rect; if (e && !t) return e; const n = [1 / 0, 1 / 0]; const i = [-1 / 0, -1 / 0]; const r = this.geometries; return y(r, function (e) { e.type === 'polygon' ? mf(e.exterior, n, i, t) : y(e.points, function (e) { mf(e, n, i, t) }) }), isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1]) || (n[0] = n[1] = i[0] = i[1] = 0), e = new $M(n[0], n[1], i[0] - n[0], i[1] - n[1]), t || (this._rect = e), e }, n.prototype.contain = function (t) { const e = this.getBoundingRect(); const n = this.geometries; if (!e.contain(t[0], t[1])) return !1; t:for (let i = 0, r = n.length; r > i; i++) { const o = n[i]; if (o.type === 'polygon') { const a = o.exterior; const s = o.interiors; if (yf(a, t[0], t[1])) { for (let l = 0; l < (s ? s.length : 0); l++) if (yf(s[l], t[0], t[1])) continue t; return !0 } } } return !1 }, n.prototype.transformTo = function (t, e, n, i) { let r = this.getBoundingRect(); const o = r.width / r.height; n ? i || (i = n / o) : n = o * i; for (var a = new $M(t, e, n, i), s = r.calculateTransform(a), l = this.geometries, u = 0; u < l.length; u++) { const h = l[u]; h.type === 'polygon' ? (vf(h.exterior, s), y(h.interiors, function (t) { vf(t, s) })) : y(h.points, function (t) { vf(t, s) }) }r = this._rect, r.copy(a), this._center = [r.x + r.width / 2, r.y + r.height / 2] }, n.prototype.cloneShallow = function (t) { t == null && (t = this.name); const e = new n(t, this.geometries, this._center); return e._rect = this._rect, e.transformTo = null, e }, n }(oN)); const uN = ((function (t) { function n (e, n) { const i = t.call(this, e) || this; return i.type = 'geoSVG', i._elOnlyForCalculate = n, i } return e(n, t), n.prototype.calcCenter = function () { for (var t = this._elOnlyForCalculate, e = t.getBoundingRect(), n = [e.x + e.width / 2, e.y + e.height / 2], i = Ve(rN), r = t; r && !r.isGeoSVGGraphicRoot;)He(i, r.getLocalTransform(), i), r = r.parent; return Ye(i, i), ve(n, n, i), n }, n }(oN)), (Object.freeze || Object)({ linearMap: rr, round: ar, asc: sr, getPrecision: lr, getPrecisionSafe: ur, getPixelPrecision: hr, getPercentWithPrecision: cr, MAX_SAFE_INTEGER: NI, remRadian: fr, isRadianAroundZero: gr, parseDate: yr, quantity: vr, quantityExponent: mr, nice: _r, quantile: xr, reformIntervals: wr, isNumeric: Sr, numericToNumber: br })); const hN = (Object.freeze || Object)({ parse: yr, format: Dl }); const cN = (Object.freeze || Object)({ extendShape: Os, extendPath: Rs, makePath: Bs, makeImage: Es, mergePath: Nk, resizePath: Fs, createIcon: $s, updateProps: Is, initProps: Cs, getTransform: Gs, clipPointsByRect: qs, clipRectByRect: Ks, registerShape: Ns, getShapeClass: zs, Group: CI, Image: QC, Text: aD, Circle: GD, Ellipse: YD, Sector: rk, Ring: ak, Polygon: lk, Polyline: hk, Rect: nD, Line: dk, BezierCurve: yk, Arc: mk, IncrementalDisplayable: kk, CompoundPath: _k, LinearGradient: wk, RadialGradient: bk, BoundingRect: $M }); const pN = (Object.freeze || Object)({ addCommas: Zl, toCamelCase: jl, normalizeCssArray: _A, encodeHTML: Ce, formatTpl: Kl, getTooltipMarker: Ql, formatTime: Jl, capitalFirst: tu, truncateText: _o, getTextRect: Ul }); const dN = (Object.freeze || Object)({ map: v, each: y, indexOf: p, inherits: d, reduce: m, filter: _, bind: gM, curry: S, isArray: M, isString: I, isObject: k, isFunction: T, extend: h, defaults: c, clone: s, merge: l }); var fN = qr(); const gN = [0, 1]; const yN = (function () { function t (t, e, n) { this.onBand = !1, this.inverse = !1, this.dim = t, this.scale = e, this._extent = n || [0, 0] } return t.prototype.contain = function (t) { const e = this._extent; const n = Math.min(e[0], e[1]); const i = Math.max(e[0], e[1]); return t >= n && i >= t }, t.prototype.containData = function (t) { return this.scale.contain(t) }, t.prototype.getExtent = function () { return this._extent.slice() }, t.prototype.getPixelPrecision = function (t) { return hr(t || this.scale.getExtent(), this._extent) }, t.prototype.setExtent = function (t, e) { const n = this._extent; n[0] = t, n[1] = e }, t.prototype.dataToCoord = function (t, e) { let n = this._extent; const i = this.scale; return t = i.normalize(t), this.onBand && i.type === 'ordinal' && (n = n.slice(), Ef(n, i.count())), rr(t, gN, n, e) }, t.prototype.coordToData = function (t, e) { let n = this._extent; const i = this.scale; this.onBand && i.type === 'ordinal' && (n = n.slice(), Ef(n, i.count())); const r = rr(t, n, gN, e); return this.scale.scale(r) }, t.prototype.pointToData = function () {}, t.prototype.getTicksCoords = function (t) { t = t || {}; const e = t.tickModel || this.getTickModel(); const n = Tf(this, e); const i = n.ticks; const r = v(i, function (t) { return { coord: this.dataToCoord(this.scale.type === 'ordinal' ? this.scale.getRawOrdinalNumber(t) : t), tickValue: t } }, this); const o = e.get('alignWithLabel'); return Vf(this, r, o, t.clamp), r }, t.prototype.getMinorTicksCoords = function () { if (this.scale.type === 'ordinal') return []; const t = this.model.getModel('minorTick'); let e = t.get('splitNumber'); e > 0 && e < 100 || (e = 5); const n = this.scale.getMinorTicks(e); const i = v(n, function (t) { return v(t, function (t) { return { coord: this.dataToCoord(t), tickValue: t } }, this) }, this); return i }, t.prototype.getViewLabels = function () { return Mf(this).labels }, t.prototype.getLabelModel = function () { return this.model.getModel('axisLabel') }, t.prototype.getTickModel = function () { return this.model.getModel('axisTick') }, t.prototype.getBandWidth = function () { const t = this._extent; const e = this.scale.getExtent(); let n = e[1] - e[0] + (this.onBand ? 1 : 0); n === 0 && (n = 1); const i = Math.abs(t[1] - t[0]); return Math.abs(i) / n }, t.prototype.calculateCategoryInterval = function () { return Rf(this) }, t }()); var vN = 2 * Math.PI; var mN = zC.CMD; var _N = ['top', 'right', 'bottom', 'left']; var xN = []; var wN = new WM(); var bN = new WM(); var SN = new WM(); var MN = new WM(); var TN = new WM(); var IN = []; var CN = new WM(); const DN = ['align', 'verticalAlign', 'width', 'height', 'fontSize']; const kN = new mI(); const AN = qr(); const LN = qr(); const PN = ['x', 'y', 'rotation']; var ON = (function () { function t () { this._labelList = [], this._chartViewList = [] } return t.prototype.clearLabels = function () { this._labelList = [], this._chartViewList = [] }, t.prototype._addLabel = function (t, e, n, i, r) { const o = i.style; const a = i.__hostTarget; const s = a.textConfig || {}; const l = i.getComputedTransform(); const u = i.getBoundingRect().plain(); $M.applyTransform(u, u, l), l ? kN.setLocalTransform(l) : (kN.x = kN.y = kN.rotation = kN.originX = kN.originY = 0, kN.scaleX = kN.scaleY = 1); let h; const c = i.__hostTarget; if (c) { h = c.getBoundingRect().plain(); const p = c.getComputedTransform(); $M.applyTransform(h, h, p) } const d = h && c.getTextGuideLine(); this._labelList.push({ label: i, labelLine: d, seriesModel: n, dataIndex: t, dataType: e, layoutOption: r, computedLayoutOption: null, rect: u, hostRect: h, priority: h ? h.width * h.height : 0, defaultAttr: { ignore: i.ignore, labelGuideIgnore: d && d.ignore, x: kN.x, y: kN.y, scaleX: kN.scaleX, scaleY: kN.scaleY, rotation: kN.rotation, style: { x: o.x, y: o.y, align: o.align, verticalAlign: o.verticalAlign, width: o.width, height: o.height, fontSize: o.fontSize }, cursor: i.cursor, attachedPos: s.position, attachedRot: s.rotation } }) }, t.prototype.addLabelsOfSeries = function (t) { const e = this; this._chartViewList.push(t); const n = t.__model; const i = n.get('labelLayout'); (T(i) || w(i).length) && t.group.traverse(function (t) { if (t.ignore) return !0; const r = t.getTextContent(); const o = hD(t); r && !r.disableLabelLayout && e._addLabel(o.dataIndex, o.dataType, n, r, i) }) }, t.prototype.updateLayoutConfig = function (t) { function e (t, e) { return function () { Kf(t, e) } } for (let n = t.getWidth(), i = t.getHeight(), r = 0; r < this._labelList.length; r++) { const o = this._labelList[r]; const a = o.label; const s = a.__hostTarget; const l = o.defaultAttr; let u = void 0; u = T(o.layoutOption) ? o.layoutOption(lg(o, s)) : o.layoutOption, u = u || {}, o.computedLayoutOption = u; const h = Math.PI / 180; s && s.setTextConfig({ local: !1, position: u.x != null || u.y != null ? null : l.attachedPos, rotation: u.rotate != null ? u.rotate * h : l.attachedRot, offset: [u.dx || 0, u.dy || 0] }); let c = !1; if (u.x != null ? (a.x = or(u.x, n), a.setStyle('x', 0), c = !0) : (a.x = l.x, a.setStyle('x', l.style.x)), u.y != null ? (a.y = or(u.y, i), a.setStyle('y', 0), c = !0) : (a.y = l.y, a.setStyle('y', l.style.y)), u.labelLinePoints) { const p = s.getTextGuideLine(); p && (p.setShape({ points: u.labelLinePoints }), c = !1) } const d = AN(a); d.needsUpdateLabelLine = c, a.rotation = u.rotate != null ? u.rotate * h : l.rotation, a.scaleX = l.scaleX, a.scaleY = l.scaleY; for (let f = 0; f < DN.length; f++) { const g = DN[f]; a.setStyle(g, u[g] != null ? u[g] : l.style[g]) } if (u.draggable) { if (a.draggable = !0, a.cursor = 'move', s) { let y = o.seriesModel; if (o.dataIndex != null) { const v = o.seriesModel.getData(o.dataType); y = v.getItemModel(o.dataIndex) }a.on('drag', e(s, y.getModel('labelLine'))) } } else a.off('drag'), a.cursor = l.cursor } }, t.prototype.layout = function (t) { const e = t.getWidth(); const n = t.getHeight(); const i = ng(this._labelList); const r = _(i, function (t) { return t.layoutOption.moveOverlap === 'shiftX' }); const o = _(i, function (t) { return t.layoutOption.moveOverlap === 'shiftY' }); rg(r, 0, e), og(o, 0, n); const a = _(i, function (t) { return t.layoutOption.hideOverlap }); ag(a) }, t.prototype.processLabelsOverall = function () { const t = this; y(this._chartViewList, function (e) { const n = e.__model; const i = e.ignoreLabelLineUpdate; const r = n.isAnimationEnabled(); e.group.traverse(function (e) { if (e.ignore && !e.forceLabelAnimation) return !0; let o = !i; const a = e.getTextContent(); !o && a && (o = AN(a).needsUpdateLabelLine), o && t._updateLabelLine(e, n), r && t._animateLabels(e, n) }) }) }, t.prototype._updateLabelLine = function (t, e) { const n = t.getTextContent(); const i = hD(t); const r = i.dataIndex; if (n && r != null) { const o = e.getData(i.dataType); const a = o.getItemModel(r); const s = {}; const l = o.getItemVisual(r, 'style'); const u = o.getVisual('drawType'); s.stroke = l[u]; const h = a.getModel('labelLine'); tg(t, eg(a), s), Kf(t, h) } }, t.prototype._animateLabels = function (t, e) { const n = t.getTextContent(); const i = t.getTextGuideLine(); if (n && (t.forceLabelAnimation || !n.ignore && !n.invisible && !t.disableLabelAnimation && !Ds(t))) { var r = AN(n); var o = r.oldLayout; const a = hD(t); const s = a.dataIndex; const l = { x: n.x, y: n.y, rotation: n.rotation }; const u = e.getData(a.dataType); if (o) { n.attr(o); const h = t.prevStates; h && (p(h, 'select') >= 0 && n.attr(r.oldLayoutSelect), p(h, 'emphasis') >= 0 && n.attr(r.oldLayoutEmphasis)), Is(n, l, e, s) } else if (n.attr(l), !Wk(n).valueAnimation) { const c = E(n.style.opacity, 1); n.style.opacity = 0, Cs(n, { style: { opacity: c } }, e, s) } if (r.oldLayout = l, n.states.select) { const d = r.oldLayoutSelect = {}; ug(d, l, PN), ug(d, n.states.select, PN) } if (n.states.emphasis) { const f = r.oldLayoutEmphasis = {}; ug(f, l, PN), ug(f, n.states.emphasis, PN) }gl(n, s, u, e, e) } if (i && !i.ignore && !i.invisible) { var r = LN(i); var o = r.oldLayout; const g = { points: i.shape.points }; o ? (i.attr({ shape: o }), Is(i, { shape: g }, e)) : (i.setShape(g), i.style.strokePercent = 0, Cs(i, { style: { strokePercent: 1 } }, e)), r.oldLayout = g } }, t }()); var RN = qr(); ff(hg); const NN = (function (t) { function n (e, n, i) { const r = t.call(this) || this; r.motionBlur = !1, r.lastFrameAlpha = 0.7, r.dpr = 1, r.virtual = !1, r.config = {}, r.incremental = !1, r.zlevel = 0, r.maxRepaintRectCount = 5, r.__dirty = !0, r.__firstTimePaint = !0, r.__used = !1, r.__drawIndex = 0, r.__startIndex = 0, r.__endIndex = 0, r.__prevStartIndex = null, r.__prevEndIndex = null; let o; i = i || sI, typeof e === 'string' ? o = cg(e, n, i) : k(e) && (o = e, e = o.id), r.id = e, r.dom = o; const a = o.style; return a && (K(o), o.onselectstart = function () { return !1 }, a.padding = '0', a.margin = '0', a.borderWidth = '0'), r.painter = n, r.dpr = i, r } return e(n, t), n.prototype.getElementCount = function () { return this.__endIndex - this.__startIndex }, n.prototype.afterBrush = function () { this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex }, n.prototype.initContext = function () { this.ctx = this.dom.getContext('2d'), this.ctx.dpr = this.dpr }, n.prototype.setUnpainted = function () { this.__firstTimePaint = !0 }, n.prototype.createBackBuffer = function () { const t = this.dpr; this.domBack = cg('back-' + this.id, this.painter, t), this.ctxBack = this.domBack.getContext('2d'), t !== 1 && this.ctxBack.scale(t, t) }, n.prototype.createRepaintRects = function (t, e, n, i) { function r (t) { if (t.isFinite() && !t.isZero()) if (o.length === 0) { var e = new $M(0, 0, 0, 0); e.copy(t), o.push(e) } else { for (var n = !1, i = 1 / 0, r = 0, u = 0; u < o.length; ++u) { const h = o[u]; if (h.intersect(t)) { const c = new $M(0, 0, 0, 0); c.copy(h), c.union(t), o[u] = c, n = !0; break } if (s) { l.copy(t), l.union(h); const p = t.width * t.height; const d = h.width * h.height; const f = l.width * l.height; const g = f - p - d; i > g && (i = g, r = u) } } if (s && (o[r].union(t), n = !0), !n) { var e = new $M(0, 0, 0, 0); e.copy(t), o.push(e) }s || (s = o.length >= a) } } if (this.__firstTimePaint) return this.__firstTimePaint = !1, null; for (var o = [], a = this.maxRepaintRectCount, s = !1, l = new $M(0, 0, 0, 0), u = this.__startIndex; u < this.__endIndex; ++u) { var h = t[u]; if (h) { var c = h.shouldBePainted(n, i, !0, !0); var p = h.__isRendered && (h.__dirty & sT || !c) ? h.getPrevPaintRect() : null; p && r(p); const d = c && (h.__dirty & sT || !h.__isRendered) ? h.getPaintRect() : null; d && r(d) } } for (var u = this.__prevStartIndex; u < this.__prevEndIndex; ++u) { var h = e[u]; var c = h.shouldBePainted(n, i, !0, !0); if (h && (!c || !h.__zr) && h.__isRendered) { var p = h.getPrevPaintRect(); p && r(p) } } let f; do { f = !1; for (var u = 0; u < o.length;) if (o[u].isZero())o.splice(u, 1); else { for (let g = u + 1; g < o.length;)o[u].intersect(o[g]) ? (f = !0, o[u].union(o[g]), o.splice(g, 1)) : g++; u++ } } while (f); return this._paintRects = o, o }, n.prototype.debugGetPaintRects = function () { return (this._paintRects || []).slice() }, n.prototype.resize = function (t, e) { const n = this.dpr; const i = this.dom; const r = i.style; const o = this.domBack; r && (r.width = t + 'px', r.height = e + 'px'), i.width = t * n, i.height = e * n, o && (o.width = t * n, o.height = e * n, n !== 1 && this.ctxBack.scale(n, n)) }, n.prototype.clear = function (t, e, n) { function i (t, n, i, r) { if (o.clearRect(t, n, i, r), e && e !== 'transparent') { let a = void 0; if (O(e)) { const s = e.global || e.__width === i && e.__height === r; a = s && e.__canvasGradient || Vc(o, e, { x: 0, y: 0, width: i, height: r }), e.__canvasGradient = a, e.__width = i, e.__height = r } else R(e) && (e.scaleX = e.scaleX || h, e.scaleY = e.scaleY || h, a = Kc(o, e, { dirty: function () { c.setUnpainted(), c.__painter.refresh() } })); o.save(), o.fillStyle = a || e, o.fillRect(t, n, i, r), o.restore() }l && (o.save(), o.globalAlpha = u, o.drawImage(p, t, n, i, r), o.restore()) } const r = this.dom; var o = this.ctx; const a = r.width; const s = r.height; e = e || this.clearColor; var l = this.motionBlur && !t; var u = this.lastFrameAlpha; var h = this.dpr; var c = this; l && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = 'copy', this.ctxBack.drawImage(r, 0, 0, a / h, s / h)); var p = this.domBack; !n || l ? i(0, 0, a, s) : n.length && y(n, function (t) { i(t.x * h, t.y * h, t.width * h, t.height * h) }) }, n }(kM)); const zN = 1e5; const BN = 314159; const EN = 0.01; const VN = 0.001; var FN = (function () { function t (t, e, n) { this.type = 'canvas', this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = 'canvas'; const i = !t.nodeName || t.nodeName.toUpperCase() === 'CANVAS'; this._opts = n = h({}, n || {}), this.dpr = n.devicePixelRatio || sI, this._singleCanvas = i, this.root = t; const r = t.style; r && (K(t), t.innerHTML = ''), this.storage = e; const o = this._zlevelList; this._prevDisplayList = []; const a = this._layers; if (i) { const s = t; let l = s.width; let u = s.height; n.width != null && (l = n.width), n.height != null && (u = n.height), this.dpr = n.devicePixelRatio || 1, s.width = l * this.dpr, s.height = u * this.dpr, this._width = l, this._height = u; const c = new NN(s, this, this.dpr); c.__builtin__ = !0, c.initContext(), a[BN] = c, c.zlevel = BN, o.push(BN), this._domRoot = t } else { this._width = Wc(t, 0, n), this._height = Wc(t, 1, n); const p = this._domRoot = dg(this._width, this._height); t.appendChild(p) } } return t.prototype.getType = function () { return 'canvas' }, t.prototype.isSingleCanvas = function () { return this._singleCanvas }, t.prototype.getViewportRoot = function () { return this._domRoot }, t.prototype.getViewportRootOffset = function () { const t = this.getViewportRoot(); return t ? { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 } : void 0 }, t.prototype.refresh = function (t) { const e = this.storage.getDisplayList(!0); const n = this._prevDisplayList; const i = this._zlevelList; this._redrawId = Math.random(), this._paintList(e, n, t, this._redrawId); for (let r = 0; r < i.length; r++) { const o = i[r]; const a = this._layers[o]; if (!a.__builtin__ && a.refresh) { const s = r === 0 ? this._backgroundColor : null; a.refresh(s) } } return this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this }, t.prototype.refreshHover = function () { this._paintHoverList(this.storage.getDisplayList(!1)) }, t.prototype._paintHoverList = function (t) { const e = t.length; let n = this._hoverlayer; if (n && n.clear(), e) { for (var i, r = { inHover: !0, viewWidth: this._width, viewHeight: this._height }, o = 0; e > o; o++) { const a = t[o]; a.__inHover && (n || (n = this._hoverlayer = this.getLayer(zN)), i || (i = n.ctx, i.save()), hp(i, a, r, o === e - 1)) }i && i.restore() } }, t.prototype.getHoverLayer = function () { return this.getLayer(zN) }, t.prototype.paintOne = function (t, e) { up(t, e) }, t.prototype._paintList = function (t, e, n, i) { if (this._redrawId === i) { n = n || !1, this._updateLayerStatus(t); const r = this._doPaintList(t, e, n); const o = r.finished; const a = r.needsRefreshHover; if (this._needsManuallyCompositing && this._compositeManually(), a && this._paintHoverList(t), o) this.eachLayer(function (t) { t.afterBrush && t.afterBrush() }); else { const s = this; pT(function () { s._paintList(t, e, n, i) }) } } }, t.prototype._compositeManually = function () { const t = this.getLayer(BN).ctx; const e = this._domRoot.width; const n = this._domRoot.height; t.clearRect(0, 0, e, n), this.eachBuiltinLayer(function (i) { i.virtual && t.drawImage(i.dom, 0, 0, e, n) }) }, t.prototype._doPaintList = function (t, e, n) { for (var i = this, r = [], o = this._opts.useDirtyRect, a = 0; a < this._zlevelList.length; a++) { const s = this._zlevelList[a]; const l = this._layers[s]; l.__builtin__ && l !== this._hoverlayer && (l.__dirty || n) && r.push(l) } for (var u = !0, h = !1, c = function (a) { const s = r[a]; const l = s.ctx; const c = o && s.createRepaintRects(t, e, p._width, p._height); let d = n ? s.__startIndex : s.__drawIndex; const f = !n && s.incremental && Date.now; const g = f && Date.now(); const y = s.zlevel === p._zlevelList[0] ? p._backgroundColor : null; if (s.__startIndex === s.__endIndex)s.clear(!1, y, c); else if (d === s.__startIndex) { const v = t[d]; v.incremental && v.notClear && !n || s.clear(!1, y, c) }d === -1 && (console.error('For some unknown reason. drawIndex is -1'), d = s.__startIndex); let m; const _ = function (e) { const n = { inHover: !1, allClipped: !1, prevEl: null, viewWidth: i._width, viewHeight: i._height }; for (m = d; m < s.__endIndex; m++) { const r = t[m]; if (r.__inHover && (h = !0), i._doPaintEl(r, s, o, e, n, m === s.__endIndex - 1), f) { const a = Date.now() - g; if (a > 15) break } }n.prevElClipPaths && l.restore() }; if (c) if (c.length === 0)m = s.__endIndex; else for (let x = p.dpr, w = 0; w < c.length; ++w) { const b = c[w]; l.save(), l.beginPath(), l.rect(b.x * x, b.y * x, b.width * x, b.height * x), l.clip(), _(b), l.restore() } else l.save(), _(), l.restore(); s.__drawIndex = m, s.__drawIndex < s.__endIndex && (u = !1) }, p = this, d = 0; d < r.length; d++)c(d); return ZS.wxa && y(this._layers, function (t) { t && t.ctx && t.ctx.draw && t.ctx.draw() }), { finished: u, needsRefreshHover: h } }, t.prototype._doPaintEl = function (t, e, n, i, r, o) { const a = e.ctx; if (n) { const s = t.getPaintRect(); (!i || s && s.intersect(i)) && (hp(a, t, r, o), t.setPrevPaintRect(s)) } else hp(a, t, r, o) }, t.prototype.getLayer = function (t, e) { this._singleCanvas && !this._needsManuallyCompositing && (t = BN); let n = this._layers[t]; return n || (n = new NN('zr_' + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? l(n, this._layerConfig[t], !0) : this._layerConfig[t - EN] && l(n, this._layerConfig[t - EN], !0), e && (n.virtual = e), this.insertLayer(t, n), n.initContext()), n }, t.prototype.insertLayer = function (t, e) { const n = this._layers; const i = this._zlevelList; const r = i.length; const o = this._domRoot; let a = null; let s = -1; if (!n[t] && pg(e)) { if (r > 0 && t > i[0]) { for (s = 0; r - 1 > s && !(i[s] < t && i[s + 1] > t); s++);a = n[i[s]] } if (i.splice(s + 1, 0, t), n[t] = e, !e.virtual) if (a) { const l = a.dom; l.nextSibling ? o.insertBefore(e.dom, l.nextSibling) : o.appendChild(e.dom) } else o.firstChild ? o.insertBefore(e.dom, o.firstChild) : o.appendChild(e.dom); e.__painter = this } }, t.prototype.eachLayer = function (t, e) { for (let n = this._zlevelList, i = 0; i < n.length; i++) { const r = n[i]; t.call(e, this._layers[r], r) } }, t.prototype.eachBuiltinLayer = function (t, e) { for (let n = this._zlevelList, i = 0; i < n.length; i++) { const r = n[i]; const o = this._layers[r]; o.__builtin__ && t.call(e, o, r) } }, t.prototype.eachOtherLayer = function (t, e) { for (let n = this._zlevelList, i = 0; i < n.length; i++) { const r = n[i]; const o = this._layers[r]; o.__builtin__ || t.call(e, o, r) } }, t.prototype.getLayers = function () { return this._layers }, t.prototype._updateLayerStatus = function (t) { function e (t) { s && (s.__endIndex !== t && (s.__dirty = !0), s.__endIndex = t) } if (this.eachBuiltinLayer(function (t) { t.__dirty = t.__used = !1 }), this._singleCanvas) for (let n = 1; n < t.length; n++) { var i = t[n]; if (i.zlevel !== t[n - 1].zlevel || i.incremental) { this._needsManuallyCompositing = !0; break } } let r; let o; var s = null; let l = 0; for (o = 0; o < t.length; o++) { var i = t[o]; const u = i.zlevel; let h = void 0; r !== u && (r = u, l = 0), i.incremental ? (h = this.getLayer(u + VN, this._needsManuallyCompositing), h.incremental = !0, l = 1) : h = this.getLayer(u + (l > 0 ? EN : 0), this._needsManuallyCompositing), h.__builtin__ || a('ZLevel ' + u + ' has been used by unkown layer ' + h.id), h !== s && (h.__used = !0, h.__startIndex !== o && (h.__dirty = !0), h.__startIndex = o, h.__drawIndex = h.incremental ? -1 : o, e(o), s = h), i.__dirty & sT && !i.__inHover && (h.__dirty = !0, h.incremental && h.__drawIndex < 0 && (h.__drawIndex = o)) }e(o), this.eachBuiltinLayer(function (t) { !t.__used && t.getElementCount() > 0 && (t.__dirty = !0, t.__startIndex = t.__endIndex = t.__drawIndex = 0), t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex) }) }, t.prototype.clear = function () { return this.eachBuiltinLayer(this._clearLayer), this }, t.prototype._clearLayer = function (t) { t.clear() }, t.prototype.setBackgroundColor = function (t) { this._backgroundColor = t, y(this._layers, function (t) { t.setUnpainted() }) }, t.prototype.configLayer = function (t, e) { if (e) { const n = this._layerConfig; n[t] ? l(n[t], e, !0) : n[t] = e; for (let i = 0; i < this._zlevelList.length; i++) { const r = this._zlevelList[i]; if (r === t || r === t + EN) { const o = this._layers[r]; l(o, n[t], !0) } } } }, t.prototype.delLayer = function (t) { const e = this._layers; const n = this._zlevelList; const i = e[t]; i && (i.dom.parentNode.removeChild(i.dom), delete e[t], n.splice(p(n, t), 1)) }, t.prototype.resize = function (t, e) { if (this._domRoot.style) { const n = this._domRoot; n.style.display = 'none'; const i = this._opts; const r = this.root; if (t != null && (i.width = t), e != null && (i.height = e), t = Wc(r, 0, i), e = Wc(r, 1, i), n.style.display = '', this._width !== t || e !== this._height) { n.style.width = t + 'px', n.style.height = e + 'px'; for (const o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e); this.refresh(!0) } this._width = t, this._height = e } else { if (t == null || e == null) return; this._width = t, this._height = e, this.getLayer(BN).resize(t, e) } return this }, t.prototype.clearLayer = function (t) { const e = this._layers[t]; e && e.clear() }, t.prototype.dispose = function () { this.root.innerHTML = '', this.root = this.storage = this._domRoot = this._layers = null }, t.prototype.getRenderedCanvas = function (t) { if (t = t || {}, this._singleCanvas && !this._compositeManually) return this._layers[BN].dom; const e = new NN('image', this, t.pixelRatio || this.dpr); e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor); const n = e.ctx; if (t.pixelRatio <= this.dpr) { this.refresh(); const i = e.dom.width; const r = e.dom.height; this.eachLayer(function (t) { t.__builtin__ ? n.drawImage(t.dom, 0, 0, i, r) : t.renderToCanvas && (n.save(), t.renderToCanvas(n), n.restore()) }) } else for (let o = { inHover: !1, viewWidth: this._width, viewHeight: this._height }, a = this.storage.getDisplayList(!0), s = 0, l = a.length; l > s; s++) { const u = a[s]; hp(n, u, o, s === l - 1) } return e.dom }, t.prototype.getWidth = function () { return this._width }, t.prototype.getHeight = function () { return this._height }, t }()); var HN = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = 'dataset', e } return e(n, t), n.prototype.init = function (e, n, i) { t.prototype.init.call(this, e, n, i), this._sourceManager = new BL(this), kh(this) }, n.prototype.mergeOption = function (e, n) { t.prototype.mergeOption.call(this, e, n), kh(this) }, n.prototype.optionUpdated = function () { this._sourceManager.dirty() }, n.prototype.getSourceManager = function () { return this._sourceManager }, n.type = 'dataset', n.defaultOption = { seriesLayoutBy: FA }, n }(CA)); var WN = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = 'dataset', e } return e(n, t), n.type = 'dataset', n }(YL)); ff([fg, gg]), ff(hg); var GN = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.hasSymbolVisual = !0, e } return e(n, t), n.prototype.getInitialData = function () { return gd(null, this, { useEncodeDefaulter: !0 }) }, n.prototype.getProgressive = function () { const t = this.option.progressive; return t == null ? this.option.large ? 5e3 : this.get('progressive') : t }, n.prototype.getProgressiveThreshold = function () { const t = this.option.progressiveThreshold; return t == null ? this.option.large ? 1e4 : this.get('progressiveThreshold') : t }, n.prototype.brushSelector = function (t, e, n) { return n.point(e.getItemLayout(t)) }, n.prototype.getZLevelKey = function () { return this.getData().count() > this.getProgressiveThreshold() ? this.id : '' }, n.type = 'series.scatter', n.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'], n.defaultOption = { coordinateSystem: 'cartesian2d', z: 2, legendHoverLink: !0, symbolSize: 10, large: !1, largeThreshold: 2e3, itemStyle: { opacity: 0.8 }, emphasis: { scale: !0 }, clip: !0, select: { itemStyle: { borderColor: '#212121' } }, universalTransition: { divideShape: 'clone' } }, n }(XL)); var XN = (function (t) { function n (e, n, i, r) { const o = t.call(this) || this; return o.updateData(e, n, i, r), o } return e(n, t), n.prototype._createSymbol = function (t, e, n, i, r) { this.removeAll(); const o = Oc(t, -1, -1, 2, 2, null, r); o.attr({ z2: 100, culling: !0, scaleX: i[0] / 2, scaleY: i[1] / 2 }), o.drift = vg, this._symbolType = t, this.add(o) }, n.prototype.stopSymbolAnimation = function (t) { this.childAt(0).stopAnimation(null, t) }, n.prototype.getSymbolType = function () { return this._symbolType }, n.prototype.getSymbolPath = function () { return this.childAt(0) }, n.prototype.highlight = function () { Pa(this.childAt(0)) }, n.prototype.downplay = function () { Oa(this.childAt(0)) }, n.prototype.setZ = function (t, e) { const n = this.childAt(0); n.zlevel = t, n.z = e }, n.prototype.setDraggable = function (t, e) { const n = this.childAt(0); n.draggable = t, n.cursor = !e && t ? 'move' : n.cursor }, n.prototype.updateData = function (t, e, i, r) { this.silent = !1; const o = t.getItemVisual(e, 'symbol') || 'circle'; const a = t.hostModel; const s = n.getSymbolSize(t, e); const l = o !== this._symbolType; const u = r && r.disableAnimation; if (l) { const h = t.getItemVisual(e, 'symbolKeepAspect'); this._createSymbol(o, t, e, s, h) } else { var c = this.childAt(0); c.silent = !1; var p = { scaleX: s[0] / 2, scaleY: s[1] / 2 }; u ? c.attr(p) : Is(c, p, a, e), Ps(c) } if (this._updateCommon(t, e, s, i, r), l) { var c = this.childAt(0); if (!u) { var p = { scaleX: this._sizeX, scaleY: this._sizeY, style: { opacity: c.style.opacity } }; c.scaleX = c.scaleY = 0, c.style.opacity = 0, Cs(c, p, a, e) } }u && this.childAt(0).stopAnimation('leave') }, n.prototype._updateCommon = function (t, e, n, i, r) { function o (e) { return C ? t.getName(e) : yg(t, e) } let a; let s; let l; let u; let c; let p; let d; let f; let g; const y = this.childAt(0); const v = t.hostModel; if (i && (a = i.emphasisItemStyle, s = i.blurItemStyle, l = i.selectItemStyle, u = i.focus, c = i.blurScope, d = i.labelStatesModels, f = i.hoverScale, g = i.cursorStyle, p = i.emphasisDisabled), !i || t.hasItemOption) { const m = i && i.itemModel ? i.itemModel : t.getItemModel(e); const _ = m.getModel('emphasis'); a = _.getModel('itemStyle').getItemStyle(), l = m.getModel(['select', 'itemStyle']).getItemStyle(), s = m.getModel(['blur', 'itemStyle']).getItemStyle(), u = _.get('focus'), c = _.get('blurScope'), p = _.get('disabled'), d = ll(m), f = _.getShallow('scale'), g = m.getShallow('cursor') } const x = t.getItemVisual(e, 'symbolRotate'); y.attr('rotation', (x || 0) * Math.PI / 180 || 0); const w = Nc(t.getItemVisual(e, 'symbolOffset'), n); w && (y.x = w[0], y.y = w[1]), g && y.attr('cursor', g); const b = t.getItemVisual(e, 'style'); const S = b.fill; if (y instanceof QC) { const M = y.style; y.useStyle(h({ image: M.image, x: M.x, y: M.y, width: M.width, height: M.height }, b)) } else y.useStyle(y.__isEmptyBrush ? h({}, b) : b), y.style.decal = null, y.setColor(S, r && r.symbolInnerColor), y.style.strokeNoScale = !0; const T = t.getItemVisual(e, 'liftZ'); const I = this._z2; T != null ? I == null && (this._z2 = y.z2, y.z2 += T) : I != null && (y.z2 = I, this._z2 = null); var C = r && r.useNameLabel; sl(y, d, { labelFetcher: v, labelDataIndex: e, defaultText: o, inheritColor: S, defaultOpacity: b.opacity }), this._sizeX = n[0] / 2, this._sizeY = n[1] / 2; const D = y.ensureState('emphasis'); D.style = a, y.ensureState('select').style = l, y.ensureState('blur').style = s; const k = f == null || f === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(f) && f > 0 ? +f : 1; D.scaleX = this._sizeX * k, D.scaleY = this._sizeY * k, this.setSymbolScale(1), $a(this, u, c, p) }, n.prototype.setSymbolScale = function (t) { this.scaleX = this.scaleY = t }, n.prototype.fadeOut = function (t, e, n) { const i = this.childAt(0); const r = hD(this).dataIndex; const o = n && n.animation; if (this.silent = i.silent = !0, n && n.fadeLabel) { const a = i.getTextContent(); a && ks(a, { style: { opacity: 0 } }, e, { dataIndex: r, removeOpt: o, cb: function () { i.removeTextContent() } }) } else i.removeTextContent(); ks(i, { style: { opacity: 0 }, scaleX: 0, scaleY: 0 }, e, { dataIndex: r, cb: t, removeOpt: o }) }, n.getSymbolSize = function (t, e) { return Rc(t.getItemVisual(e, 'symbolSize')) }, n }(CI)); const YN = (function () { function t (t) { this.group = new CI(), this._SymbolCtor = t || XN } return t.prototype.updateData = function (t, e) { this._progressiveEls = null, e = _g(e); const n = this.group; const i = t.hostModel; const r = this._data; const o = this._SymbolCtor; const a = e.disableAnimation; const s = xg(t); const l = { disableAnimation: a }; const u = e.getSymbolPoint || function (e) { return t.getItemLayout(e) }; r || n.removeAll(), t.diff(r).add(function (i) { const r = u(i); if (mg(t, r, i, e)) { const a = new o(t, i, s, l); a.setPosition(r), t.setItemGraphicEl(i, a), n.add(a) } }).update(function (h, c) { let p = r.getItemGraphicEl(c); const d = u(h); if (!mg(t, d, h, e)) return void n.remove(p); const f = t.getItemVisual(h, 'symbol') || 'circle'; const g = p && p.getSymbolType && p.getSymbolType(); if (!p || g && g !== f)n.remove(p), p = new o(t, h, s, l), p.setPosition(d); else { p.updateData(t, h, s, l); const y = { x: d[0], y: d[1] }; a ? p.attr(y) : Is(p, y, i) }n.add(p), t.setItemGraphicEl(h, p) }).remove(function (t) { const e = r.getItemGraphicEl(t); e && e.fadeOut(function () { n.remove(e) }, i) }).execute(), this._getSymbolPoint = u, this._data = t }, t.prototype.updateLayout = function () { const t = this; const e = this._data; e && e.eachItemGraphicEl(function (e, n) { const i = t._getSymbolPoint(n); e.setPosition(i), e.markRedraw() }) }, t.prototype.incrementalPrepareUpdate = function (t) { this._seriesScope = xg(t), this._data = null, this.group.removeAll() }, t.prototype.incrementalUpdate = function (t, e, n) { function i (t) { t.isGroup || (t.incremental = !0, t.ensureState('emphasis').hoverLayer = !0) } this._progressiveEls = [], n = _g(n); for (let r = t.start; r < t.end; r++) { const o = e.getItemLayout(r); if (mg(e, o, r, n)) { const a = new this._SymbolCtor(e, r, this._seriesScope); a.traverse(i), a.setPosition(o), this.group.add(a), e.setItemGraphicEl(r, a), this._progressiveEls.push(a) } } }, t.prototype.eachRendered = function (t) { rl(this._progressiveEls || this.group, t) }, t.prototype.remove = function (t) { const e = this.group; const n = this._data; n && t ? n.eachItemGraphicEl(function (t) { t.fadeOut(function () { e.remove(t) }, n.hostModel) }) : e.removeAll() }, t }()); const UN = 4; const ZN = (function () { function t () {} return t }()); const jN = (function (t) {
    function n (e) { const n = t.call(this, e) || this; return n._off = 0, n.hoverDataIdx = -1, n } return e(n, t), n.prototype.getDefaultShape = function () { return new ZN() }, n.prototype.reset = function () { this.notClear = !1, this._off = 0 }, n.prototype.buildPath = function (t, e) { let n; const i = e.points; const r = e.size; const o = this.symbolProxy; const a = o.shape; const s = t.getContext ? t.getContext() : t; const l = s && r[0] < UN; const u = this.softClipShape; if (l) return void (this._ctx = s); for (this._ctx = null, n = this._off; n < i.length;) { const h = i[n++]; const c = i[n++]; isNaN(h) || isNaN(c) || (!u || u.contain(h, c)) && (a.x = h - r[0] / 2, a.y = c - r[1] / 2, a.width = r[0], a.height = r[1], o.buildPath(t, a, !0)) } this.incremental && (this._off = n, this.notClear = !0) }, n.prototype.afterBrush = function () { let t; const e = this.shape; const n = e.points; const i = e.size; const r = this._ctx; const o = this.softClipShape; if (r) { for (t = this._off; t < n.length;) { const a = n[t++]; const s = n[t++]; isNaN(a) || isNaN(s) || (!o || o.contain(a, s)) && r.fillRect(a - i[0] / 2, s - i[1] / 2, i[0], i[1]) } this.incremental && (this._off = t, this.notClear = !0) } }, n.prototype.findDataIndex = function (t, e) { for (let n = this.shape, i = n.points, r = n.size, o = Math.max(r[0], 4), a = Math.max(r[1], 4), s = i.length / 2 - 1; s >= 0; s--) { const l = 2 * s; const u = i[l] - o / 2; const h = i[l + 1] - a / 2; if (t >= u && e >= h && u + o >= t && h + a >= e) return s } return -1 }, n.prototype.contain = function (t, e) { const n = this.transformCoordToLocal(t, e); const i = this.getBoundingRect(); if (t = n[0], e = n[1], i.contain(t, e)) { const r = this.hoverDataIdx = this.findDataIndex(t, e); return r >= 0 } return this.hoverDataIdx = -1, !1 }, n.prototype.getBoundingRect = function () {
      let t = this._rect; if (!t) {
        for (var e = this.shape, n = e.points, i = e.size, r = i[0], o = i[1], a = 1 / 0, s = 1 / 0, l = -1 / 0, u = -1 / 0, h = 0; h < n.length;) {
          const c = n[h++]; const p = n[h++]
          a = Math.min(c, a), l = Math.max(c, l), s = Math.min(p, s), u = Math.max(p, u)
        }t = this._rect = new $M(a - r / 2, s - o / 2, l - a + r, u - s + o)
      } return t
    }, n
  }(ZC)); const qN = (function () { function t () { this.group = new CI() } return t.prototype.updateData = function (t, e) { this._clear(); const n = this._create(); n.setShape({ points: t.getLayout('points') }), this._setCommon(n, t, e) }, t.prototype.updateLayout = function (t) { let e = t.getLayout('points'); this.group.eachChild(function (t) { if (t.startIndex != null) { const n = 2 * (t.endIndex - t.startIndex); const i = 4 * t.startIndex * 2; e = new Float32Array(e.buffer, i, n) }t.setShape('points', e), t.reset() }) }, t.prototype.incrementalPrepareUpdate = function () { this._clear() }, t.prototype.incrementalUpdate = function (t, e, n) { const i = this._newAdded[0]; const r = e.getLayout('points'); const o = i && i.shape.points; if (o && o.length < 2e4) { const a = o.length; const s = new Float32Array(a + r.length); s.set(o), s.set(r, a), i.endIndex = t.end, i.setShape({ points: s }) } else { this._newAdded = []; const l = this._create(); l.startIndex = t.start, l.endIndex = t.end, l.incremental = !0, l.setShape({ points: r }), this._setCommon(l, e, n) } }, t.prototype.eachRendered = function (t) { this._newAdded[0] && t(this._newAdded[0]) }, t.prototype._create = function () { const t = new jN({ cursor: 'default' }); return t.ignoreCoarsePointer = !0, this.group.add(t), this._newAdded.push(t), t }, t.prototype._setCommon = function (t, e, n) { const i = e.hostModel; n = n || {}; const r = e.getVisual('symbolSize'); t.setShape('size', r instanceof Array ? r : [r, r]), t.softClipShape = n.clipShape || null, t.symbolProxy = Oc(e.getVisual('symbol'), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor; const o = t.shape.size[0] < UN; t.useStyle(i.getModel('itemStyle').getItemStyle(o ? ['color', 'shadowBlur', 'shadowColor'] : ['color'])); const a = e.getVisual('style'); const s = a && a.fill; s && t.setColor(s); const l = hD(t); l.seriesIndex = i.seriesIndex, t.on('mousemove', function () { l.dataIndex = null; const e = t.hoverDataIdx; e >= 0 && (l.dataIndex = e + (t.startIndex || 0)) }) }, t.prototype.remove = function () { this._clear() }, t.prototype._clear = function () { this._newAdded = [], this.group.removeAll() }, t }()); var KN = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.render = function (t) { const e = t.getData(); const n = this._updateSymbolDraw(e, t); n.updateData(e, { clipShape: this._getClipShape(t) }), this._finished = !0 }, n.prototype.incrementalPrepareRender = function (t) { const e = t.getData(); const n = this._updateSymbolDraw(e, t); n.incrementalPrepareUpdate(e), this._finished = !1 }, n.prototype.incrementalRender = function (t, e) { this._symbolDraw.incrementalUpdate(t, e.getData(), { clipShape: this._getClipShape(e) }), this._finished = t.end === e.getData().count() }, n.prototype.updateTransform = function (t, e, n) { const i = t.getData(); if (this.group.dirty(), !this._finished || i.count() > 1e4) return { update: !0 }; const r = wg('').reset(t, e, n); r.progress && r.progress({ start: 0, end: i.count(), count: i.count() }, i), this._symbolDraw.updateLayout(i) }, n.prototype.eachRendered = function (t) { this._symbolDraw && this._symbolDraw.eachRendered(t) }, n.prototype._getClipShape = function (t) { const e = t.coordinateSystem; const n = e && e.getArea && e.getArea(); return t.get('clip', !0) ? n : null }, n.prototype._updateSymbolDraw = function (t, e) { let n = this._symbolDraw; const i = e.pipelineContext; const r = i.large; return n && r === this._isLargeDraw || (n && n.remove(), n = this._symbolDraw = r ? new qN() : new YN(), this._isLargeDraw = r, this.group.removeAll()), this.group.add(n.group), n }, n.prototype.remove = function () { this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null }, n.prototype.dispose = function () {}, n.type = 'scatter', n }(jL)); var $N = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.type = 'grid', n.dependencies = ['xAxis', 'yAxis'], n.layoutMode = 'box', n.defaultOption = { show: !1, z: 0, left: '10%', top: 60, right: '10%', bottom: 70, containLabel: !1, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' }, n }(CA)); var QN = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.getCoordSysModel = function () { return this.getReferringComponents('grid', HI).models[0] }, n.type = 'cartesian2dAxis', n }(CA)); f(QN, QR); const JN = { show: !0, z: 0, inverse: !1, name: '', nameLocation: 'end', nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: '...', placeholder: '.' }, nameTextStyle: {}, nameGap: 15, silent: !1, triggerEvent: !1, tooltip: { show: !1 }, axisPointer: {}, axisLine: { show: !0, onZero: !0, onZeroAxisIndex: null, lineStyle: { color: '#6E7079', width: 1, type: 'solid' }, symbol: ['none', 'none'], symbolSize: [10, 15] }, axisTick: { show: !0, inside: !1, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12 }, splitLine: { show: !0, lineStyle: { color: ['#E0E6F1'], width: 1, type: 'solid' } }, splitArea: { show: !1, areaStyle: { color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)'] } } }; const tz = l({ boundaryGap: !0, deduplication: null, splitLine: { show: !1 }, axisTick: { alignWithLabel: !1, interval: 'auto' }, axisLabel: { interval: 'auto' } }, JN); const ez = l({ boundaryGap: [0, 0], axisLine: { show: 'auto' }, axisTick: { show: 'auto' }, splitNumber: 5, minorTick: { show: !1, splitNumber: 5, length: 3, lineStyle: {} }, minorSplitLine: { show: !1, lineStyle: { color: '#F4F7FD', width: 1 } } }, JN); const nz = l({ splitNumber: 6, axisLabel: { showMinLabel: !1, showMaxLabel: !1, rich: { primary: { fontWeight: 'bold' } } }, splitLine: { show: !1 } }, ez); const iz = c({ logBase: 10 }, ez); var rz = { category: tz, value: ez, time: nz, log: iz }; var oz = { value: 1, category: 1, time: 1, log: 1 }; const az = (function () { function t (t) { this.type = 'cartesian', this._dimList = [], this._axes = {}, this.name = t || '' } return t.prototype.getAxis = function (t) { return this._axes[t] }, t.prototype.getAxes = function () { return v(this._dimList, function (t) { return this._axes[t] }, this) }, t.prototype.getAxesByScale = function (t) { return t = t.toLowerCase(), _(this.getAxes(), function (e) { return e.scale.type === t }) }, t.prototype.addAxis = function (t) { const e = t.dim; this._axes[e] = t, this._dimList.push(e) }, t }()); const sz = ['x', 'y']; const lz = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = 'cartesian2d', e.dimensions = sz, e } return e(n, t), n.prototype.calcAffineTransform = function () { this._transform = this._invTransform = null; const t = this.getAxis('x').scale; const e = this.getAxis('y').scale; if (Mg(t) && Mg(e)) { const n = t.getExtent(); const i = e.getExtent(); const r = this.dataToPoint([n[0], i[0]]); const o = this.dataToPoint([n[1], i[1]]); const a = n[1] - n[0]; const s = i[1] - i[0]; if (a && s) { const l = (o[0] - r[0]) / a; const u = (o[1] - r[1]) / s; const h = r[0] - n[0] * l; const c = r[1] - i[0] * u; const p = this._transform = [l, 0, 0, u, h, c]; this._invTransform = Ye([], p) } } }, n.prototype.getBaseAxis = function () { return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x') }, n.prototype.containPoint = function (t) { const e = this.getAxis('x'); const n = this.getAxis('y'); return e.contain(e.toLocalCoord(t[0])) && n.contain(n.toLocalCoord(t[1])) }, n.prototype.containData = function (t) { return this.getAxis('x').containData(t[0]) && this.getAxis('y').containData(t[1]) }, n.prototype.containZone = function (t, e) { const n = this.dataToPoint(t); const i = this.dataToPoint(e); const r = this.getArea(); const o = new $M(n[0], n[1], i[0] - n[0], i[1] - n[1]); return r.intersect(o) }, n.prototype.dataToPoint = function (t, e, n) { n = n || []; const i = t[0]; const r = t[1]; if (this._transform && i != null && isFinite(i) && r != null && isFinite(r)) return ve(n, t, this._transform); const o = this.getAxis('x'); const a = this.getAxis('y'); return n[0] = o.toGlobalCoord(o.dataToCoord(i, e)), n[1] = a.toGlobalCoord(a.dataToCoord(r, e)), n }, n.prototype.clampData = function (t, e) { const n = this.getAxis('x').scale; const i = this.getAxis('y').scale; const r = n.getExtent(); const o = i.getExtent(); const a = n.parse(t[0]); const s = i.parse(t[1]); return e = e || [], e[0] = Math.min(Math.max(Math.min(r[0], r[1]), a), Math.max(r[0], r[1])), e[1] = Math.min(Math.max(Math.min(o[0], o[1]), s), Math.max(o[0], o[1])), e }, n.prototype.pointToData = function (t, e) { const n = []; if (this._invTransform) return ve(n, t, this._invTransform); const i = this.getAxis('x'); const r = this.getAxis('y'); return n[0] = i.coordToData(i.toLocalCoord(t[0]), e), n[1] = r.coordToData(r.toLocalCoord(t[1]), e), n }, n.prototype.getOtherAxis = function (t) { return this.getAxis(t.dim === 'x' ? 'y' : 'x') }, n.prototype.getArea = function () { const t = this.getAxis('x').getGlobalExtent(); const e = this.getAxis('y').getGlobalExtent(); const n = Math.min(t[0], t[1]); const i = Math.min(e[0], e[1]); const r = Math.max(t[0], t[1]) - n; const o = Math.max(e[0], e[1]) - i; return new $M(n, i, r, o) }, n }(az)); const uz = (function (t) { function n (e, n, i, r, o) { const a = t.call(this, e, n, i) || this; return a.index = 0, a.type = r || 'value', a.position = o || 'bottom', a } return e(n, t), n.prototype.isHorizontal = function () { const t = this.position; return t === 'top' || t === 'bottom' }, n.prototype.getGlobalExtent = function (t) { const e = this.getExtent(); return e[0] = this.toGlobalCoord(e[0]), e[1] = this.toGlobalCoord(e[1]), t && e[0] > e[1] && e.reverse(), e }, n.prototype.pointToData = function (t, e) { return this.coordToData(this.toLocalCoord(t[this.dim === 'x' ? 0 : 1]), e) }, n.prototype.setCategorySortInfo = function (t) { return this.type !== 'category' ? !1 : (this.model.option.categorySortInfo = t, void this.scale.setSortInfo(t)) }, n }(yN)); var hz = Math.log; var cz = (function () { function t (t, e, n) { this.type = 'grid', this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = sz, this._initCartesian(t, e, n), this.model = t } return t.prototype.getRect = function () { return this._rect }, t.prototype.update = function (t, e) { function n (t) { let e; const n = w(t); const i = n.length; if (i) { for (var r = [], o = i - 1; o >= 0; o--) { const a = +n[o]; const s = t[a]; const l = s.model; const u = s.scale; _d(u) && l.get('alignTicks') && l.get('interval') == null ? r.push(s) : (Qd(u, l), _d(u) && (e = s)) }r.length && (e || (e = r.pop(), Qd(e.scale, e.model)), y(r, function (t) { Dg(t.scale, t.model, e.scale) })) } } const i = this._axesMap; this._updateScale(t, this.model), n(i.x), n(i.y); const r = {}; y(i.x, function (t) { Ag(i, 'y', t, r) }), y(i.y, function (t) { Ag(i, 'x', t, r) }), this.resize(this.model, e) }, t.prototype.resize = function (t, e, n) { function i () { y(s, function (t) { const e = t.isHorizontal(); const n = e ? [0, a.width] : [0, a.height]; const i = t.inverse ? 1 : 0; t.setExtent(n[i], n[1 - i]), Pg(t, e ? a.x : a.y) }) } const r = t.getBoxLayoutParams(); const o = !n && t.get('containLabel'); var a = ru(r, { width: e.getWidth(), height: e.getHeight() }); this._rect = a; var s = this._axesList; i(), o && (y(s, function (t) { if (!t.model.get(['axisLabel', 'inside'])) { const e = rf(t); if (e) { const n = t.isHorizontal() ? 'height' : 'width'; const i = t.model.get(['axisLabel', 'margin']); a[n] -= e[n] + i, t.position === 'top' ? a.y += e.height + i : t.position === 'left' && (a.x += e.width + i) } } }), i()), y(this._coordsList, function (t) { t.calcAffineTransform() }) }, t.prototype.getAxis = function (t, e) { const n = this._axesMap[t]; return n != null ? n[e || 0] : void 0 }, t.prototype.getAxes = function () { return this._axesList.slice() }, t.prototype.getCartesian = function (t, e) { if (t != null && e != null) { const n = 'x' + t + 'y' + e; return this._coordsMap[n] }k(t) && (e = t.yAxisIndex, t = t.xAxisIndex); for (let i = 0, r = this._coordsList; i < r.length; i++) if (r[i].getAxis('x').index === t || r[i].getAxis('y').index === e) return r[i] }, t.prototype.getCartesians = function () { return this._coordsList.slice() }, t.prototype.convertToPixel = function (t, e, n) { const i = this._findConvertTarget(e); return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null }, t.prototype.convertFromPixel = function (t, e, n) { const i = this._findConvertTarget(e); return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null }, t.prototype._findConvertTarget = function (t) { let e; let n; const i = t.seriesModel; const r = t.xAxisModel || i && i.getReferringComponents('xAxis', HI).models[0]; const o = t.yAxisModel || i && i.getReferringComponents('yAxis', HI).models[0]; const a = t.gridModel; const s = this._coordsList; if (i)e = i.coordinateSystem, p(s, e) < 0 && (e = null); else if (r && o)e = this.getCartesian(r.componentIndex, o.componentIndex); else if (r)n = this.getAxis('x', r.componentIndex); else if (o)n = this.getAxis('y', o.componentIndex); else if (a) { const l = a.coordinateSystem; l === this && (e = this._coordsList[0]) } return { cartesian: e, axis: n } }, t.prototype.containPoint = function (t) { const e = this._coordsList[0]; return e ? e.containPoint(t) : void 0 }, t.prototype._initCartesian = function (t, e) { function n (e) { return function (n, i) { if (kg(n, t)) { let l = n.get('position'); e === 'x' ? l !== 'top' && l !== 'bottom' && (l = o.bottom ? 'top' : 'bottom') : l !== 'left' && l !== 'right' && (l = o.left ? 'right' : 'left'), o[l] = !0; const u = new uz(e, Jd(n), [0, 0], n.get('type'), l); const h = u.type === 'category'; u.onBand = h && n.get('boundaryGap'), u.inverse = n.get('inverse'), n.axis = u, u.model = n, u.grid = r, u.index = i, r._axesList.push(u), a[e][i] = u, s[e]++ } } } const i = this; var r = this; var o = { left: !1, right: !1, top: !1, bottom: !1 }; var a = { x: {}, y: {} }; var s = { x: 0, y: 0 }; return e.eachComponent('xAxis', n('x'), this), e.eachComponent('yAxis', n('y'), this), s.x && s.y ? (this._axesMap = a, void y(a.x, function (e, n) { y(a.y, function (r, o) { const a = 'x' + n + 'y' + o; const s = new lz(a); s.master = i, s.model = t, i._coordsMap[a] = s, i._coordsList.push(s), s.addAxis(e), s.addAxis(r) }) })) : (this._axesMap = {}, void (this._axesList = [])) }, t.prototype._updateScale = function (t, e) { function n (t, e) { y(lf(t, e.dim), function (n) { e.scale.unionExtentFromData(t, n) }) }y(this._axesList, function (t) { if (t.scale.setExtent(1 / 0, -1 / 0), t.type === 'category') { const e = t.model.get('categorySortInfo'); t.scale.setSortInfo(e) } }), t.eachSeries(function (t) { if (Ig(t)) { const i = Cg(t); const r = i.xAxisModel; const o = i.yAxisModel; if (!kg(r, e) || !kg(o, e)) return; const a = this.getCartesian(r.componentIndex, o.componentIndex); const s = t.getData(); const l = a.getAxis('x'); const u = a.getAxis('y'); n(s, l), n(s, u) } }, this) }, t.prototype.getTooltipAxes = function (t) { const e = []; const n = []; return y(this.getCartesians(), function (i) { const r = t != null && t !== 'auto' ? i.getAxis(t) : i.getBaseAxis(); const o = i.getOtherAxis(r); p(e, r) < 0 && e.push(r), p(n, o) < 0 && n.push(o) }), { baseAxes: e, otherAxes: n } }, t.create = function (e, n) { const i = []; return e.eachComponent('grid', function (r, o) { const a = new t(r, e, n); a.name = 'grid_' + o, a.resize(r, n, !0), r.coordinateSystem = a, i.push(a) }), e.eachSeries(function (t) { if (Ig(t)) { const e = Cg(t); const n = e.xAxisModel; const i = e.yAxisModel; const r = n.getCoordSysModel(); const o = r.coordinateSystem; t.coordinateSystem = o.getCartesian(n.componentIndex, i.componentIndex) } }), i }, t.dimensions = sz, t }()); var pz = Math.PI; var dz = (function () { function t (t, e) { this.group = new CI(), this.opt = e, this.axisModel = t, c(e, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0, handleAutoShown: function () { return !0 } }); const n = new CI({ x: e.position[0], y: e.position[1], rotation: e.rotation }); n.updateTransform(), this._transformGroup = n } return t.prototype.hasBuilder = function (t) { return !!fz[t] }, t.prototype.add = function (t) { fz[t](this.opt, this.axisModel, this.group, this._transformGroup) }, t.prototype.getGroup = function () { return this.group }, t.innerTextLayout = function (t, e, n) { let i; let r; const o = fr(e - t); return gr(o) ? (r = n > 0 ? 'top' : 'bottom', i = 'center') : gr(o - pz) ? (r = n > 0 ? 'bottom' : 'top', i = 'center') : (r = 'middle', i = o > 0 && pz > o ? n > 0 ? 'right' : 'left' : n > 0 ? 'left' : 'right'), { rotation: o, textAlign: i, textVerticalAlign: r } }, t.makeAxisEventDataBase = function (t) { const e = { componentType: t.mainType, componentIndex: t.componentIndex }; return e[t.mainType + 'Index'] = t.componentIndex, e }, t.isLabelSilent = function (t) { const e = t.get('tooltip'); return t.get('silent') || !(t.get('triggerEvent') || e && e.show) }, t }()); var fz = { axisLine: function (t, e, n, i) { let r = e.get(['axisLine', 'show']); if (r === 'auto' && t.handleAutoShown && (r = t.handleAutoShown('axisLine')), r) { const o = e.axis.getExtent(); const a = i.transform; const s = [o[0], 0]; const l = [o[1], 0]; const u = s[0] > l[0]; a && (ve(s, s, a), ve(l, l, a)); const c = h({ lineCap: 'round' }, e.getModel(['axisLine', 'lineStyle']).getLineStyle()); const p = new dk({ shape: { x1: s[0], y1: s[1], x2: l[0], y2: l[1] }, style: c, strokeContainThreshold: t.strokeContainThreshold || 5, silent: !0, z2: 1 }); Hs(p.shape, p.style.lineWidth), p.anid = 'line', n.add(p); let d = e.get(['axisLine', 'symbol']); if (d != null) { let f = e.get(['axisLine', 'symbolSize']); I(d) && (d = [d, d]), (I(f) || D(f)) && (f = [f, f]); const g = Nc(e.get(['axisLine', 'symbolOffset']) || 0, f); const v = f[0]; const m = f[1]; y([{ rotate: t.rotation + Math.PI / 2, offset: g[0], r: 0 }, { rotate: t.rotation - Math.PI / 2, offset: g[1], r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1])) }], function (e, i) { if (d[i] !== 'none' && d[i] != null) { const r = Oc(d[i], -v / 2, -m / 2, v, m, c.stroke, !0); const o = e.r + e.offset; const a = u ? l : s; r.attr({ rotation: e.rotate, x: a[0] + o * Math.cos(t.rotation), y: a[1] - o * Math.sin(t.rotation), silent: !0, z2: 11 }), n.add(r) } }) } } }, axisTickLabel: function (t, e, n, i) { const r = Vg(n, i, e, t); const o = Hg(n, i, e, t); if (Rg(e, o, r), Fg(n, i, e, t.tickDirection), e.get(['axisLabel', 'hideOverlap'])) { const a = ng(v(o, function (t) { return { label: t, priority: t.z2, defaultAttr: { ignore: t.ignore } } })); ag(a) } }, axisName: function (t, e, n, i) { const r = B(t.axisName, e.get('name')); if (r) { let o; const a = e.get('nameLocation'); const s = t.nameDirection; const l = e.getModel('nameTextStyle'); const u = e.get('nameGap') || 0; const h = e.axis.getExtent(); const c = h[0] > h[1] ? -1 : 1; const p = [a === 'start' ? h[0] - c * u : a === 'end' ? h[1] + c * u : (h[0] + h[1]) / 2, Bg(a) ? t.labelOffset + s * u : 0]; let d = e.get('nameRotate'); d != null && (d = d * pz / 180); let f; Bg(a) ? o = dz.innerTextLayout(t.rotation, d != null ? d : t.rotation, s) : (o = Og(t.rotation, a, d || 0, h), f = t.axisNameAvailableWidth, f != null && (f = Math.abs(f / Math.sin(o.rotation)), !isFinite(f) && (f = null))); const g = l.getFont(); const y = e.get('nameTruncate', !0) || {}; const v = y.ellipsis; const m = B(t.nameTruncateMaxWidth, y.maxWidth, f); const _ = new aD({ x: p[0], y: p[1], rotation: o.rotation, silent: dz.isLabelSilent(e), style: ul(l, { text: r, font: g, overflow: 'truncate', width: m, ellipsis: v, fill: l.getTextColor() || e.get(['axisLine', 'lineStyle', 'color']), align: l.get('align') || o.textAlign, verticalAlign: l.get('verticalAlign') || o.textVerticalAlign }), z2: 1 }); if (nl({ el: _, componentModel: e, itemName: r }), _.__fullText = r, _.anid = 'name', e.get('triggerEvent')) { const x = dz.makeAxisEventDataBase(e); x.targetType = 'axisName', x.name = r, hD(_).eventData = x }i.add(_), _.updateTransform(), n.add(_), _.decomposeTransform() } } }; const gz = {}; var yz = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.render = function (e, n, i) { this.axisPointerClass && jg(e), t.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(e, i, !0) }, n.prototype.updateAxisPointer = function (t, e, n) { this._doUpdateAxisPointerClass(t, n, !1) }, n.prototype.remove = function (t, e) { const n = this._axisPointer; n && n.remove(e) }, n.prototype.dispose = function (e, n) { this._disposeAxisPointer(n), t.prototype.dispose.apply(this, arguments) }, n.prototype._doUpdateAxisPointerClass = function (t, e, i) { const r = n.getAxisPointerClass(this.axisPointerClass); if (r) { const o = Kg(t); o ? (this._axisPointer || (this._axisPointer = new r())).render(t, o, e, i) : this._disposeAxisPointer(e) } }, n.prototype._disposeAxisPointer = function (t) { this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null }, n.registerAxisPointerClass = function (t, e) { gz[t] = e }, n.getAxisPointerClass = function (t) { return t && gz[t] }, n.type = 'axis', n }(YL)); var vz = qr(); const mz = ['axisLine', 'axisTickLabel', 'axisName']; const _z = ['splitArea', 'splitLine', 'minorSplitLine']; const xz = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.axisPointerClass = 'CartesianAxisPointer', e } return e(n, t), n.prototype.render = function (e, n, i, r) { this.group.removeAll(); const o = this._axisGroup; if (this._axisGroup = new CI(), this.group.add(this._axisGroup), e.get('show')) { const a = e.getCoordSysModel(); const s = Tg(a, e); const l = new dz(e, h({ handleAutoShown: function () { for (let t = a.coordinateSystem.getCartesians(), n = 0; n < t.length; n++) if (_d(t[n].getOtherAxis(e.axis).scale)) return !0; return !1 } }, s)); y(mz, l.add, l), this._axisGroup.add(l.getGroup()), y(_z, function (t) { e.get([t, 'show']) && wz[t](this, this._axisGroup, e, a) }, this); const u = r && r.type === 'changeAxisOrder' && r.isInitSort; u || js(o, this._axisGroup, e), t.prototype.render.call(this, e, n, i, r) } }, n.prototype.remove = function () { ty(this) }, n.type = 'cartesianAxis', n }(yz)); var wz = { splitLine: function (t, e, n, i) { const r = n.axis; if (!r.scale.isBlank()) { const o = n.getModel('splitLine'); const a = o.getModel('lineStyle'); let s = a.get('color'); s = M(s) ? s : [s]; for (let l = i.coordinateSystem.getRect(), u = r.isHorizontal(), h = 0, p = r.getTicksCoords({ tickModel: o }), d = [], f = [], g = a.getLineStyle(), y = 0; y < p.length; y++) { const v = r.toGlobalCoord(p[y].coord); u ? (d[0] = v, d[1] = l.y, f[0] = v, f[1] = l.y + l.height) : (d[0] = l.x, d[1] = v, f[0] = l.x + l.width, f[1] = v); const m = h++ % s.length; const _ = p[y].tickValue; const x = new dk({ anid: _ != null ? 'line_' + p[y].tickValue : null, autoBatch: !0, shape: { x1: d[0], y1: d[1], x2: f[0], y2: f[1] }, style: c({ stroke: s[m] }, g), silent: !0 }); Hs(x.shape, g.lineWidth), e.add(x) } } }, minorSplitLine: function (t, e, n, i) { const r = n.axis; const o = n.getModel('minorSplitLine'); const a = o.getModel('lineStyle'); const s = i.coordinateSystem.getRect(); const l = r.isHorizontal(); const u = r.getMinorTicksCoords(); if (u.length) for (let h = [], c = [], p = a.getLineStyle(), d = 0; d < u.length; d++) for (let f = 0; f < u[d].length; f++) { const g = r.toGlobalCoord(u[d][f].coord); l ? (h[0] = g, h[1] = s.y, c[0] = g, c[1] = s.y + s.height) : (h[0] = s.x, h[1] = g, c[0] = s.x + s.width, c[1] = g); const y = new dk({ anid: 'minor_line_' + u[d][f].tickValue, autoBatch: !0, shape: { x1: h[0], y1: h[1], x2: c[0], y2: c[1] }, style: p, silent: !0 }); Hs(y.shape, p.lineWidth), e.add(y) } }, splitArea: function (t, e, n, i) { Jg(t, e, n, i) } }; var bz = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.type = 'xAxis', n }(xz)); var Sz = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = bz.type, e } return e(n, t), n.type = 'yAxis', n }(xz)); var Mz = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = 'grid', e } return e(n, t), n.prototype.render = function (t) { this.group.removeAll(), t.get('show') && this.group.add(new nD({ shape: t.coordinateSystem.getRect(), style: c({ fill: t.get('backgroundColor') }, t.getItemStyle()), silent: !0, z2: -1 })) }, n.type = 'grid', n }(YL)); var Tz = { offset: 0 }; ff(ny); const Iz = ve; var Cz = (function (t) { function n (e) { const n = t.call(this) || this; return n.type = 'view', n.dimensions = ['x', 'y'], n._roamTransformable = new mI(), n._rawTransformable = new mI(), n.name = e, n } return e(n, t), n.prototype.setBoundingRect = function (t, e, n, i) { return this._rect = new $M(t, e, n, i), this._rect }, n.prototype.getBoundingRect = function () { return this._rect }, n.prototype.setViewRect = function (t, e, n, i) { this._transformTo(t, e, n, i), this._viewRect = new $M(t, e, n, i) }, n.prototype._transformTo = function (t, e, n, i) { const r = this.getBoundingRect(); const o = this._rawTransformable; o.transform = r.calculateTransform(new $M(t, e, n, i)); const a = o.parent; o.parent = null, o.decomposeTransform(), o.parent = a, this._updateTransform() }, n.prototype.setCenter = function (t, e) { t && (this._center = [or(t[0], e.getWidth()), or(t[1], e.getHeight())], this._updateCenterAndZoom()) }, n.prototype.setZoom = function (t) { t = t || 1; const e = this.zoomLimit; e && (e.max != null && (t = Math.min(e.max, t)), e.min != null && (t = Math.max(e.min, t))), this._zoom = t, this._updateCenterAndZoom() }, n.prototype.getDefaultCenter = function () { const t = this.getBoundingRect(); const e = t.x + t.width / 2; const n = t.y + t.height / 2; return [e, n] }, n.prototype.getCenter = function () { return this._center || this.getDefaultCenter() }, n.prototype.getZoom = function () { return this._zoom || 1 }, n.prototype.getRoamTransform = function () { return this._roamTransformable.getLocalTransform() }, n.prototype._updateCenterAndZoom = function () { const t = this._rawTransformable.getLocalTransform(); const e = this._roamTransformable; let n = this.getDefaultCenter(); let i = this.getCenter(); const r = this.getZoom(); i = ve([], i, t), n = ve([], n, t), e.originX = i[0], e.originY = i[1], e.x = n[0] - i[0], e.y = n[1] - i[1], e.scaleX = e.scaleY = r, this._updateTransform() }, n.prototype._updateTransform = function () { const t = this._roamTransformable; const e = this._rawTransformable; e.parent = t, t.updateTransform(), e.updateTransform(), Fe(this.transform || (this.transform = []), e.transform || Ee()), this._rawTransform = e.getLocalTransform(), this.invTransform = this.invTransform || [], Ye(this.invTransform, this.transform), this.decomposeTransform() }, n.prototype.getTransformInfo = function () { const t = this._rawTransformable; const e = this._roamTransformable; const n = new mI(); return n.transform = e.transform, n.decomposeTransform(), { roam: { x: n.x, y: n.y, scaleX: n.scaleX, scaleY: n.scaleY }, raw: { x: t.x, y: t.y, scaleX: t.scaleX, scaleY: t.scaleY } } }, n.prototype.getViewRect = function () { return this._viewRect }, n.prototype.getViewRectAfterRoam = function () { const t = this.getBoundingRect().clone(); return t.applyTransform(this.transform), t }, n.prototype.dataToPoint = function (t, e, n) { const i = e ? this._rawTransform : this.transform; return n = n || [], i ? Iz(n, t, i) : te(n, t) }, n.prototype.pointToData = function (t) { const e = this.invTransform; return e ? Iz([], t, e) : [t[0], t[1]] }, n.prototype.convertToPixel = function (t, e, n) { const i = yy(e); return i === this ? i.dataToPoint(n) : null }, n.prototype.convertFromPixel = function (t, e, n) { const i = yy(e); return i === this ? i.pointToData(n) : null }, n.prototype.containPoint = function (t) { return this.getViewRectAfterRoam().contain(t[0], t[1]) }, n.dimensions = ['x', 'y'], n }(mI)); var Dz = '\x00_ec_interaction_mutex'; zp({ type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update' }, Q); const kz = (function (t) { function n (e) { const n = t.call(this) || this; n._zr = e; const i = gM(n._mousedownHandler, n); const r = gM(n._mousemoveHandler, n); const o = gM(n._mouseupHandler, n); const a = gM(n._mousewheelHandler, n); const l = gM(n._pinchHandler, n); return n.enable = function (t, n) { this.disable(), this._opt = c(s(n) || {}, { zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0 }), t == null && (t = !0), (t === !0 || t === 'move' || t === 'pan') && (e.on('mousedown', i), e.on('mousemove', r), e.on('mouseup', o)), (t === !0 || t === 'scale' || t === 'zoom') && (e.on('mousewheel', a), e.on('pinch', l)) }, n.disable = function () { e.off('mousedown', i), e.off('mousemove', r), e.off('mouseup', o), e.off('mousewheel', a), e.off('pinch', l) }, n } return e(n, t), n.prototype.isDragging = function () { return this._dragging }, n.prototype.isPinching = function () { return this._pinching }, n.prototype.setPointerChecker = function (t) { this.pointerChecker = t }, n.prototype.dispose = function () { this.disable() }, n.prototype._mousedownHandler = function (t) { if (!Ne(t)) { for (let e = t.target; e;) { if (e.draggable) return; e = e.__hostTarget || e.parent } const n = t.offsetX; const i = t.offsetY; this.pointerChecker && this.pointerChecker(t, n, i) && (this._x = n, this._y = i, this._dragging = !0) } }, n.prototype._mousemoveHandler = function (t) { if (this._dragging && Ty('moveOnMouseMove', t, this._opt) && t.gestureEvent !== 'pinch' && !wy(this._zr, 'globalPan')) { const e = t.offsetX; const n = t.offsetY; const i = this._x; const r = this._y; const o = e - i; const a = n - r; this._x = e, this._y = n, this._opt.preventDefaultMouseMove && EM(t.event), My(this, 'pan', 'moveOnMouseMove', t, { dx: o, dy: a, oldX: i, oldY: r, newX: e, newY: n, isAvailableBehavior: null }) } }, n.prototype._mouseupHandler = function (t) { Ne(t) || (this._dragging = !1) }, n.prototype._mousewheelHandler = function (t) { const e = Ty('zoomOnMouseWheel', t, this._opt); const n = Ty('moveOnMouseWheel', t, this._opt); const i = t.wheelDelta; const r = Math.abs(i); const o = t.offsetX; const a = t.offsetY; if (i !== 0 && (e || n)) { if (e) { const s = r > 3 ? 1.4 : r > 1 ? 1.2 : 1.1; const l = i > 0 ? s : 1 / s; Sy(this, 'zoom', 'zoomOnMouseWheel', t, { scale: l, originX: o, originY: a, isAvailableBehavior: null }) } if (n) { const u = Math.abs(i); const h = (i > 0 ? 1 : -1) * (u > 3 ? 0.4 : u > 1 ? 0.15 : 0.05); Sy(this, 'scrollMove', 'moveOnMouseWheel', t, { scrollDelta: h, originX: o, originY: a, isAvailableBehavior: null }) } } }, n.prototype._pinchHandler = function (t) { if (!wy(this._zr, 'globalPan')) { const e = t.pinchScale > 1 ? 1.1 : 1 / 1.1; Sy(this, 'zoom', null, t, { scale: e, originX: t.pinchX, originY: t.pinchY, isAvailableBehavior: null }) } }, n }(kM)); var Az = { axisPointer: 1, tooltip: 1, brush: 1 }; const Lz = (function () { function t () { this.parentPoint = [], this.childPoints = [] } return t }()); var Pz = (function (t) { function n (e) { return t.call(this, e) || this } return e(n, t), n.prototype.getDefaultStyle = function () { return { stroke: '#000', fill: null } }, n.prototype.getDefaultShape = function () { return new Lz() }, n.prototype.buildPath = function (t, e) { const n = e.childPoints; const i = n.length; const r = e.parentPoint; const o = n[0]; const a = n[i - 1]; if (i === 1) return t.moveTo(r[0], r[1]), void t.lineTo(o[0], o[1]); const s = e.orient; const l = s === 'TB' || s === 'BT' ? 0 : 1; const u = 1 - l; const h = or(e.forkPosition, 1); const c = []; c[l] = r[l], c[u] = r[u] + (a[u] - r[u]) * h, t.moveTo(r[0], r[1]), t.lineTo(c[0], c[1]), t.moveTo(o[0], o[1]), c[l] = o[l], t.lineTo(c[0], c[1]), c[l] = a[l], t.lineTo(c[0], c[1]), t.lineTo(a[0], a[1]); for (let p = 1; i - 1 > p; p++) { const d = n[p]; t.moveTo(d[0], d[1]), c[l] = d[l], t.lineTo(c[0], c[1]) } }, n }(ZC)); var Oz = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e._mainGroup = new CI(), e } return e(n, t), n.prototype.init = function (t, e) { this._controller = new kz(e.getZr()), this._controllerHost = { target: this.group }, this.group.add(this._mainGroup) }, n.prototype.render = function (t, e, n) { const i = t.getData(); const r = t.layoutInfo; const o = this._mainGroup; const a = t.get('layout'); a === 'radial' ? (o.x = r.x + r.width / 2, o.y = r.y + r.height / 2) : (o.x = r.x, o.y = r.y), this._updateViewCoordSys(t, n), this._updateController(t, e, n); const s = this._data; i.diff(s).add(function (e) { Cy(i, e) && Dy(i, e, null, o, t) }).update(function (e, n) { const r = s.getItemGraphicEl(n); return Cy(i, e) ? void Dy(i, e, r, o, t) : void (r && Py(s, n, r, o, t)) }).remove(function (e) { const n = s.getItemGraphicEl(e); n && Py(s, e, n, o, t) }).execute(), this._nodeScaleRatio = t.get('nodeScaleRatio'), this._updateNodeAndLinkScale(t), t.get('expandAndCollapse') === !0 && i.eachItemGraphicEl(function (e, i) { e.off('click').on('click', function () { n.dispatchAction({ type: 'treeExpandAndCollapse', seriesId: t.id, dataIndex: i }) }) }), this._data = i }, n.prototype._updateViewCoordSys = function (t, e) { const n = t.getData(); const i = []; n.each(function (t) { const e = n.getItemLayout(t); !e || isNaN(e.x) || isNaN(e.y) || i.push([+e.x, +e.y]) }); const r = []; const o = []; Ao(i, r, o); const a = this._min; const s = this._max; o[0] - r[0] === 0 && (r[0] = a ? a[0] : r[0] - 1, o[0] = s ? s[0] : o[0] + 1), o[1] - r[1] === 0 && (r[1] = a ? a[1] : r[1] - 1, o[1] = s ? s[1] : o[1] + 1); const l = t.coordinateSystem = new Cz(); l.zoomLimit = t.get('scaleLimit'), l.setBoundingRect(r[0], r[1], o[0] - r[0], o[1] - r[1]), l.setCenter(t.get('center'), e), l.setZoom(t.get('zoom')), this.group.attr({ x: l.x, y: l.y, scaleX: l.scaleX, scaleY: l.scaleY }), this._min = r, this._max = o }, n.prototype._updateController = function (t, e, n) { const i = this; const r = this._controller; const o = this._controllerHost; const a = this.group; r.setPointerChecker(function (e, i, r) { const o = a.getBoundingRect(); return o.applyTransform(a.transform), o.contain(i, r) && !Iy(e, n, t) }), r.enable(t.get('roam')), o.zoomLimit = t.get('scaleLimit'), o.zoom = t.coordinateSystem.getZoom(), r.off('pan').off('zoom').on('pan', function (e) { vy(o, e.dx, e.dy), n.dispatchAction({ seriesId: t.id, type: 'treeRoam', dx: e.dx, dy: e.dy }) }).on('zoom', function (e) { my(o, e.scale, e.originX, e.originY), n.dispatchAction({ seriesId: t.id, type: 'treeRoam', zoom: e.scale, originX: e.originX, originY: e.originY }), i._updateNodeAndLinkScale(t), n.updateLabelLayout() }) }, n.prototype._updateNodeAndLinkScale = function (t) { const e = t.getData(); const n = this._getNodeGlobalScale(t); e.eachItemGraphicEl(function (t) { t.setSymbolScale(n) }) }, n.prototype._getNodeGlobalScale = function (t) { const e = t.coordinateSystem; if (e.type !== 'view') return 1; const n = this._nodeScaleRatio; const i = e.scaleX || 1; const r = e.getZoom(); const o = (r - 1) * n + 1; return o / i }, n.prototype.dispose = function () { this._controller && this._controller.dispose(), this._controllerHost = null }, n.prototype.remove = function () { this._mainGroup.removeAll(), this._data = null }, n.type = 'tree', n }(jL)); var Rz = qr(); const Nz = (function () {
    function t (t, e) { this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = t || '', this.hostTree = e } return t.prototype.isRemoved = function () { return this.dataIndex < 0 }, t.prototype.eachNode = function (t, e, n) { T(t) && (n = e, e = t, t = null), t = t || {}, I(t) && (t = { order: t }); let i; const r = t.order || 'preorder'; const o = this[t.attr || 'children']; r === 'preorder' && (i = e.call(n, this)); for (let a = 0; !i && a < o.length; a++)o[a].eachNode(t, e, n); r === 'postorder' && e.call(n, this) }, t.prototype.updateDepthAndHeight = function (t) { let e = 0; this.depth = t; for (let n = 0; n < this.children.length; n++) { const i = this.children[n]; i.updateDepthAndHeight(t + 1), i.height > e && (e = i.height) } this.height = e + 1 }, t.prototype.getNodeById = function (t) { if (this.getId() === t) return this; for (let e = 0, n = this.children, i = n.length; i > e; e++) { const r = n[e].getNodeById(t); if (r) return r } }, t.prototype.contains = function (t) { if (t === this) return !0; for (let e = 0, n = this.children, i = n.length; i > e; e++) { const r = n[e].contains(t); if (r) return r } }, t.prototype.getAncestors = function (t) { for (var e = [], n = t ? this : this.parentNode; n;)e.push(n), n = n.parentNode; return e.reverse(), e }, t.prototype.getAncestorsIndices = function () { for (var t = [], e = this; e;)t.push(e.dataIndex), e = e.parentNode; return t.reverse(), t }, t.prototype.getDescendantIndices = function () { const t = []; return this.eachNode(function (e) { t.push(e.dataIndex) }), t }, t.prototype.getValue = function (t) { const e = this.hostTree.data; return e.getStore().get(e.getDimensionIndex(t || 'value'), this.dataIndex) }, t.prototype.setLayout = function (t, e) { this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e) }, t.prototype.getLayout = function () { return this.hostTree.data.getItemLayout(this.dataIndex) }, t.prototype.getModel = function (t) { if (!(this.dataIndex < 0)) { const e = this.hostTree; const n = e.data.getItemModel(this.dataIndex); return n.getModel(t) } }, t.prototype.getLevelModel = function () { return (this.hostTree.levelModels || [])[this.depth] }, t.prototype.setVisual = function (t, e) { this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e) }, t.prototype.getVisual = function (t) { return this.hostTree.data.getItemVisual(this.dataIndex, t) }, t.prototype.getRawIndex = function () { return this.hostTree.data.getRawIndex(this.dataIndex) }, t.prototype.getId = function () { return this.hostTree.data.getId(this.dataIndex) }, t.prototype.getChildIndex = function () {
      if (this.parentNode) {
        for (let t = this.parentNode.children, e = 0; e < t.length; ++e) if (t[e] === this) return e
        return -1
      } return -1
    }, t.prototype.isAncestorOf = function (t) { for (let e = t.parentNode; e;) { if (e === this) return !0; e = e.parentNode } return !1 }, t.prototype.isDescendantOf = function (t) { return t !== this && t.isAncestorOf(this) }, t
  }()); const zz = (function () { function t (t) { this.type = 'tree', this._nodes = [], this.hostModel = t } return t.prototype.eachNode = function (t, e, n) { this.root.eachNode(t, e, n) }, t.prototype.getNodeByDataIndex = function (t) { const e = this.data.getRawIndex(t); return this._nodes[e] }, t.prototype.getNodeById = function (t) { return this.root.getNodeById(t) }, t.prototype.update = function () { for (var t = this.data, e = this._nodes, n = 0, i = e.length; i > n; n++)e[n].dataIndex = -1; for (var n = 0, i = t.count(); i > n; n++)e[t.getRawIndex(n)].dataIndex = n }, t.prototype.clearLayouts = function () { this.data.clearItemLayouts() }, t.createTree = function (e, n, i) { function r (t, e) { const n = t.value; s = Math.max(s, M(n) ? n.length : 1), a.push(t); const i = new Nz(Wr(t.name, ''), o); e ? Gy(i, e) : o.root = i, o._nodes.push(i); const l = t.children; if (l) for (let u = 0; u < l.length; u++)r(l[u], i) } var o = new t(n); var a = []; var s = 1; r(e), o.root.updateDepthAndHeight(0); const l = id(a, { coordDimensions: ['value'], dimensionsCount: s }).dimensions; const u = new TR(l, n); return u.initData(a), i && i(u), Ry({ mainData: u, struct: o, structAttr: 'tree' }), o.update(), o }, t }()); var Bz = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.hasSymbolVisual = !0, e.ignoreStyleOnData = !0, e } return e(n, t), n.prototype.getInitialData = function (t) { function e (t) { t.wrapMethod('getItemModel', function (t, e) { const n = o.getNodeByDataIndex(e); return n && n.children.length && n.isExpand || (t.parentModel = r), t }) } const n = { name: t.name, children: t.data }; const i = t.leaves || {}; var r = new Jk(i, this, this.ecModel); var o = zz.createTree(n, this, e); let a = 0; o.eachNode('preorder', function (t) { t.depth > a && (a = t.depth) }); const s = t.expandAndCollapse; const l = s && t.initialTreeDepth >= 0 ? t.initialTreeDepth : a; return o.root.eachNode('preorder', function (t) { const e = t.hostTree.data.getRawDataItem(t.dataIndex); t.isExpand = e && e.collapsed != null ? !e.collapsed : t.depth <= l }), o.data }, n.prototype.getOrient = function () { let t = this.get('orient'); return t === 'horizontal' ? t = 'LR' : t === 'vertical' && (t = 'TB'), t }, n.prototype.setZoom = function (t) { this.option.zoom = t }, n.prototype.setCenter = function (t) { this.option.center = t }, n.prototype.formatTooltip = function (t) { for (var e = this.getData().tree, n = e.root.children[0], i = e.getNodeByDataIndex(t), r = i.getValue(), o = i.name; i && i !== n;)o = i.parentNode.name + '.' + o, i = i.parentNode; return Oh('nameValue', { name: o, value: r, noValue: isNaN(r) || r == null }) }, n.prototype.getDataParams = function (e) { const n = t.prototype.getDataParams.apply(this, arguments); const i = this.getData().tree.getNodeByDataIndex(e); return n.treeAncestors = Xy(i, this), n.collapsed = !i.isExpand, n }, n.type = 'series.tree', n.layoutMode = 'box', n.defaultOption = { z: 2, coordinateSystem: 'view', left: '12%', top: '12%', right: '12%', bottom: '12%', layout: 'orthogonal', edgeShape: 'curve', edgeForkPosition: '50%', roam: !1, nodeScaleRatio: 0.4, center: null, zoom: 1, orient: 'LR', symbol: 'emptyCircle', symbolSize: 7, expandAndCollapse: !0, initialTreeDepth: 2, lineStyle: { color: '#ccc', width: 1.5, curveness: 0.5 }, itemStyle: { color: 'lightsteelblue', borderWidth: 1.5 }, label: { show: !0 }, animationEasing: 'linear', animationDuration: 700, animationDurationUpdate: 500 }, n }(XL)); ff(Jy); const Ez = '-->'; var Vz = function (t) { return t.get('autoCurveness') || null }; var Fz = function (t, e) { const n = Vz(t); let i = 20; let r = []; if (D(n))i = n; else if (M(n)) return void (t.__curvenessList = n); e > i && (i = e); const o = i % 2 ? i + 2 : i + 3; r = []; for (let a = 0; o > a; a++)r.push((a % 2 ? a + 1 : a) / 10 * (a % 2 ? -1 : 1)); t.__curvenessList = r }; var Hz = function (t, e, n) { const i = [t.id, t.dataIndex].join('.'); const r = [e.id, e.dataIndex].join('.'); return [n.uid, i, r].join(Ez) }; var Wz = function (t) { const e = t.split(Ez); return [e[0], e[2], e[1]].join(Ez) }; var Gz = function (t, e) { const n = Hz(t.node1, t.node2, e); return e.__edgeMap[n] }; var Xz = function (t, e) { const n = Yz(Hz(t.node1, t.node2, e), e); const i = Yz(Hz(t.node2, t.node1, e), e); return n + i }; var Yz = function (t, e) { const n = e.__edgeMap; return n[t] ? n[t].length : 0 }; const Uz = Math.PI; const Zz = []; var jz = { value: function (t, e, n, i, r, o, a) { let s = 0; const l = n.getSum('value'); const u = 2 * Math.PI / (l || a); e.eachNode(function (t) { const e = t.getValue('value'); const n = u * (l ? e : 1) / 2; s += n, t.setLayout([i * Math.cos(s) + r, i * Math.sin(s) + o]), s += n }) }, symbolSize: function (t, e, n, i, r, o, a) { let s = 0; Zz.length = a; const l = hv(t); e.eachNode(function (t) { let e = cv(t); isNaN(e) && (e = 2), e < 0 && (e = 0), e *= l; let n = Math.asin(e / 2 / i); isNaN(n) && (n = Uz / 2), Zz[t.dataIndex] = n, s += 2 * n }); const u = (2 * Uz - s) / a / 2; let h = 0; e.eachNode(function (t) { const e = u + Zz[t.dataIndex]; h += e, (!t.getLayout() || !t.getLayout().fixed) && t.setLayout([i * Math.cos(h) + r, i * Math.sin(h) + o]), h += e }) } }; var qz = re; const Kz = dk.prototype; const $z = yk.prototype; const Qz = (function () { function t () { this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1 } return t }()); var Jz = ((function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n }(Qz)), (function (t) { function n (e) { const n = t.call(this, e) || this; return n.type = 'ec-line', n } return e(n, t), n.prototype.getDefaultStyle = function () { return { stroke: '#000', fill: null } }, n.prototype.getDefaultShape = function () { return new Qz() }, n.prototype.buildPath = function (t, e) { _v(e) ? Kz.buildPath.call(this, t, e) : $z.buildPath.call(this, t, e) }, n.prototype.pointAt = function (t) { return _v(this.shape) ? Kz.pointAt.call(this, t) : $z.pointAt.call(this, t) }, n.prototype.tangentAt = function (t) { const e = this.shape; const n = _v(e) ? [e.x2 - e.x1, e.y2 - e.y1] : $z.tangentAt.call(this, t); return pe(n, n) }, n }(ZC))); const tB = ['fromSymbol', 'toSymbol']; const eB = (function (t) { function n (e, n, i) { const r = t.call(this) || this; return r._createLine(e, n, i), r } return e(n, t), n.prototype._createLine = function (t, e, n) { const i = t.hostModel; const r = t.getItemLayout(e); const o = bv(r); o.shape.percent = 0, Cs(o, { shape: { percent: 1 } }, i, e), this.add(o), y(tB, function (n) { const i = wv(n, t, e); this.add(i), this[xv(n)] = t.getItemVisual(e, n) }, this), this._updateCommonStl(t, e, n) }, n.prototype.updateData = function (t, e, n) { const i = t.hostModel; const r = this.childOfName('line'); const o = t.getItemLayout(e); const a = { shape: {} }; Sv(a.shape, o), Is(r, a, i, e), y(tB, function (n) { const i = t.getItemVisual(e, n); const r = xv(n); if (this[r] !== i) { this.remove(this.childOfName(n)); const o = wv(n, t, e); this.add(o) } this[r] = i }, this), this._updateCommonStl(t, e, n) }, n.prototype.getLinePath = function () { return this.childAt(0) }, n.prototype._updateCommonStl = function (t, e, n) { const i = t.hostModel; const r = this.childOfName('line'); let o = n && n.emphasisLineStyle; let a = n && n.blurLineStyle; let s = n && n.selectLineStyle; let l = n && n.labelStatesModels; let u = n && n.emphasisDisabled; let h = n && n.focus; let c = n && n.blurScope; if (!n || t.hasItemOption) { const p = t.getItemModel(e); const d = p.getModel('emphasis'); o = d.getModel('lineStyle').getLineStyle(), a = p.getModel(['blur', 'lineStyle']).getLineStyle(), s = p.getModel(['select', 'lineStyle']).getLineStyle(), u = d.get('disabled'), h = d.get('focus'), c = d.get('blurScope'), l = ll(p) } const f = t.getItemVisual(e, 'style'); const g = f.stroke; r.useStyle(f), r.style.fill = null, r.style.strokeNoScale = !0, r.ensureState('emphasis').style = o, r.ensureState('blur').style = a, r.ensureState('select').style = s, y(tB, function (t) { const e = this.childOfName(t); if (e) { e.setColor(g), e.style.opacity = f.opacity; for (let n = 0; n < _D.length; n++) { const i = _D[n]; const o = r.getState(i); if (o) { const a = o.style || {}; const s = e.ensureState(i); const l = s.style || (s.style = {}); a.stroke != null && (l[e.__isEmptyBrush ? 'stroke' : 'fill'] = a.stroke), a.opacity != null && (l.opacity = a.opacity) } }e.markRedraw() } }, this); const v = i.getRawValue(e); sl(this, l, { labelDataIndex: e, labelFetcher: { getFormattedLabel: function (e, n) { return i.getFormattedLabel(e, n, t.dataType) } }, inheritColor: g || '#000', defaultOpacity: f.opacity, defaultText: (v == null ? t.getName(e) : isFinite(v) ? ar(v) : v) + '' }); const m = this.getTextContent(); if (m) { const _ = l.normal; m.__align = m.style.align, m.__verticalAlign = m.style.verticalAlign, m.__position = _.get('position') || 'middle'; let x = _.get('distance'); M(x) || (x = [x, x]), m.__labelDistance = x } this.setTextConfig({ position: null, local: !0, inside: !1 }), $a(this, h, c, u) }, n.prototype.highlight = function () { Pa(this) }, n.prototype.downplay = function () { Oa(this) }, n.prototype.updateLayout = function (t, e) { this.setLinePoints(t.getItemLayout(e)) }, n.prototype.setLinePoints = function (t) { const e = this.childOfName('line'); Sv(e.shape, t), e.dirty() }, n.prototype.beforeUpdate = function () { function t (t, e) { const n = t.__specifiedRotation; if (n == null) { const i = s.tangentAt(e); t.attr('rotation', (e === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(i[1], i[0])) } else t.attr('rotation', n) } const e = this; const n = e.childOfName('fromSymbol'); const i = e.childOfName('toSymbol'); const r = e.getTextContent(); if (n || i || r && !r.ignore) { for (var o = 1, a = this.parent; a;)a.scaleX && (o /= a.scaleX), a = a.parent; var s = e.childOfName('line'); if (this.__dirty || s.__dirty) { const l = s.shape.percent; const u = s.pointAt(0); const h = s.pointAt(l); const c = oe([], h, u); if (pe(c, c), n && (n.setPosition(u), t(n, 0), n.scaleX = n.scaleY = o * l, n.markRedraw()), i && (i.setPosition(h), t(i, 1), i.scaleX = i.scaleY = o * l, i.markRedraw()), r && !r.ignore) { r.x = r.y = 0, r.originX = r.originY = 0; let p = void 0; let d = void 0; const f = r.__labelDistance; const g = f[0] * o; const y = f[1] * o; const v = l / 2; const m = s.tangentAt(v); const _ = [m[1], -m[0]]; const x = s.pointAt(v); _[1] > 0 && (_[0] = -_[0], _[1] = -_[1]); const w = m[0] < 0 ? -1 : 1; if (r.__position !== 'start' && r.__position !== 'end') { let b = -Math.atan2(m[1], m[0]); h[0] < u[0] && (b = Math.PI + b), r.rotation = b } let S = void 0; switch (r.__position) { case 'insideStartTop':case 'insideMiddleTop':case 'insideEndTop':case 'middle':S = -y, d = 'bottom'; break; case 'insideStartBottom':case 'insideMiddleBottom':case 'insideEndBottom':S = y, d = 'top'; break; default:S = 0, d = 'middle' } switch (r.__position) { case 'end':r.x = c[0] * g + h[0], r.y = c[1] * y + h[1], p = c[0] > 0.8 ? 'left' : c[0] < -0.8 ? 'right' : 'center', d = c[1] > 0.8 ? 'top' : c[1] < -0.8 ? 'bottom' : 'middle'; break; case 'start':r.x = -c[0] * g + u[0], r.y = -c[1] * y + u[1], p = c[0] > 0.8 ? 'right' : c[0] < -0.8 ? 'left' : 'center', d = c[1] > 0.8 ? 'bottom' : c[1] < -0.8 ? 'top' : 'middle'; break; case 'insideStartTop':case 'insideStart':case 'insideStartBottom':r.x = g * w + u[0], r.y = u[1] + S, p = m[0] < 0 ? 'right' : 'left', r.originX = -g * w, r.originY = -S; break; case 'insideMiddleTop':case 'insideMiddle':case 'insideMiddleBottom':case 'middle':r.x = x[0], r.y = x[1] + S, p = 'center', r.originY = -S; break; case 'insideEndTop':case 'insideEnd':case 'insideEndBottom':r.x = -g * w + h[0], r.y = h[1] + S, p = m[0] >= 0 ? 'right' : 'left', r.originX = g * w, r.originY = -S }r.scaleX = r.scaleY = o, r.setStyle({ verticalAlign: r.__verticalAlign || d, align: r.__align || p }) } } } }, n }(CI)); const nB = (function () { function t (t) { this.group = new CI(), this._LineCtor = t || eB } return t.prototype.updateData = function (t) { const e = this; this._progressiveEls = null; const n = this; const i = n.group; const r = n._lineData; n._lineData = t, r || i.removeAll(); const o = Tv(t); t.diff(r).add(function (n) { e._doAdd(t, n, o) }).update(function (n, i) { e._doUpdate(r, t, i, n, o) }).remove(function (t) { i.remove(r.getItemGraphicEl(t)) }).execute() }, t.prototype.updateLayout = function () { const t = this._lineData; t && t.eachItemGraphicEl(function (e, n) { e.updateLayout(t, n) }, this) }, t.prototype.incrementalPrepareUpdate = function (t) { this._seriesScope = Tv(t), this._lineData = null, this.group.removeAll() }, t.prototype.incrementalUpdate = function (t, e) { function n (t) { t.isGroup || Mv(t) || (t.incremental = !0, t.ensureState('emphasis').hoverLayer = !0) } this._progressiveEls = []; for (let i = t.start; i < t.end; i++) { const r = e.getItemLayout(i); if (Cv(r)) { const o = new this._LineCtor(e, i, this._seriesScope); o.traverse(n), this.group.add(o), e.setItemGraphicEl(i, o), this._progressiveEls.push(o) } } }, t.prototype.remove = function () { this.group.removeAll() }, t.prototype.eachRendered = function (t) { rl(this._progressiveEls || this.group, t) }, t.prototype._doAdd = function (t, e, n) { const i = t.getItemLayout(e); if (Cv(i)) { const r = new this._LineCtor(t, e, n); t.setItemGraphicEl(e, r), this.group.add(r) } }, t.prototype._doUpdate = function (t, e, n, i, r) { let o = t.getItemGraphicEl(n); return Cv(e.getItemLayout(i)) ? (o ? o.updateData(e, i, r) : o = new this._LineCtor(e, i, r), e.setItemGraphicEl(i, o), void this.group.add(o)) : void this.group.remove(o) }, t }()); var iB = []; var rB = []; var oB = []; var aB = mn; var sB = TM; var lB = Math.abs; var uB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.init = function (t, e) { const n = new YN(); const i = new nB(); const r = this.group; this._controller = new kz(e.getZr()), this._controllerHost = { target: r }, r.add(n.group), r.add(i.group), this._symbolDraw = n, this._lineDraw = i, this._firstRender = !0 }, n.prototype.render = function (t, e, n) { const i = this; const r = t.coordinateSystem; this._model = t; const o = this._symbolDraw; const a = this._lineDraw; const s = this.group; if (Av(r)) { const l = { x: r.x, y: r.y, scaleX: r.scaleX, scaleY: r.scaleY }; this._firstRender ? s.attr(l) : Is(s, l, t) }kv(t.getGraph(), hv(t)); const u = t.getData(); o.updateData(u); const h = t.getEdgeData(); a.updateData(h), this._updateNodeAndLinkScale(), this._updateController(t, e, n), clearTimeout(this._layoutTimeout); const c = t.forceLayout; const p = t.get(['force', 'layoutAnimation']); c && this._startForceLayoutIteration(c, p); const d = t.get('layout'); u.graph.eachNode(function (e) { const n = e.dataIndex; const r = e.getGraphicEl(); const o = e.getModel(); if (r) { r.off('drag').off('dragend'); const a = o.get('draggable'); a && r.on('drag', function (o) { switch (d) { case 'force':c.warmUp(), !i._layouting && i._startForceLayoutIteration(c, p), c.setFixed(n), u.setItemLayout(n, [r.x, r.y]); break; case 'circular':u.setItemLayout(n, [r.x, r.y]), e.setLayout({ fixed: !0 }, !0), pv(t, 'symbolSize', e, [o.offsetX, o.offsetY]), i.updateLayout(t); break; case 'none':default:u.setItemLayout(n, [r.x, r.y]), lv(t.getGraph(), t), i.updateLayout(t) } }).on('dragend', function () { c && c.setUnfixed(n) }), r.setDraggable(a, !!o.get('cursor')); const s = o.get(['emphasis', 'focus']); s === 'adjacency' && (hD(r).focus = e.getAdjacentDataIndices()) } }), u.graph.eachEdge(function (t) { const e = t.getGraphicEl(); const n = t.getModel().get(['emphasis', 'focus']); e && n === 'adjacency' && (hD(e).focus = { edge: [t.dataIndex], node: [t.node1.dataIndex, t.node2.dataIndex] }) }); const f = t.get('layout') === 'circular' && t.get(['circular', 'rotateLabel']); const g = u.getLayout('cx'); const y = u.getLayout('cy'); u.graph.eachNode(function (t) { dv(t, f, g, y) }), this._firstRender = !1 }, n.prototype.dispose = function () { this._controller && this._controller.dispose(), this._controllerHost = null }, n.prototype._startForceLayoutIteration = function (t, e) { const n = this; !(function i () { t.step(function (t) { n.updateLayout(n._model), (n._layouting = !t) && (e ? n._layoutTimeout = setTimeout(i, 16) : i()) }) }()) }, n.prototype._updateController = function (t, e, n) { const i = this; const r = this._controller; const o = this._controllerHost; const a = this.group; return r.setPointerChecker(function (e, i, r) { const o = a.getBoundingRect(); return o.applyTransform(a.transform), o.contain(i, r) && !Iy(e, n, t) }), Av(t.coordinateSystem) ? (r.enable(t.get('roam')), o.zoomLimit = t.get('scaleLimit'), o.zoom = t.coordinateSystem.getZoom(), void r.off('pan').off('zoom').on('pan', function (e) { vy(o, e.dx, e.dy), n.dispatchAction({ seriesId: t.id, type: 'graphRoam', dx: e.dx, dy: e.dy }) }).on('zoom', function (e) { my(o, e.scale, e.originX, e.originY), n.dispatchAction({ seriesId: t.id, type: 'graphRoam', zoom: e.scale, originX: e.originX, originY: e.originY }), i._updateNodeAndLinkScale(), kv(t.getGraph(), hv(t)), i._lineDraw.updateLayout(), n.updateLabelLayout() })) : void r.disable() }, n.prototype._updateNodeAndLinkScale = function () { const t = this._model; const e = t.getData(); const n = hv(t); e.eachItemGraphicEl(function (t) { t && t.setSymbolScale(n) }) }, n.prototype.updateLayout = function (t) { kv(t.getGraph(), hv(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout() }, n.prototype.remove = function () { this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove() }, n.type = 'graph', n }(jL)); var hB = (function () { function t (t) { this.type = 'graph', this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1 } return t.prototype.isDirected = function () { return this._directed }, t.prototype.addNode = function (t, e) { t = t == null ? '' + e : '' + t; const n = this._nodesMap; if (!n[Lv(t)]) { const i = new cB(t, e); return i.hostGraph = this, this.nodes.push(i), n[Lv(t)] = i, i } }, t.prototype.getNodeByIndex = function (t) { const e = this.data.getRawIndex(t); return this.nodes[e] }, t.prototype.getNodeById = function (t) { return this._nodesMap[Lv(t)] }, t.prototype.addEdge = function (t, e, n) { const i = this._nodesMap; const r = this._edgesMap; if (D(t) && (t = this.nodes[t]), D(e) && (e = this.nodes[e]), t instanceof cB || (t = i[Lv(t)]), e instanceof cB || (e = i[Lv(e)]), t && e) { const o = t.id + '-' + e.id; const a = new pB(t, e, n); return a.hostGraph = this, this._directed && (t.outEdges.push(a), e.inEdges.push(a)), t.edges.push(a), t !== e && e.edges.push(a), this.edges.push(a), r[o] = a, a } }, t.prototype.getEdgeByIndex = function (t) { const e = this.edgeData.getRawIndex(t); return this.edges[e] }, t.prototype.getEdge = function (t, e) { t instanceof cB && (t = t.id), e instanceof cB && (e = e.id); const n = this._edgesMap; return this._directed ? n[t + '-' + e] : n[t + '-' + e] || n[e + '-' + t] }, t.prototype.eachNode = function (t, e) { for (let n = this.nodes, i = n.length, r = 0; i > r; r++)n[r].dataIndex >= 0 && t.call(e, n[r], r) }, t.prototype.eachEdge = function (t, e) { for (let n = this.edges, i = n.length, r = 0; i > r; r++)n[r].dataIndex >= 0 && n[r].node1.dataIndex >= 0 && n[r].node2.dataIndex >= 0 && t.call(e, n[r], r) }, t.prototype.breadthFirstTraverse = function (t, e, n, i) { if (e instanceof cB || (e = this._nodesMap[Lv(e)]), e) { for (var r = n === 'out' ? 'outEdges' : n === 'in' ? 'inEdges' : 'edges', o = 0; o < this.nodes.length; o++) this.nodes[o].__visited = !1; if (!t.call(i, e, null)) for (let a = [e]; a.length;) for (var s = a.shift(), l = s[r], o = 0; o < l.length; o++) { const u = l[o]; const h = u.node1 === s ? u.node2 : u.node1; if (!h.__visited) { if (t.call(i, h, s)) return; a.push(h), h.__visited = !0 } } } }, t.prototype.update = function () { for (var t = this.data, e = this.edgeData, n = this.nodes, i = this.edges, r = 0, o = n.length; o > r; r++)n[r].dataIndex = -1; for (var r = 0, o = t.count(); o > r; r++)n[t.getRawIndex(r)].dataIndex = r; e.filterSelf(function (t) { const n = i[e.getRawIndex(t)]; return n.node1.dataIndex >= 0 && n.node2.dataIndex >= 0 }); for (var r = 0, o = i.length; o > r; r++)i[r].dataIndex = -1; for (var r = 0, o = e.count(); o > r; r++)i[e.getRawIndex(r)].dataIndex = r }, t.prototype.clone = function () { for (var e = new t(this._directed), n = this.nodes, i = this.edges, r = 0; r < n.length; r++)e.addNode(n[r].id, n[r].dataIndex); for (var r = 0; r < i.length; r++) { const o = i[r]; e.addEdge(o.node1.id, o.node2.id, o.dataIndex) } return e }, t }()); var cB = (function () { function t (t, e) { this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t == null ? '' : t, this.dataIndex = e == null ? -1 : e } return t.prototype.degree = function () { return this.edges.length }, t.prototype.inDegree = function () { return this.inEdges.length }, t.prototype.outDegree = function () { return this.outEdges.length }, t.prototype.getModel = function (t) { if (!(this.dataIndex < 0)) { const e = this.hostGraph; const n = e.data.getItemModel(this.dataIndex); return n.getModel(t) } }, t.prototype.getAdjacentDataIndices = function () { for (var t = { edge: [], node: [] }, e = 0; e < this.edges.length; e++) { const n = this.edges[e]; n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex)) } return t }, t }()); var pB = (function () { function t (t, e, n) { this.dataIndex = -1, this.node1 = t, this.node2 = e, this.dataIndex = n == null ? -1 : n } return t.prototype.getModel = function (t) { if (!(this.dataIndex < 0)) { const e = this.hostGraph; const n = e.edgeData.getItemModel(this.dataIndex); return n.getModel(t) } }, t.prototype.getAdjacentDataIndices = function () { return { edge: [this.dataIndex], node: [this.node1.dataIndex, this.node2.dataIndex] } }, t }()); f(cB, Pv('hostGraph', 'data')), f(pB, Pv('hostGraph', 'edgeData')); const dB = (function () { function t (t, e) { this._getDataWithEncodedVisual = t, this._getRawData = e } return t.prototype.getAllNames = function () { const t = this._getRawData(); return t.mapArray(t.getName) }, t.prototype.containName = function (t) { const e = this._getRawData(); return e.indexOfName(t) >= 0 }, t.prototype.indexOfName = function (t) { const e = this._getDataWithEncodedVisual(); return e.indexOfName(t) }, t.prototype.getItemVisual = function (t, e) { const n = this._getDataWithEncodedVisual(); return n.getItemVisual(t, e) }, t }()); var fB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.hasSymbolVisual = !0, e } return e(n, t), n.prototype.init = function (e) { function n () { return i._categoriesData }t.prototype.init.apply(this, arguments); var i = this; this.legendVisualProvider = new dB(n, n), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData() }, n.prototype.mergeOption = function (e) { t.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData() }, n.prototype.mergeDefaultAndTheme = function (e) { t.prototype.mergeDefaultAndTheme.apply(this, arguments), Ar(e, 'edgeLabel', ['show']) }, n.prototype.getInitialData = function (t) { function e (t, e) { function n (t, e) { const n = o.call(this, t, e); return n.resolveParentPath = i, n } function i (t) { if (t && (t[0] === 'label' || t[1] === 'label')) { const e = t.slice(); return t[0] === 'label' ? e[0] = 'edgeLabel' : t[1] === 'label' && (e[1] = 'edgeLabel'), e } return t }t.wrapMethod('getItemModel', function (t) { const e = r._categoriesModels; const n = t.getShallow('category'); const i = e[n]; return i && (i.parentModel = t.parentModel, t.parentModel = i), t }); var o = Jk.prototype.getModel; e.wrapMethod('getItemModel', function (t) { return t.resolveParentPath = i, t.getModel = n, t }) } const n = t.edges || t.links || []; const i = t.data || t.nodes || []; var r = this; if (i && n) { rv(this); const o = Ov(i, n, this, !0, e); return y(o.edges, function (t) { ov(t.node1, t.node2, this, t.dataIndex) }, this), o.data } }, n.prototype.getGraph = function () { return this.getData().graph }, n.prototype.getEdgeData = function () { return this.getGraph().edgeData }, n.prototype.getCategoriesData = function () { return this._categoriesData }, n.prototype.formatTooltip = function (t, e, n) { if (n === 'edge') { const i = this.getData(); const r = this.getDataParams(t, n); const o = i.graph.getEdgeByIndex(t); const a = i.getName(o.node1.dataIndex); const s = i.getName(o.node2.dataIndex); const l = []; return a != null && l.push(a), s != null && l.push(s), Oh('nameValue', { name: l.join(' > '), value: r.value, noValue: r.value == null }) } const u = jh({ series: this, dataIndex: t, multipleSeries: e }); return u }, n.prototype._updateCategoriesData = function () { const t = v(this.option.categories || [], function (t) { return t.value != null ? t : h({ value: 0 }, t) }); const e = new TR(['value'], this); e.initData(t), this._categoriesData = e, this._categoriesModels = e.mapArray(function (t) { return e.getItemModel(t) }) }, n.prototype.setZoom = function (t) { this.option.zoom = t }, n.prototype.setCenter = function (t) { this.option.center = t }, n.prototype.isAnimationEnabled = function () { return t.prototype.isAnimationEnabled.call(this) && !(this.get('layout') === 'force' && this.get(['force', 'layoutAnimation'])) }, n.type = 'series.graph', n.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'], n.defaultOption = { z: 2, coordinateSystem: 'view', legendHoverLink: !0, layout: null, circular: { rotateLabel: !1 }, force: { initLayout: null, repulsion: [0, 50], gravity: 0.1, friction: 0.6, edgeLength: 30, layoutAnimation: !0 }, left: 'center', top: 'center', symbol: 'circle', symbolSize: 10, edgeSymbol: ['none', 'none'], edgeSymbolSize: 10, edgeLabel: { position: 'middle', distance: 5 }, draggable: !1, roam: !1, center: null, zoom: 1, nodeScaleRatio: 0.6, label: { show: !1, formatter: '{b}' }, itemStyle: {}, lineStyle: { color: '#aaa', width: 1, opacity: 0.5 }, emphasis: { scale: !0, label: { show: !0 } }, select: { itemStyle: { borderColor: '#212121' } } }, n }(XL)); var gB = { type: 'graphRoam', event: 'graphRoam', update: 'none' }; ff(Rv); var yB = { color: 'fill', borderColor: 'stroke' }; var vB = { symbol: 1, symbolSize: 1, symbolKeepAspect: 1, legendIcon: 1, visualMeta: 1, liftZ: 1, decal: 1 }; var mB = qr(); var _B = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.optionUpdated = function () { this.currentZLevel = this.get('zlevel', !0), this.currentZ = this.get('z', !0) }, n.prototype.getInitialData = function () { return gd(null, this) }, n.prototype.getDataParams = function (e, n, i) { const r = t.prototype.getDataParams.call(this, e, n); return i && (r.info = mB(i).info), r }, n.type = 'series.custom', n.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'], n.defaultOption = { coordinateSystem: 'cartesian2d', z: 2, legendHoverLink: !0, clip: !1 }, n }(XL)); var xB = { position: ['x', 'y'], scale: ['scaleX', 'scaleY'], origin: ['originX', 'originY'] }; var wB = w(xB); var bB = (m(_I, function (t, e) { return t[e] = 1, t }, {}), _I.join(', '), ['', 'style', 'shape', 'extra']); var SB = qr(); var MB = {}; var TB = { setTransform: function (t, e) { return MB.el[t] = e, this }, getTransform: function (t) { return MB.el[t] }, setShape: function (t, e) { const n = MB.el; const i = n.shape || (n.shape = {}); return i[t] = e, n.dirtyShape && n.dirtyShape(), this }, getShape: function (t) { const e = MB.el.shape; return e ? e[t] : void 0 }, setStyle: function (t, e) { const n = MB.el; const i = n.style; return i && (i[t] = e, n.dirtyStyle && n.dirtyStyle()), this }, getStyle: function (t) { const e = MB.el.style; return e ? e[t] : void 0 }, setExtra: function (t, e) { const n = MB.el.extra || (MB.el.extra = {}); return n[t] = e, this }, getExtra: function (t) { const e = MB.el.extra; return e ? e[t] : void 0 } }; var IB = qr(); var CB = ['percent', 'easing', 'shape', 'style', 'extra']; var DB = 'emphasis'; var kB = 'normal'; const AB = 'blur'; const LB = 'select'; var PB = [kB, DB, AB, LB]; var OB = { normal: ['itemStyle'], emphasis: [DB, 'itemStyle'], blur: [AB, 'itemStyle'], select: [LB, 'itemStyle'] }; var RB = { normal: ['label'], emphasis: [DB, 'label'], blur: [AB, 'label'], select: [LB, 'label'] }; var NB = ['x', 'y']; var zB = 'e\x00\x00'; var BB = { normal: {}, emphasis: {}, blur: {}, select: {} }; var EB = { cartesian2d: Vv, geo: Hv, single: Gv, polar: Yv, calendar: Uv }; var VB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.render = function (t, e, n, i) { this._progressiveEls = null; const r = this._data; const o = t.getData(); const a = this.group; const s = Sm(t, o, e, n); r || a.removeAll(), o.diff(r).add(function (e) { Tm(n, null, e, s(e, i), t, a, o) }).remove(function (e) { const n = r.getItemGraphicEl(e); n && em(n, mB(n).option, t) }).update(function (e, l) { const u = r.getItemGraphicEl(l); Tm(n, u, e, s(e, i), t, a, o) }).execute(); const l = t.get('clip', !0) ? Bv(t.coordinateSystem, !1, t) : null; l ? a.setClipPath(l) : a.removeClipPath(), this._data = o }, n.prototype.incrementalPrepareRender = function () { this.group.removeAll(), this._data = null }, n.prototype.incrementalRender = function (t, e, n, i, r) { function o (t) { t.isGroup || (t.incremental = !0, t.ensureState('emphasis').hoverLayer = !0) } for (let a = e.getData(), s = Sm(e, a, n, i), l = this._progressiveEls = [], u = t.start; u < t.end; u++) { const h = Tm(null, null, u, s(u, r), e, this.group, a); h && (h.traverse(o), l.push(h)) } }, n.prototype.eachRendered = function (t) { rl(this._progressiveEls || this.group, t) }, n.prototype.filterForExposedEvent = function (t, e, n) { const i = e.element; if (i == null || n.name === i) return !0; for (;(n = n.__hostTarget || n.parent) && n !== this.group;) if (n.name === i) return !0; return !1 }, n.type = 'custom', n }(jL)); ff(Hm), ff(ey); var FB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.init = function (e) { const n = uu(e); t.prototype.init.apply(this, arguments), Wm(e, n) }, n.prototype.mergeOption = function (e) { t.prototype.mergeOption.apply(this, arguments), Wm(this.option, e) }, n.prototype.getCellSize = function () { return this.option.cellSize }, n.type = 'calendar', n.defaultOption = { z: 2, left: 80, top: 60, cellSize: 20, orient: 'horizontal', splitLine: { show: !0, lineStyle: { color: '#000', width: 1, type: 'solid' } }, itemStyle: { color: '#fff', borderWidth: 1, borderColor: '#ccc' }, dayLabel: { show: !0, firstDay: 0, position: 'start', margin: '50%', color: '#000' }, monthLabel: { show: !0, position: 'start', margin: 5, align: 'center', formatter: null, color: '#000' }, yearLabel: { show: !0, position: null, margin: 30, formatter: null, color: '#ccc', fontFamily: 'sans-serif', fontWeight: 'bolder', fontSize: 20 } }, n }(CA)); var HB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.render = function (t, e) { const n = this.group; n.removeAll(); const i = t.coordinateSystem; const r = i.getRangeInfo(); const o = i.getOrient(); const a = e.getLocaleModel(); this._renderDayRect(t, r, n), this._renderLines(t, r, o, n), this._renderYearText(t, r, o, n), this._renderMonthText(t, a, o, n), this._renderWeekText(t, a, r, o, n) }, n.prototype._renderDayRect = function (t, e, n) { for (let i = t.coordinateSystem, r = t.getModel('itemStyle').getItemStyle(), o = i.getCellWidth(), a = i.getCellHeight(), s = e.start.time; s <= e.end.time; s = i.getNextNDay(s, 1).time) { const l = i.dataToRect([s], !1).tl; const u = new nD({ shape: { x: l[0], y: l[1], width: o, height: a }, cursor: 'default', style: r }); n.add(u) } }, n.prototype._renderLines = function (t, e, n, i) { function r (e) { o._firstDayOfMonth.push(a.getDateInfo(e)), o._firstDayPoints.push(a.dataToRect([e], !1).tl); const r = o._getLinePointsOfOneWeek(t, e, n); o._tlpoints.push(r[0]), o._blpoints.push(r[r.length - 1]), l && o._drawSplitline(r, s, i) } var o = this; var a = t.coordinateSystem; var s = t.getModel(['splitLine', 'lineStyle']).getLineStyle(); var l = t.get(['splitLine', 'show']); const u = s.lineWidth; this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = []; for (let h = e.start, c = 0; h.time <= e.end.time; c++) { r(h.formatedDate), c === 0 && (h = a.getDateInfo(e.start.y + '-' + e.start.m)); const p = h.date; p.setMonth(p.getMonth() + 1), h = a.getDateInfo(p) }r(a.getNextNDay(e.end.time, 1).formatedDate), l && this._drawSplitline(o._getEdgesPoints(o._tlpoints, u, n), s, i), l && this._drawSplitline(o._getEdgesPoints(o._blpoints, u, n), s, i) }, n.prototype._getEdgesPoints = function (t, e, n) { const i = [t[0].slice(), t[t.length - 1].slice()]; const r = n === 'horizontal' ? 0 : 1; return i[0][r] = i[0][r] - e / 2, i[1][r] = i[1][r] + e / 2, i }, n.prototype._drawSplitline = function (t, e, n) { const i = new hk({ z2: 20, shape: { points: t }, style: e }); n.add(i) }, n.prototype._getLinePointsOfOneWeek = function (t, e, n) { for (var i = t.coordinateSystem, r = i.getDateInfo(e), o = [], a = 0; a < 7; a++) { const s = i.getNextNDay(r.time, a); const l = i.dataToRect([s.time], !1); o[2 * s.day] = l.tl, o[2 * s.day + 1] = l[n === 'horizontal' ? 'bl' : 'tr'] } return o }, n.prototype._formatterLabel = function (t, e) { return I(t) && t ? $l(t, e) : T(t) ? t(e) : e.nameMap }, n.prototype._yearTextPositionControl = function (t, e, n, i, r) { let o = e[0]; let a = e[1]; let s = ['center', 'bottom']; i === 'bottom' ? (a += r, s = ['center', 'top']) : i === 'left' ? o -= r : i === 'right' ? (o += r, s = ['center', 'top']) : a -= r; let l = 0; return (i === 'left' || i === 'right') && (l = Math.PI / 2), { rotation: l, x: o, y: a, style: { align: s[0], verticalAlign: s[1] } } }, n.prototype._renderYearText = function (t, e, n, i) { const r = t.getModel('yearLabel'); if (r.get('show')) { const o = r.get('margin'); let a = r.get('position'); a || (a = n !== 'horizontal' ? 'top' : 'left'); const s = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]]; const l = (s[0][0] + s[1][0]) / 2; const u = (s[0][1] + s[1][1]) / 2; const h = n === 'horizontal' ? 0 : 1; const c = { top: [l, s[h][1]], bottom: [l, s[1 - h][1]], left: [s[1 - h][0], u], right: [s[h][0], u] }; let p = e.start.y; +e.end.y > +e.start.y && (p = p + '-' + e.end.y); const d = r.get('formatter'); const f = { start: e.start.y, end: e.end.y, nameMap: p }; const g = this._formatterLabel(d, f); const y = new aD({ z2: 30, style: ul(r, { text: g }) }); y.attr(this._yearTextPositionControl(y, c[a], n, a, o)), i.add(y) } }, n.prototype._monthTextPositionControl = function (t, e, n, i, r) { let o = 'left'; let a = 'top'; let s = t[0]; let l = t[1]; return n === 'horizontal' ? (l += r, e && (o = 'center'), i === 'start' && (a = 'bottom')) : (s += r, e && (a = 'middle'), i === 'start' && (o = 'right')), { x: s, y: l, align: o, verticalAlign: a } }, n.prototype._renderMonthText = function (t, e, n, i) { const r = t.getModel('monthLabel'); if (r.get('show')) { let o = r.get('nameMap'); let a = r.get('margin'); const s = r.get('position'); const l = r.get('align'); const u = [this._tlpoints, this._blpoints]; (!o || I(o)) && (o && (e = bl(o) || e), o = e.get(['time', 'monthAbbr']) || []); const c = s === 'start' ? 0 : 1; const p = n === 'horizontal' ? 0 : 1; a = s === 'start' ? -a : a; for (let d = l === 'center', f = 0; f < u[c].length - 1; f++) { const g = u[c][f].slice(); const y = this._firstDayOfMonth[f]; if (d) { const v = this._firstDayPoints[f]; g[p] = (v[p] + u[0][f + 1][p]) / 2 } const m = r.get('formatter'); const _ = o[+y.m - 1]; const x = { yyyy: y.y, yy: (y.y + '').slice(2), MM: y.m, M: +y.m, nameMap: _ }; const w = this._formatterLabel(m, x); const b = new aD({ z2: 30, style: h(ul(r, { text: w }), this._monthTextPositionControl(g, d, n, s, a)) }); i.add(b) } } }, n.prototype._weekTextPositionControl = function (t, e, n, i, r) { let o = 'center'; let a = 'middle'; let s = t[0]; let l = t[1]; const u = n === 'start'; return e === 'horizontal' ? (s = s + i + (u ? 1 : -1) * r[0] / 2, o = u ? 'right' : 'left') : (l = l + i + (u ? 1 : -1) * r[1] / 2, a = u ? 'bottom' : 'top'), { x: s, y: l, align: o, verticalAlign: a } }, n.prototype._renderWeekText = function (t, e, n, i, r) { const o = t.getModel('dayLabel'); if (o.get('show')) { const a = t.coordinateSystem; const s = o.get('position'); let l = o.get('nameMap'); let u = o.get('margin'); const c = a.getFirstDayOfWeek(); if (!l || I(l)) { l && (e = bl(l) || e); const p = e.get(['time', 'dayOfWeekShort']); l = p || v(e.get(['time', 'dayOfWeekAbbr']), function (t) { return t[0] }) } let d = a.getNextNDay(n.end.time, 7 - n.lweek).time; const f = [a.getCellWidth(), a.getCellHeight()]; u = or(u, Math.min(f[1], f[0])), s === 'start' && (d = a.getNextNDay(n.start.time, -(7 + n.fweek)).time, u = -u); for (let g = 0; g < 7; g++) { const y = a.getNextNDay(d, g); const m = a.dataToRect([y.time], !1).center; let _ = g; _ = Math.abs((g + c) % 7); const x = new aD({ z2: 30, style: h(ul(o, { text: l[_] }), this._weekTextPositionControl(m, i, s, u, f)) }); r.add(x) } } }, n.type = 'calendar', n }(YL)); const WB = 864e5; var GB = (function () {
    function t (e) { this.type = 'calendar', this.dimensions = t.dimensions, this.getDimensionsInfo = t.getDimensionsInfo, this._model = e } return t.getDimensionsInfo = function () { return [{ name: 'time', type: 'time' }, 'value'] }, t.prototype.getRangeInfo = function () { return this._rangeInfo }, t.prototype.getModel = function () { return this._model }, t.prototype.getRect = function () { return this._rect }, t.prototype.getCellWidth = function () { return this._sw }, t.prototype.getCellHeight = function () { return this._sh }, t.prototype.getOrient = function () { return this._orient }, t.prototype.getFirstDayOfWeek = function () { return this._firstDayOfWeek }, t.prototype.getDateInfo = function (t) {
      t = yr(t); const e = t.getFullYear(); const n = t.getMonth() + 1; const i = n < 10 ? '0' + n : '' + n; const r = t.getDate(); const o = r < 10 ? '0' + r : '' + r; let a = t.getDay(); return a = Math.abs((a + 7 - this.getFirstDayOfWeek()) % 7), { y: e + '', m: i, d: o, day: a, time: t.getTime(), formatedDate: e + '-' + i + '-' + o, date: t }
    }, t.prototype.getNextNDay = function (t, e) { return e = e || 0, e === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + e), this.getDateInfo(t)) }, t.prototype.update = function (t, e) { function n (t, e) { return t[e] != null && t[e] !== 'auto' } this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay'), this._orient = this._model.get('orient'), this._lineWidth = this._model.getModel('itemStyle').getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption()); const i = this._rangeInfo.weeks || 1; const r = ['width', 'height']; const o = this._model.getCellSize().slice(); const a = this._model.getBoxLayoutParams(); const s = this._orient === 'horizontal' ? [i, 7] : [7, i]; y([0, 1], function (t) { n(o, t) && (a[r[t]] = o[t] * s[t]) }); const l = { width: e.getWidth(), height: e.getHeight() }; const u = this._rect = ru(a, l); y([0, 1], function (t) { n(o, t) || (o[t] = u[r[t]] / s[t]) }), this._sw = o[0], this._sh = o[1] }, t.prototype.dataToPoint = function (t, e) { M(t) && (t = t[0]), e == null && (e = !0); const n = this.getDateInfo(t); const i = this._rangeInfo; const r = n.formatedDate; if (e && !(n.time >= i.start.time && n.time < i.end.time + WB)) return [0 / 0, 0 / 0]; const o = n.day; const a = this._getRangeInfo([i.start.time, r]).nthWeek; return this._orient === 'vertical' ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + a * this._sh + this._sh / 2] : [this._rect.x + a * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2] }, t.prototype.pointToData = function (t) { const e = this.pointToDate(t); return e && e.time }, t.prototype.dataToRect = function (t, e) { const n = this.dataToPoint(t, e); return { contentShape: { x: n[0] - (this._sw - this._lineWidth) / 2, y: n[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth }, center: n, tl: [n[0] - this._sw / 2, n[1] - this._sh / 2], tr: [n[0] + this._sw / 2, n[1] - this._sh / 2], br: [n[0] + this._sw / 2, n[1] + this._sh / 2], bl: [n[0] - this._sw / 2, n[1] + this._sh / 2] } }, t.prototype.pointToDate = function (t) { const e = Math.floor((t[0] - this._rect.x) / this._sw) + 1; const n = Math.floor((t[1] - this._rect.y) / this._sh) + 1; const i = this._rangeInfo.range; return this._orient === 'vertical' ? this._getDateByWeeksAndDay(n, e - 1, i) : this._getDateByWeeksAndDay(e, n - 1, i) }, t.prototype.convertToPixel = function (t, e, n) { const i = Gm(e); return i === this ? i.dataToPoint(n) : null }, t.prototype.convertFromPixel = function (t, e, n) { const i = Gm(e); return i === this ? i.pointToData(n) : null }, t.prototype.containPoint = function () { return console.warn('Not implemented.'), !1 }, t.prototype._initRangeOption = function () { let t; let e = this._model.get('range'); if (M(e) && e.length === 1 && (e = e[0]), M(e))t = e; else { const n = e.toString(); if (/^\d{4}$/.test(n) && (t = [n + '-01-01', n + '-12-31']), /^\d{4}[\/|-]\d{1,2}$/.test(n)) { const i = this.getDateInfo(n); const r = i.date; r.setMonth(r.getMonth() + 1); const o = this.getNextNDay(r, -1); t = [i.formatedDate, o.formatedDate] }/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (t = [n, n]) } if (!t) return e; const a = this._getRangeInfo(t); return a.start.time > a.end.time && t.reverse(), t }, t.prototype._getRangeInfo = function (t) { let e; const n = [this.getDateInfo(t[0]), this.getDateInfo(t[1])]; n[0].time > n[1].time && (e = !0, n.reverse()); let i = Math.floor(n[1].time / WB) - Math.floor(n[0].time / WB) + 1; const r = new Date(n[0].time); const o = r.getDate(); const a = n[1].date.getDate(); r.setDate(o + i - 1); let s = r.getDate(); if (s !== a) for (let l = r.getTime() - n[1].time > 0 ? 1 : -1; (s = r.getDate()) !== a && (r.getTime() - n[1].time) * l > 0;)i -= l, r.setDate(s - l); const u = Math.floor((i + n[0].day + 6) / 7); const h = e ? -u + 1 : u - 1; return e && n.reverse(), { range: [n[0].formatedDate, n[1].formatedDate], start: n[0], end: n[1], allDay: i, weeks: u, nthWeek: h, fweek: n[0].day, lweek: n[1].day } }, t.prototype._getDateByWeeksAndDay = function (t, e, n) { const i = this._getRangeInfo(n); if (t > i.weeks || t === 0 && e < i.fweek || t === i.weeks && e > i.lweek) return null; const r = 7 * (t - 1) - i.fweek + e; const o = new Date(i.start.time); return o.setDate(+i.start.d + r), this.getDateInfo(o) }, t.create = function (e, n) { const i = []; return e.eachComponent('calendar', function (r) { const o = new t(r, e, n); i.push(o), r.coordinateSystem = o }), e.eachSeries(function (t) { t.get('coordinateSystem') === 'calendar' && (t.coordinateSystem = i[t.get('calendarIndex') || 0]) }), i }, t.dimensions = ['time', 'value'], t
  }()); ff(Xm); var XB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.layoutMode = { type: 'box', ignoreSize: !0 }, e } return e(n, t), n.type = 'title', n.defaultOption = { z: 6, show: !0, text: '', target: 'blank', subtext: '', subtarget: 'blank', left: 0, top: 0, backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: 'bold', color: '#464646' }, subtextStyle: { fontSize: 12, color: '#6E7079' } }, n }(CA)); var YB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.render = function (t, e, n) { if (this.group.removeAll(), t.get('show')) { const i = this.group; const r = t.getModel('textStyle'); const o = t.getModel('subtextStyle'); let a = t.get('textAlign'); let s = E(t.get('textBaseline'), t.get('textVerticalAlign')); const l = new aD({ style: ul(r, { text: t.get('text'), fill: r.getTextColor() }, { disableBox: !0 }), z2: 10 }); const u = l.getBoundingRect(); const h = t.get('subtext'); const c = new aD({ style: ul(o, { text: h, fill: o.getTextColor(), y: u.height + t.get('itemGap'), verticalAlign: 'top' }, { disableBox: !0 }), z2: 10 }); const p = t.get('link'); const d = t.get('sublink'); const f = t.get('triggerEvent', !0); l.silent = !p && !f, c.silent = !d && !f, p && l.on('click', function () { nu(p, '_' + t.get('target')) }), d && c.on('click', function () { nu(d, '_' + t.get('subtarget')) }), hD(l).eventData = hD(c).eventData = f ? { componentType: 'title', componentIndex: t.componentIndex } : null, i.add(l), h && i.add(c); let g = i.getBoundingRect(); const y = t.getBoxLayoutParams(); y.width = g.width, y.height = g.height; const v = ru(y, { width: n.getWidth(), height: n.getHeight() }, t.get('padding')); a || (a = t.get('left') || t.get('right'), a === 'middle' && (a = 'center'), a === 'right' ? v.x += v.width : a === 'center' && (v.x += v.width / 2)), s || (s = t.get('top') || t.get('bottom'), s === 'center' && (s = 'middle'), s === 'bottom' ? v.y += v.height : s === 'middle' && (v.y += v.height / 2), s = s || 'top'), i.x = v.x, i.y = v.y, i.markRedraw(); const m = { align: a, verticalAlign: s }; l.setStyle(m), c.setStyle(m), g = i.getBoundingRect(); const _ = v.margin; const x = t.getItemStyle(['color', 'opacity']); x.fill = t.get('backgroundColor'); const w = new nD({ shape: { x: g.x - _[3], y: g.y - _[0], width: g.width + _[1] + _[3], height: g.height + _[0] + _[2], r: t.get('borderRadius') }, style: x, subPixelOptimize: !0, silent: !0 }); i.add(w) } }, n.type = 'title', n }(YL)); ff(Ym); const UB = function (t, e) { return e === 'all' ? { type: 'all', title: t.getLocaleModel().get(['legend', 'selector', 'all']) } : e === 'inverse' ? { type: 'inverse', title: t.getLocaleModel().get(['legend', 'selector', 'inverse']) } : void 0 }; var ZB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.layoutMode = { type: 'box', ignoreSize: !0 }, e } return e(n, t), n.prototype.init = function (t, e, n) { this.mergeDefaultAndTheme(t, n), t.selected = t.selected || {}, this._updateSelector(t) }, n.prototype.mergeOption = function (e, n) { t.prototype.mergeOption.call(this, e, n), this._updateSelector(e) }, n.prototype._updateSelector = function (t) { let e = t.selector; const n = this.ecModel; e === !0 && (e = t.selector = ['all', 'inverse']), M(e) && y(e, function (t, i) { I(t) && (t = { type: t }), e[i] = l(t, UB(n, t.type)) }) }, n.prototype.optionUpdated = function () { this._updateData(this.ecModel); const t = this._data; if (t[0] && this.get('selectedMode') === 'single') { for (var e = !1, n = 0; n < t.length; n++) { const i = t[n].get('name'); if (this.isSelected(i)) { this.select(i), e = !0; break } }!e && this.select(t[0].get('name')) } }, n.prototype._updateData = function (t) { let e = []; let n = []; t.eachRawSeries(function (i) { const r = i.name; n.push(r); let o; if (i.legendVisualProvider) { const a = i.legendVisualProvider; const s = a.getAllNames(); t.isSeriesFiltered(i) || (n = n.concat(s)), s.length ? e = e.concat(s) : o = !0 } else o = !0; o && Gr(i) && e.push(i.name) }), this._availableNames = n; const i = this.get('data') || e; const r = Z(); const o = v(i, function (t) { return (I(t) || D(t)) && (t = { name: t }), r.get(t.name) ? null : (r.set(t.name, !0), new Jk(t, this, this.ecModel)) }, this); this._data = _(o, function (t) { return !!t }) }, n.prototype.getData = function () { return this._data }, n.prototype.select = function (t) { const e = this.option.selected; const n = this.get('selectedMode'); if (n === 'single') { const i = this._data; y(i, function (t) { e[t.get('name')] = !1 }) }e[t] = !0 }, n.prototype.unSelect = function (t) { this.get('selectedMode') !== 'single' && (this.option.selected[t] = !1) }, n.prototype.toggleSelected = function (t) { const e = this.option.selected; e.hasOwnProperty(t) || (e[t] = !0), this[e[t] ? 'unSelect' : 'select'](t) }, n.prototype.allSelect = function () { const t = this._data; const e = this.option.selected; y(t, function (t) { e[t.get('name', !0)] = !0 }) }, n.prototype.inverseSelect = function () { const t = this._data; const e = this.option.selected; y(t, function (t) { const n = t.get('name', !0); e.hasOwnProperty(n) || (e[n] = !0), e[n] = !e[n] }) }, n.prototype.isSelected = function (t) { const e = this.option.selected; return !(e.hasOwnProperty(t) && !e[t]) && p(this._availableNames, t) >= 0 }, n.prototype.getOrient = function () { return this.get('orient') === 'vertical' ? { index: 1, name: 'vertical' } : { index: 0, name: 'horizontal' } }, n.type = 'legend.plain', n.dependencies = ['series'], n.defaultOption = { z: 4, show: !0, orient: 'horizontal', left: 'center', top: 0, align: 'auto', backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, symbolRotate: 'inherit', symbolKeepAspect: !0, inactiveColor: '#ccc', inactiveBorderColor: '#ccc', inactiveBorderWidth: 'auto', itemStyle: { color: 'inherit', opacity: 'inherit', borderColor: 'inherit', borderWidth: 'auto', borderCap: 'inherit', borderJoin: 'inherit', borderDashOffset: 'inherit', borderMiterLimit: 'inherit' }, lineStyle: { width: 'auto', color: 'inherit', inactiveColor: '#ccc', inactiveWidth: 2, opacity: 'inherit', type: 'inherit', cap: 'inherit', join: 'inherit', dashOffset: 'inherit', miterLimit: 'inherit' }, textStyle: { color: '#333' }, selectedMode: !0, selector: !1, selectorLabel: { show: !0, borderRadius: 10, padding: [3, 5, 3, 5], fontSize: 12, fontFamily: 'sans-serif', color: '#666', borderWidth: 1, borderColor: '#666' }, emphasis: { selectorLabel: { show: !0, color: '#eee', backgroundColor: '#666' } }, selectorPosition: 'auto', selectorItemGap: 7, selectorButtonGap: 10, tooltip: { show: !1 } }, n }(CA)); const jB = S; var qB = y; const KB = CI; var $B = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.newlineDisabled = !1, e } return e(n, t), n.prototype.init = function () { this.group.add(this._contentGroup = new KB()), this.group.add(this._selectorGroup = new KB()), this._isFirstRender = !0 }, n.prototype.getContentGroup = function () { return this._contentGroup }, n.prototype.getSelectorGroup = function () { return this._selectorGroup }, n.prototype.render = function (t, e, n) { const i = this._isFirstRender; if (this._isFirstRender = !1, this.resetInner(), t.get('show', !0)) { let r = t.get('align'); const o = t.get('orient'); r && r !== 'auto' || (r = t.get('left') === 'right' && o === 'vertical' ? 'right' : 'left'); const a = t.get('selector', !0); let s = t.get('selectorPosition', !0); !a || s && s !== 'auto' || (s = o === 'horizontal' ? 'end' : 'start'), this.renderInner(r, t, e, n, a, o, s); const l = t.getBoxLayoutParams(); const u = { width: n.getWidth(), height: n.getHeight() }; const h = t.get('padding'); const p = ru(l, u, h); const d = this.layoutInner(t, r, p, i, a, s); const f = ru(c({ width: d.width, height: d.height }, l), u, h); this.group.x = f.x - d.x, this.group.y = f.y - d.y, this.group.markRedraw(), this.group.add(this._backgroundEl = Zm(d, t)) } }, n.prototype.resetInner = function () { this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll() }, n.prototype.renderInner = function (t, e, n, i, r, o, a) { const s = this.getContentGroup(); const l = Z(); const u = e.get('selectedMode'); const c = []; n.eachRawSeries(function (t) { !t.get('legendHoverLink') && c.push(t.id) }), qB(e.getData(), function (r, o) { const a = r.get('name'); if (!this.newlineDisabled && (a === '' || a === '\n')) { const p = new KB(); return p.newline = !0, void s.add(p) } const d = n.getSeriesByName(a)[0]; if (!l.get(a)) if (d) { const f = d.getData(); const g = f.getVisual('legendLineStyle') || {}; const y = f.getVisual('legendIcon'); const v = f.getVisual('style'); const m = this._createItem(d, a, o, r, e, t, g, v, y, u, i); m.on('click', jB(Km, a, null, i, c)).on('mouseover', jB(Qm, d.name, null, i, c)).on('mouseout', jB(Jm, d.name, null, i, c)), l.set(a, !0) } else n.eachRawSeries(function (n) { if (!l.get(a) && n.legendVisualProvider) { const s = n.legendVisualProvider; if (!s.containName(a)) return; const p = s.indexOfName(a); let d = s.getItemVisual(p, 'style'); const f = s.getItemVisual(p, 'legendIcon'); const g = zn(d.fill); g && g[3] === 0 && (g[3] = 0.2, d = h(h({}, d), { fill: Yn(g, 'rgba') })); const y = this._createItem(n, a, o, r, e, t, {}, d, f, u, i); y.on('click', jB(Km, null, a, i, c)).on('mouseover', jB(Qm, null, a, i, c)).on('mouseout', jB(Jm, null, a, i, c)), l.set(a, !0) } }, this) }, this), r && this._createSelector(r, e, i, o, a) }, n.prototype._createSelector = function (t, e, n) { const i = this.getSelectorGroup(); qB(t, function (t) { const r = t.type; const o = new aD({ style: { x: 0, y: 0, align: 'center', verticalAlign: 'middle' }, onclick: function () { n.dispatchAction({ type: r === 'all' ? 'legendAllSelect' : 'legendInverseSelect' }) } }); i.add(o); const a = e.getModel('selectorLabel'); const s = e.getModel(['emphasis', 'selectorLabel']); sl(o, { normal: a, emphasis: s }, { defaultText: t.title }), qa(o) }) }, n.prototype._createItem = function (t, e, n, i, r, o, a, s, l, u, h) { const c = t.visualDrawType; const p = r.get('itemWidth'); const d = r.get('itemHeight'); const f = r.isSelected(e); const g = i.get('symbolRotate'); const y = i.get('symbolKeepAspect'); const v = i.get('icon'); l = v || l || 'roundRect'; const m = jm(l, i, a, s, c, f, h); const _ = new KB(); const x = i.getModel('textStyle'); if (!T(t.getLegendIcon) || v && v !== 'inherit') { const w = v === 'inherit' && t.getData().getVisual('symbol') ? g === 'inherit' ? t.getData().getVisual('symbolRotate') : g : 0; _.add(qm({ itemWidth: p, itemHeight: d, icon: l, iconRotate: w, itemStyle: m.itemStyle, lineStyle: m.lineStyle, symbolKeepAspect: y })) } else _.add(t.getLegendIcon({ itemWidth: p, itemHeight: d, icon: l, iconRotate: g, itemStyle: m.itemStyle, lineStyle: m.lineStyle, symbolKeepAspect: y })); const b = o === 'left' ? p + 5 : -5; const S = o; const M = r.get('formatter'); let C = e; I(M) && M ? C = M.replace('{name}', e != null ? e : '') : T(M) && (C = M(e)); const D = i.get('inactiveColor'); _.add(new aD({ style: ul(x, { text: C, x: b, y: d / 2, fill: f ? x.getTextColor() : D, align: S, verticalAlign: 'middle' }) })); const k = new nD({ shape: _.getBoundingRect(), invisible: !0 }); const A = i.getModel('tooltip'); return A.get('show') && nl({ el: k, componentModel: r, itemName: e, itemTooltipOption: A.option }), _.add(k), _.eachChild(function (t) { t.silent = !0 }), k.silent = !u, this.getContentGroup().add(_), qa(_), _.__legendDataIndex = n, _ }, n.prototype.layoutInner = function (t, e, n, i, r, o) { const a = this.getContentGroup(); const s = this.getSelectorGroup(); TA(t.get('orient'), a, t.get('itemGap'), n.width, n.height); const l = a.getBoundingRect(); const u = [-l.x, -l.y]; if (s.markRedraw(), a.markRedraw(), r) { TA('horizontal', s, t.get('selectorItemGap', !0)); const h = s.getBoundingRect(); const c = [-h.x, -h.y]; const p = t.get('selectorButtonGap', !0); const d = t.getOrient().index; const f = d === 0 ? 'width' : 'height'; const g = d === 0 ? 'height' : 'width'; const y = d === 0 ? 'y' : 'x'; o === 'end' ? c[d] += l[f] + p : u[d] += h[f] + p, c[1 - d] += l[g] / 2 - h[g] / 2, s.x = c[0], s.y = c[1], a.x = u[0], a.y = u[1]; const v = { x: 0, y: 0 }; return v[f] = l[f] + p + h[f], v[g] = Math.max(l[g], h[g]), v[y] = Math.min(0, h[y] + c[1 - d]), v } return a.x = u[0], a.y = u[1], this.group.getBoundingRect() }, n.prototype.remove = function () { this.getContentGroup().removeAll(), this._isFirstRender = !0 }, n.type = 'legend.plain', n }(YL)); var QB = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.setScrollDataIndex = function (t) { this.option.scrollDataIndex = t }, n.prototype.init = function (e, n, i) { const r = uu(e); t.prototype.init.call(this, e, n, i), r_(this, e, r) }, n.prototype.mergeOption = function (e, n) { t.prototype.mergeOption.call(this, e, n), r_(this, this.option, e) }, n.type = 'legend.scroll', n.defaultOption = _l(ZB.defaultOption, { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: 'end', pageFormatter: '{current}/{total}', pageIcons: { horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'], vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z'] }, pageIconColor: '#2f4554', pageIconInactiveColor: '#aaa', pageIconSize: 15, pageTextStyle: { color: '#333' }, animationDurationUpdate: 800 }), n }(ZB)); const JB = CI; const tE = ['width', 'height']; const eE = ['x', 'y']; var nE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.newlineDisabled = !0, e._currentIndex = 0, e } return e(n, t), n.prototype.init = function () { t.prototype.init.call(this), this.group.add(this._containerGroup = new JB()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new JB()) }, n.prototype.resetInner = function () { t.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null }, n.prototype.renderInner = function (e, n, i, r, o, a, s) { function l (t, e) { const i = t + 'DataIndex'; const o = $s(n.get('pageIcons', !0)[n.getOrient().name][e], { onclick: gM(u._pageGo, u, i, n, r) }, { x: -p[0] / 2, y: -p[1] / 2, width: p[0], height: p[1] }); o.name = t, h.add(o) } var u = this; t.prototype.renderInner.call(this, e, n, i, r, o, a, s); var h = this._controllerGroup; const c = n.get('pageIconSize', !0); var p = M(c) ? c : [c, c]; l('pagePrev', 0); const d = n.getModel('pageTextStyle'); h.add(new aD({ name: 'pageText', style: { text: 'xx/xx', fill: d.getTextColor(), font: d.getFont(), verticalAlign: 'middle', align: 'center' }, silent: !0 })), l('pageNext', 1) }, n.prototype.layoutInner = function (t, e, n, i, r, o) { const a = this.getSelectorGroup(); const l = t.getOrient().index; const u = tE[l]; const h = eE[l]; const c = tE[1 - l]; const p = eE[1 - l]; r && TA('horizontal', a, t.get('selectorItemGap', !0)); const d = t.get('selectorButtonGap', !0); const f = a.getBoundingRect(); const g = [-f.x, -f.y]; const y = s(n); r && (y[u] = n[u] - f[u] - d); const v = this._layoutContentAndController(t, i, y, l, u, c, p, h); if (r) { if (o === 'end')g[l] += v[u] + d; else { const m = f[u] + d; g[l] -= m, v[h] -= m }v[u] += f[u] + d, g[1 - l] += v[p] + v[c] / 2 - f[c] / 2, v[c] = Math.max(v[c], f[c]), v[p] = Math.min(v[p], f[p] + g[1 - l]), a.x = g[0], a.y = g[1], a.markRedraw() } return v }, n.prototype._layoutContentAndController = function (t, e, n, i, r, o, a, s) { const l = this.getContentGroup(); const u = this._containerGroup; const h = this._controllerGroup; TA(t.get('orient'), l, t.get('itemGap'), i ? n.width : null, i ? null : n.height), TA('horizontal', h, t.get('pageButtonItemGap', !0)); const c = l.getBoundingRect(); const p = h.getBoundingRect(); const d = this._showController = c[r] > n[r]; const f = [-c.x, -c.y]; e || (f[i] = l[s]); const g = [0, 0]; const y = [-p.x, -p.y]; const v = E(t.get('pageButtonGap', !0), t.get('itemGap', !0)); if (d) { const m = t.get('pageButtonPosition', !0); m === 'end' ? y[i] += n[r] - p[r] : g[i] += p[r] + v }y[1 - i] += c[o] / 2 - p[o] / 2, l.setPosition(f), u.setPosition(g), h.setPosition(y); const _ = { x: 0, y: 0 }; if (_[r] = d ? n[r] : c[r], _[o] = Math.max(c[o], p[o]), _[a] = Math.min(0, p[a] + y[1 - i]), u.__rectSize = n[r], d) { const x = { x: 0, y: 0 }; x[r] = Math.max(n[r] - p[r] - v, 0), x[o] = _[o], u.setClipPath(new nD({ shape: x })), u.__rectSize = x[r] } else h.eachChild(function (t) { t.attr({ invisible: !0, silent: !0 }) }); const w = this._getPageInfo(t); return w.pageIndex != null && Is(l, { x: w.contentPosition[0], y: w.contentPosition[1] }, d ? t : null), this._updatePageInfoView(t, w), _ }, n.prototype._pageGo = function (t, e, n) { const i = this._getPageInfo(e)[t]; i != null && n.dispatchAction({ type: 'legendScroll', scrollDataIndex: i, legendId: e.id }) }, n.prototype._updatePageInfoView = function (t, e) { const n = this._controllerGroup; y(['pagePrev', 'pageNext'], function (i) { const r = i + 'DataIndex'; const o = e[r] != null; const a = n.childOfName(i); a && (a.setStyle('fill', o ? t.get('pageIconColor', !0) : t.get('pageIconInactiveColor', !0)), a.cursor = o ? 'pointer' : 'default') }); const i = n.childOfName('pageText'); const r = t.get('pageFormatter'); const o = e.pageIndex; const a = o != null ? o + 1 : 0; const s = e.pageCount; i && r && i.setStyle('text', I(r) ? r.replace('{current}', a == null ? '' : a + '').replace('{total}', s == null ? '' : s + '') : r({ current: a, total: s })) }, n.prototype._getPageInfo = function (t) { function e (t) { if (t) { const e = t.getBoundingRect(); const n = e[l] + t[l]; return { s: n, e: n + e[s], i: t.__legendDataIndex } } } function n (t, e) { return t.e >= e && t.s <= e + o } const i = t.get('scrollDataIndex', !0); const r = this.getContentGroup(); var o = this._containerGroup.__rectSize; const a = t.getOrient().index; var s = tE[a]; var l = eE[a]; const u = this._findTargetItemIndex(i); const h = r.children(); const c = h[u]; const p = h.length; const d = p ? 1 : 0; const f = { contentPosition: [r.x, r.y], pageCount: d, pageIndex: d - 1, pagePrevDataIndex: null, pageNextDataIndex: null }; if (!c) return f; const g = e(c); f.contentPosition[a] = -g.s; for (var y = u + 1, v = g, m = g, _ = null; p >= y; ++y)_ = e(h[y]), (!_ && m.e > v.s + o || _ && !n(_, v.s)) && (v = m.i > v.i ? m : _, v && (f.pageNextDataIndex == null && (f.pageNextDataIndex = v.i), ++f.pageCount)), m = _; for (var y = u - 1, v = g, m = g, _ = null; y >= -1; --y)_ = e(h[y]), _ && n(m, _.s) || !(v.i < m.i) || (m = v, f.pagePrevDataIndex == null && (f.pagePrevDataIndex = v.i), ++f.pageCount, ++f.pageIndex), v = _; return f }, n.prototype._findTargetItemIndex = function (t) { if (!this._showController) return 0; let e; let n; const i = this.getContentGroup(); return i.eachChild(function (i, r) { const o = i.__legendDataIndex; n == null && o != null && (n = r), o === t && (e = r) }), e != null ? e : n }, n.type = 'legend.scroll', n }($B)); ff(a_); var iE = qr(); const rE = s; const oE = gM; const aE = (function () { function t () { this._dragging = !1, this.animationThreshold = 15 } return t.prototype.render = function (t, e, n, i) { const r = e.get('value'); const o = e.get('status'); if (this._axisModel = t, this._axisPointerModel = e, this._api = n, i || this._lastValue !== r || this._lastStatus !== o) { this._lastValue = r, this._lastStatus = o; let a = this._group; const s = this._handle; if (!o || o === 'hide') return a && a.hide(), void (s && s.hide()); a && a.show(), s && s.show(); const l = {}; this.makeElOption(l, r, t, e, n); const u = l.graphicKey; u !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = u; const h = this._moveAnimation = this.determineAnimation(t, e); if (a) { const c = S(s_, e, h); this.updatePointerEl(a, l, c), this.updateLabelEl(a, l, c, e) } else a = this._group = new CI(), this.createPointerEl(a, l, t, e), this.createLabelEl(a, l, t, e), n.getZr().add(a); c_(a, e, !0), this._renderHandle(r) } }, t.prototype.remove = function (t) { this.clear(t) }, t.prototype.dispose = function (t) { this.clear(t) }, t.prototype.determineAnimation = function (t, e) { const n = e.get('animation'); const i = t.axis; const r = i.type === 'category'; const o = e.get('snap'); if (!o && !r) return !1; if (n === 'auto' || n == null) { const a = this.animationThreshold; if (r && i.getBandWidth() > a) return !0; if (o) { const s = qg(t).seriesDataCount; const l = i.getExtent(); return Math.abs(l[0] - l[1]) / s > a } return !1 } return n === !0 }, t.prototype.makeElOption = function () {}, t.prototype.createPointerEl = function (t, e) { const n = e.pointer; if (n) { const i = iE(t).pointerEl = new Bk[n.type](rE(e.pointer)); t.add(i) } }, t.prototype.createLabelEl = function (t, e, n, i) { if (e.label) { const r = iE(t).labelEl = new aD(rE(e.label)); t.add(r), u_(r, i) } }, t.prototype.updatePointerEl = function (t, e, n) { const i = iE(t).pointerEl; i && e.pointer && (i.setStyle(e.pointer.style), n(i, { shape: e.pointer.shape })) }, t.prototype.updateLabelEl = function (t, e, n, i) { const r = iE(t).labelEl; r && (r.setStyle(e.label.style), n(r, { x: e.label.x, y: e.label.y }), u_(r, i)) }, t.prototype._renderHandle = function (t) { if (!this._dragging && this.updateHandleTransform) { const e = this._axisPointerModel; const n = this._api.getZr(); let i = this._handle; const r = e.getModel('handle'); const o = e.get('status'); if (!r.get('show') || !o || o === 'hide') return i && n.remove(i), void (this._handle = null); let a; this._handle || (a = !0, i = this._handle = $s(r.get('icon'), { cursor: 'move', draggable: !0, onmousemove: function (t) { EM(t.event) }, onmousedown: oE(this._onHandleDragMove, this, 0, 0), drift: oE(this._onHandleDragMove, this), ondragend: oE(this._onHandleDragEnd, this) }), n.add(i)), c_(i, e, !1), i.setStyle(r.getItemStyle(null, ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'])); let s = r.get('size'); M(s) || (s = [s, s]), i.scaleX = s[0] / 2, i.scaleY = s[1] / 2, cc(this, '_doDispatchAxisPointer', r.get('throttle') || 0, 'fixRate'), this._moveHandleToValue(t, a) } }, t.prototype._moveHandleToValue = function (t, e) { s_(this._axisPointerModel, !e && this._moveAnimation, this._handle, h_(this.getHandleTransform(t, this._axisModel, this._axisPointerModel))) }, t.prototype._onHandleDragMove = function (t, e) { const n = this._handle; if (n) { this._dragging = !0; const i = this.updateHandleTransform(h_(n), [t, e], this._axisModel, this._axisPointerModel); this._payloadInfo = i, n.stopAnimation(), n.attr(h_(i)), iE(n).lastProp = null, this._doDispatchAxisPointer() } }, t.prototype._doDispatchAxisPointer = function () { const t = this._handle; if (t) { const e = this._payloadInfo; const n = this._axisModel; this._api.dispatchAction({ type: 'updateAxisPointer', x: e.cursorPoint[0], y: e.cursorPoint[1], tooltipOption: e.tooltipOption, axesInfo: [{ axisDim: n.axis.dim, axisIndex: n.componentIndex }] }) } }, t.prototype._onHandleDragEnd = function () { this._dragging = !1; const t = this._handle; if (t) { const e = this._axisPointerModel.get('value'); this._moveHandleToValue(e), this._api.dispatchAction({ type: 'hideTip' }) } }, t.prototype.clear = function (t) { this._lastValue = null, this._lastStatus = null; const e = t.getZr(); const n = this._group; const i = this._handle; e && n && (this._lastGraphicKey = null, n && e.remove(n), i && e.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), pc(this, '_doDispatchAxisPointer') }, t.prototype.doClear = function () {}, t.prototype.buildLabel = function (t, e, n) { return n = n || 0, { x: t[n], y: t[1 - n], width: e[n], height: e[1 - n] } }, t }()); var sE = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.makeElOption = function (t, e, n, i, r) { const o = n.axis; const a = o.grid; const s = i.get('type'); const l = x_(a, o).getOtherAxis(o).getGlobalExtent(); const u = o.toGlobalCoord(o.dataToCoord(e, !0)); if (s && s !== 'none') { const h = p_(i); const c = lE[s](o, u, l); c.style = h, t.graphicKey = c.type, t.pointer = c } const p = Tg(a.model, n); v_(e, t, p, n, i, r) }, n.prototype.getHandleTransform = function (t, e, n) { const i = Tg(e.axis.grid.model, e, { labelInside: !1 }); i.labelMargin = n.get(['handle', 'margin']); const r = y_(e.axis, t, i); return { x: r[0], y: r[1], rotation: i.rotation + (i.labelDirection < 0 ? Math.PI : 0) } }, n.prototype.updateHandleTransform = function (t, e, n) { const i = n.axis; const r = i.grid; const o = i.getGlobalExtent(!0); const a = x_(r, i).getOtherAxis(i).getGlobalExtent(); const s = i.dim === 'x' ? 0 : 1; const l = [t.x, t.y]; l[s] += e[s], l[s] = Math.min(o[1], l[s]), l[s] = Math.max(o[0], l[s]); const u = (a[1] + a[0]) / 2; const h = [u, u]; h[s] = l[s]; const c = [{ verticalAlign: 'middle' }, { align: 'center' }]; return { x: l[0], y: l[1], rotation: t.rotation, cursorPoint: h, tooltipOption: c[s] } }, n }(aE)); var lE = { line: function (t, e, n) { const i = m_([e, n[0]], [e, n[1]], w_(t)); return { type: 'Line', subPixelOptimize: !0, shape: i } }, shadow: function (t, e, n) { const i = Math.max(1, t.getBandWidth()); const r = n[1] - n[0]; return { type: 'Rect', shape: __([e - i / 2, n[0]], [i, r], w_(t)) } } }; var uE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.type = 'axisPointer', n.defaultOption = { show: 'auto', z: 50, type: 'line', snap: !1, triggerTooltip: !0, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: '#B9BEC9', width: 1, type: 'dashed' }, shadowStyle: { color: 'rgba(210,219,238,0.2)' }, label: { show: !0, formatter: null, precision: 'auto', margin: 3, color: '#fff', padding: [5, 7, 5, 7], backgroundColor: 'auto', borderColor: null, borderWidth: 0, borderRadius: 3 }, handle: { show: !1, icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', size: 45, margin: 50, color: '#333', shadowBlur: 3, shadowColor: '#aaa', shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } }, n }(CA)); var hE = qr(); var cE = y; var pE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.render = function (t, e, n) { const i = e.getComponent('tooltip'); const r = t.get('triggerOn') || i && i.get('triggerOn') || 'mousemove|click'; b_('axisPointer', n, function (t, e, n) { r !== 'none' && (t === 'leave' || r.indexOf(t) >= 0) && n({ type: 'updateAxisPointer', currTrigger: t, x: e && e.offsetX, y: e && e.offsetY }) }) }, n.prototype.remove = function (t, e) { D_('axisPointer', e) }, n.prototype.dispose = function (t, e) { D_('axisPointer', e) }, n.type = 'axisPointer', n }(YL)); var dE = qr(); var fE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.type = 'tooltip', n.dependencies = ['axisPointer'], n.defaultOption = { z: 60, show: !0, showContent: !0, trigger: 'item', triggerOn: 'mousemove|click', alwaysShowContent: !1, displayMode: 'single', renderMode: 'auto', confine: null, showDelay: 0, hideDelay: 100, transitionDuration: 0.4, enterable: !1, backgroundColor: '#fff', shadowBlur: 10, shadowColor: 'rgba(0, 0, 0, .2)', shadowOffsetX: 1, shadowOffsetY: 2, borderRadius: 4, borderWidth: 1, padding: null, extraCssText: '', axisPointer: { type: 'line', axis: 'auto', animation: 'auto', animationDurationUpdate: 200, animationEasingUpdate: 'exponentialOut', crossStyle: { color: '#999', width: 1, type: 'dashed', textStyle: {} } }, textStyle: { color: '#666', fontSize: 14 } }, n }(CA)); var gE = G_(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']); const yE = G_(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']); var vE = X_(yE, 'transition'); var mE = X_(gE, 'transform'); const _E = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;' + (ZS.transform3dSupported ? 'will-change:transform;' : ''); const xE = (function () { function t (t, e, n) { if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, ZS.wxa) return null; const i = document.createElement('div'); i.domBelongToZr = !0, this.el = i; const r = this._zr = e.getZr(); const o = this._appendToBody = n && n.appendToBody; Q_(this._styleCoord, r, o, e.getWidth() / 2, e.getHeight() / 2), o ? document.body.appendChild(i) : t.appendChild(i), this._container = t; const a = this; i.onmouseenter = function () { a._enterable && (clearTimeout(a._hideTimeout), a._show = !0), a._inContent = !0 }, i.onmousemove = function (t) { if (t = t || window.event, !a._enterable) { const e = r.handler; const n = r.painter.getViewportRoot(); Le(n, t, !0), e.dispatch('mousemove', t) } }, i.onmouseleave = function () { a._inContent = !1, a._enterable && a._show && a.hideLater(a._hideDelay) } } return t.prototype.update = function (t) { const e = this._container; const n = Y_(e, 'position'); const i = e.style; i.position !== 'absolute' && n !== 'absolute' && (i.position = 'relative'); const r = t.get('alwaysShowContent'); r && this._moveIfResized(), this._alwaysShowContent = r, this.el.className = t.get('className') || '' }, t.prototype.show = function (t, e) { clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout); const n = this.el; const i = n.style; const r = this._styleCoord; n.innerHTML ? i.cssText = _E + $_(t, !this._firstShow, this._longHide) + q_(r[0], r[1], !0) + ('border-color:' + eu(e) + ';') + (t.get('extraCssText') || '') + (';pointer-events:' + (this._enterable ? 'auto' : 'none')) : i.display = 'none', this._show = !0, this._firstShow = !1, this._longHide = !1 }, t.prototype.setContent = function (t, e, n, i, r) { const o = this.el; if (t == null) return void (o.innerHTML = ''); let a = ''; if (I(r) && n.get('trigger') === 'item' && !W_(n) && (a = Z_(n, i, r)), I(t))o.innerHTML = t + a; else if (t) { o.innerHTML = '', M(t) || (t = [t]); for (let s = 0; s < t.length; s++)P(t[s]) && t[s].parentNode !== o && o.appendChild(t[s]); if (a && o.childNodes.length) { const l = document.createElement('div'); l.innerHTML = a, o.appendChild(l) } } }, t.prototype.setEnterable = function (t) { this._enterable = t }, t.prototype.getSize = function () { const t = this.el; return [t.offsetWidth, t.offsetHeight] }, t.prototype.moveTo = function (t, e) { const n = this._styleCoord; if (Q_(n, this._zr, this._appendToBody, t, e), n[0] != null && n[1] != null) { const i = this.el.style; const r = q_(n[0], n[1]); y(r, function (t) { i[t[0]] = t[1] }) } }, t.prototype._moveIfResized = function () { const t = this._styleCoord[2]; const e = this._styleCoord[3]; this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight()) }, t.prototype.hide = function () { const t = this; const e = this.el.style; e.visibility = 'hidden', e.opacity = '0', ZS.transform3dSupported && (e.willChange = ''), this._show = !1, this._longHideTimeout = setTimeout(function () { return t._longHide = !0 }, 500) }, t.prototype.hideLater = function (t) { !this._show || this._inContent && this._enterable || this._alwaysShowContent || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(gM(this.hide, this), t)) : this.hide()) }, t.prototype.isShow = function () { return this._show }, t.prototype.dispose = function () { this.el.parentNode.removeChild(this.el) }, t }()); const wE = (function () {
    function t (t) { this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), ex(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2) } return t.prototype.update = function (t) { const e = t.get('alwaysShowContent'); e && this._moveIfResized(), this._alwaysShowContent = e }, t.prototype.show = function () { this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0 }, t.prototype.setContent = function (t, e, n, i) { const r = this; k(t) && Cr(''), this.el && this._zr.remove(this.el); const o = n.getModel('textStyle'); this.el = new aD({ style: { rich: e.richTextStyles, text: t, lineHeight: 22, borderWidth: 1, borderColor: i, textShadowColor: o.get('textShadowColor'), fill: n.get(['textStyle', 'color']), padding: Zh(n, 'richText'), verticalAlign: 'top', align: 'left' }, z: n.get('z') }), y(['backgroundColor', 'borderRadius', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'], function (t) { r.el.style[t] = n.get(t) }), y(['textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'], function (t) { r.el.style[t] = o.get(t) || 0 }), this._zr.add(this.el); const a = this; this.el.on('mouseover', function () { a._enterable && (clearTimeout(a._hideTimeout), a._show = !0), a._inContent = !0 }), this.el.on('mouseout', function () { a._enterable && a._show && a.hideLater(a._hideDelay), a._inContent = !1 }) }, t.prototype.setEnterable = function (t) { this._enterable = t }, t.prototype.getSize = function () {
      const t = this.el; const e = this.el.getBoundingRect(); const n = tx(t.style); return [e.width + n.left + n.right, e.height + n.top + n.bottom]
    }, t.prototype.moveTo = function (t, e) { const n = this.el; if (n) { const i = this._styleCoord; ex(i, this._zr, t, e), t = i[0], e = i[1]; const r = n.style; const o = J_(r.borderWidth || 0); const a = tx(r); n.x = t + o + a.left, n.y = e + o + a.top, n.markRedraw() } }, t.prototype._moveIfResized = function () { const t = this._styleCoord[2]; const e = this._styleCoord[3]; this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight()) }, t.prototype.hide = function () { this.el && this.el.hide(), this._show = !1 }, t.prototype.hideLater = function (t) { !this._show || this._inContent && this._enterable || this._alwaysShowContent || (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(gM(this.hide, this), t)) : this.hide()) }, t.prototype.isShow = function () { return this._show }, t.prototype.dispose = function () { this._zr.remove(this.el) }, t
  }()); const bE = new nD({ shape: { x: -1, y: -1, width: 2, height: 2 } }); var SE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.init = function (t, e) { if (!ZS.node && e.getDom()) { const n = t.getComponent('tooltip'); const i = this._renderMode = eo(n.get('renderMode')); this._tooltipContent = i === 'richText' ? new wE(e) : new xE(e.getDom(), e, { appendToBody: n.get('appendToBody', !0) }) } }, n.prototype.render = function (t, e, n) { if (!ZS.node && n.getDom()) { this.group.removeAll(), this._tooltipModel = t, this._ecModel = e, this._api = n; const i = this._tooltipContent; i.update(t), i.setEnterable(t.get('enterable')), this._initGlobalListener(), this._keepShow(), this._renderMode !== 'richText' && t.get('transitionDuration') ? cc(this, '_updatePosition', 50, 'fixRate') : pc(this, '_updatePosition') } }, n.prototype._initGlobalListener = function () { const t = this._tooltipModel; const e = t.get('triggerOn'); b_('itemTooltip', this._api, gM(function (t, n, i) { e !== 'none' && (e.indexOf(t) >= 0 ? this._tryShow(n, i) : t === 'leave' && this._hide(i)) }, this)) }, n.prototype._keepShow = function () { const t = this._tooltipModel; const e = this._ecModel; const n = this._api; const i = t.get('triggerOn'); if (this._lastX != null && this._lastY != null && i !== 'none' && i !== 'click') { const r = this; clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () { !n.isDisposed() && r.manuallyShowTip(t, e, n, { x: r._lastX, y: r._lastY, dataByCoordSys: r._lastDataByCoordSys }) }) } }, n.prototype.manuallyShowTip = function (t, e, n, i) { if (i.from !== this.uid && !ZS.node && n.getDom()) { const r = ix(i, n); this._ticket = ''; const o = i.dataByCoordSys; const a = lx(i, e, n); if (a) { const s = a.el.getBoundingRect().clone(); s.applyTransform(a.el.transform), this._tryShow({ offsetX: s.x + s.width / 2, offsetY: s.y + s.height / 2, target: a.el, position: i.position, positionDefault: 'bottom' }, r) } else if (i.tooltip && i.x != null && i.y != null) { const l = bE; l.x = i.x, l.y = i.y, l.update(), hD(l).tooltipConfig = { name: null, option: i.tooltip }, this._tryShow({ offsetX: i.x, offsetY: i.y, target: l }, r) } else if (o) this._tryShow({ offsetX: i.x, offsetY: i.y, position: i.position, dataByCoordSys: o, tooltipOption: i.tooltipOption }, r); else if (i.seriesIndex != null) { if (this._manuallyAxisShowTip(t, e, n, i)) return; const u = k_(i, e); const h = u.point[0]; const c = u.point[1]; h != null && c != null && this._tryShow({ offsetX: h, offsetY: c, target: u.el, position: i.position, positionDefault: 'bottom' }, r) } else i.x != null && i.y != null && (n.dispatchAction({ type: 'updateAxisPointer', x: i.x, y: i.y }), this._tryShow({ offsetX: i.x, offsetY: i.y, position: i.position, target: n.getZr().findHover(i.x, i.y).target }, r)) } }, n.prototype.manuallyHideTip = function (t, e, n, i) { const r = this._tooltipContent; this._tooltipModel && r.hideLater(this._tooltipModel.get('hideDelay')), this._lastX = this._lastY = this._lastDataByCoordSys = null, i.from !== this.uid && this._hide(ix(i, n)) }, n.prototype._manuallyAxisShowTip = function (t, e, n, i) { const r = i.seriesIndex; const o = i.dataIndex; const a = e.getComponent('axisPointer').coordSysAxesInfo; if (r != null && o != null && a != null) { const s = e.getSeriesByIndex(r); if (s) { const l = s.getData(); const u = nx([l.getItemModel(o), s, (s.coordinateSystem || {}).model], this._tooltipModel); if (u.get('trigger') === 'axis') return n.dispatchAction({ type: 'updateAxisPointer', seriesIndex: r, dataIndex: o, position: i.position }), !0 } } }, n.prototype._tryShow = function (t, e) { const n = t.target; const i = this._tooltipModel; if (i) { this._lastX = t.offsetX, this._lastY = t.offsetY; const r = t.dataByCoordSys; if (r && r.length) this._showAxisTooltip(r, t); else if (n) { this._lastDataByCoordSys = null; let o, a; Lc(n, function (t) { return hD(t).dataIndex != null ? (o = t, !0) : hD(t).tooltipConfig != null ? (a = t, !0) : void 0 }, !0), o ? this._showSeriesItemTooltip(t, o, e) : a ? this._showComponentItemTooltip(t, a, e) : this._hide(e) } else this._lastDataByCoordSys = null, this._hide(e) } }, n.prototype._showOrMove = function (t, e) { const n = t.get('showDelay'); e = gM(e, this), clearTimeout(this._showTimout), n > 0 ? this._showTimout = setTimeout(e, n) : e() }, n.prototype._showAxisTooltip = function (t, e) { const n = this._ecModel; const i = this._tooltipModel; const r = [e.offsetX, e.offsetY]; const o = nx([e.tooltipOption], i); const a = this._renderMode; const s = []; const l = Oh('section', { blocks: [], noHeader: !0 }); const u = []; const c = new HL(); y(t, function (t) { y(t.dataByAxis, function (t) { const e = n.getComponent(t.axisDim + 'Axis', t.axisIndex); const r = t.value; if (e && r != null) { const o = g_(r, e.axis, n, t.seriesDataIndices, t.valueLabelOpt); const p = Oh('section', { header: o, noHeader: !G(o), sortBlocks: !0, blocks: [] }); l.blocks.push(p), y(t.seriesDataIndices, function (l) { const d = n.getSeriesByIndex(l.seriesIndex); const f = l.dataIndexInside; const g = d.getDataParams(f); if (!(g.dataIndex < 0)) { g.axisDim = t.axisDim, g.axisIndex = t.axisIndex, g.axisType = t.axisType, g.axisId = t.axisId, g.axisValue = nf(e.axis, { value: r }), g.axisValueLabel = o, g.marker = c.makeTooltipMarker('item', eu(g.color), a); const y = dh(d.formatTooltip(f, !0, null)); const v = y.frag; if (v) { const m = nx([d], i).get('valueFormatter'); p.blocks.push(m ? h({ valueFormatter: m }, v) : v) }y.text && u.push(y.text), s.push(g) } }) } }) }), l.blocks.reverse(), u.reverse(); const p = e.position; const d = o.get('order'); const f = Vh(l, c, a, d, n.get('useUTC'), o.get('textStyle')); f && u.unshift(f); const g = a === 'richText' ? '\n\n' : '<br/>'; const v = u.join(g); this._showOrMove(o, function () { this._updateContentNotChangedOnAxis(t, s) ? this._updatePosition(o, p, r[0], r[1], this._tooltipContent, s) : this._showTooltipContent(o, v, s, Math.random() + '', r[0], r[1], p, null, c) }) }, n.prototype._showSeriesItemTooltip = function (t, e, n) { const i = this._ecModel; const r = hD(e); const o = r.seriesIndex; const a = i.getSeriesByIndex(o); const s = r.dataModel || a; const l = r.dataIndex; const u = r.dataType; const c = s.getData(u); const p = this._renderMode; const d = t.positionDefault; const f = nx([c.getItemModel(l), s, a && (a.coordinateSystem || {}).model], this._tooltipModel, d ? { position: d } : null); const g = f.get('trigger'); if (g == null || g === 'item') { const y = s.getDataParams(l, u); const v = new HL(); y.marker = v.makeTooltipMarker('item', eu(y.color), p); const m = dh(s.formatTooltip(l, !1, u)); const _ = f.get('order'); const x = f.get('valueFormatter'); const w = m.frag; const b = w ? Vh(x ? h({ valueFormatter: x }, w) : w, v, p, _, i.get('useUTC'), f.get('textStyle')) : m.text; const S = 'item_' + s.name + '_' + l; this._showOrMove(f, function () { this._showTooltipContent(f, b, y, S, t.offsetX, t.offsetY, t.position, t.target, v) }), n({ type: 'showTip', dataIndexInside: l, dataIndex: c.getRawIndex(l), seriesIndex: o, from: this.uid }) } }, n.prototype._showComponentItemTooltip = function (t, e, n) { const i = hD(e); const r = i.tooltipConfig; let o = r.option || {}; if (I(o)) { const a = o; o = { content: a, formatter: a } } const l = [o]; const u = this._ecModel.getComponent(i.componentMainType, i.componentIndex); u && l.push(u), l.push({ formatter: o.content }); const h = t.positionDefault; const c = nx(l, this._tooltipModel, h ? { position: h } : null); const p = c.get('content'); const d = Math.random() + ''; const f = new HL(); this._showOrMove(c, function () { const n = s(c.get('formatterParams') || {}); this._showTooltipContent(c, p, n, d, t.offsetX, t.offsetY, t.position, e, f) }), n({ type: 'showTip', from: this.uid }) }, n.prototype._showTooltipContent = function (t, e, n, i, r, o, a, s, l) { if (this._ticket = '', t.get('showContent') && t.get('show')) { const u = this._tooltipContent; u.setEnterable(t.get('enterable')); const h = t.get('formatter'); a = a || t.get('position'); let c = e; const p = this._getNearestPoint([r, o], n, t.get('trigger'), t.get('borderColor')); const d = p.color; if (h) if (I(h)) { const f = t.ecModel.get('useUTC'); const g = M(n) ? n[0] : n; const y = g && g.axisType && g.axisType.indexOf('time') >= 0; c = h, y && (c = Dl(g.axisValue, c, f)), c = Kl(c, n, !0) } else if (T(h)) { const v = gM(function (e, i) { e === this._ticket && (u.setContent(i, l, t, d, a), this._updatePosition(t, a, r, o, u, n, s)) }, this); this._ticket = i, c = h(n, i, v) } else c = h; u.setContent(c, l, t, d, a), u.show(t, d), this._updatePosition(t, a, r, o, u, n, s) } }, n.prototype._getNearestPoint = function (t, e, n, i) { return n === 'axis' || M(e) ? { color: i || (this._renderMode === 'html' ? '#fff' : 'none') } : M(e) ? void 0 : { color: i || e.color || e.borderColor } }, n.prototype._updatePosition = function (t, e, n, i, r, o, a) { const s = this._api.getWidth(); const l = this._api.getHeight(); e = e || t.get('position'); const u = r.getSize(); let h = t.get('align'); let c = t.get('verticalAlign'); const p = a && a.getBoundingRect().clone(); if (a && p.applyTransform(a.transform), T(e) && (e = e([n, i], o, r.el, p, { viewSize: [s, l], contentSize: u.slice() })), M(e))n = or(e[0], s), i = or(e[1], l); else if (k(e)) { const d = e; d.width = u[0], d.height = u[1]; const f = ru(d, { width: s, height: l }); n = f.x, i = f.y, h = null, c = null } else if (I(e) && a) { var g = ax(e, p, u, t.get('borderWidth')); n = g[0], i = g[1] } else { var g = rx(n, i, r, s, l, h ? null : 20, c ? null : 20); n = g[0], i = g[1] } if (h && (n -= sx(h) ? u[0] / 2 : h === 'right' ? u[0] : 0), c && (i -= sx(c) ? u[1] / 2 : c === 'bottom' ? u[1] : 0), W_(t)) { var g = ox(n, i, r, s, l); n = g[0], i = g[1] }r.moveTo(n, i) }, n.prototype._updateContentNotChangedOnAxis = function (t, e) { const n = this._lastDataByCoordSys; const i = this._cbParamsList; let r = !!n && n.length === t.length; return r && y(n, function (n, o) { const a = n.dataByAxis || []; const s = t[o] || {}; const l = s.dataByAxis || []; r = r && a.length === l.length, r && y(a, function (t, n) { const o = l[n] || {}; const a = t.seriesDataIndices || []; const s = o.seriesDataIndices || []; r = r && t.value === o.value && t.axisType === o.axisType && t.axisId === o.axisId && a.length === s.length, r && y(a, function (t, e) { const n = s[e]; r = r && t.seriesIndex === n.seriesIndex && t.dataIndex === n.dataIndex }), i && y(t.seriesDataIndices, function (t) { const n = t.seriesIndex; const o = e[n]; const a = i[n]; o && a && a.data !== o.data && (r = !1) }) }) }), this._lastDataByCoordSys = t, this._cbParamsList = e, !!r }, n.prototype._hide = function (t) { this._lastDataByCoordSys = null, t({ type: 'hideTip', from: this.uid }) }, n.prototype.dispose = function (t, e) { !ZS.node && e.getDom() && (pc(this, '_updatePosition'), this._tooltipContent.dispose(), D_('itemTooltip', e)) }, n.type = 'tooltip', n }(YL)); ff(ux); const ME = qr(); const TE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.createdBySelf = !1, e } return e(n, t), n.prototype.init = function (t, e, n) { this.mergeDefaultAndTheme(t, n), this._mergeOption(t, n, !1, !0) }, n.prototype.isAnimationEnabled = function () { if (ZS.node) return !1; const t = this.__hostSeries; return this.getShallow('animation') && t && t.isAnimationEnabled() }, n.prototype.mergeOption = function (t, e) { this._mergeOption(t, e, !1, !1) }, n.prototype._mergeOption = function (t, e, n, i) { const r = this.mainType; n || e.eachSeries(function (t) { const n = t.get(this.mainType, !0); let o = ME(t)[r]; return n && n.data ? (o ? o._mergeOption(n, e, !0) : (i && cx(n), y(n.data, function (t) { t instanceof Array ? (cx(t[0]), cx(t[1])) : cx(t) }), o = this.createMarkerModelFromSeries(n, this, e), h(o, { mainType: this.mainType, seriesIndex: t.seriesIndex, name: t.name, createdBySelf: !0 }), o.__hostSeries = t), void (ME(t)[r] = o)) : void (ME(t)[r] = null) }, this) }, n.prototype.formatTooltip = function (t) { const e = this.getData(); const n = this.getRawValue(t); const i = e.getName(t); return Oh('section', { header: this.name, blocks: [Oh('nameValue', { name: i, value: n, noName: !i, noValue: n == null })] }) }, n.prototype.getData = function () { return this._data }, n.prototype.setData = function (t) { this._data = t }, n.getMarkerModelFromSeries = function (t, e) { return ME(t)[e] }, n.type = 'marker', n.dependencies = ['series', 'grid', 'polar', 'geo'], n }(CA)); f(TE, SL.prototype); var IE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.createMarkerModelFromSeries = function (t, e, i) { return new n(t, e, i) }, n.type = 'markPoint', n.defaultOption = { z: 5, symbol: 'pin', symbolSize: 50, tooltip: { trigger: 'item' }, label: { show: !0, position: 'inside' }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: !0 } } }, n }(TE)); var CE = { min: S(fx, 'min'), max: S(fx, 'max'), average: S(fx, 'average'), median: S(fx, 'median') }; const DE = qr(); const kE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.init = function () { this.markerGroupMap = Z() }, n.prototype.render = function (t, e, n) { const i = this; const r = this.markerGroupMap; r.each(function (t) { DE(t).keep = !1 }), e.eachSeries(function (t) { const r = TE.getMarkerModelFromSeries(t, i.type); r && i.renderSeries(t, r, e, n) }), r.each(function (t) { !DE(t).keep && i.group.remove(t.group) }) }, n.prototype.markKeep = function (t) { DE(t).keep = !0 }, n.prototype.toggleBlurSeries = function (t, e) { const n = this; y(t, function (t) { const i = TE.getMarkerModelFromSeries(t, n.type); if (i) { const r = i.getData(); r.eachItemGraphicEl(function (t) { t && (e ? Ra(t) : Na(t)) }) } }) }, n.type = 'marker', n }(YL)); var AE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.updateTransform = function (t, e, n) { e.eachSeries(function (t) { const e = TE.getMarkerModelFromSeries(t, 'markPoint'); e && (bx(e.getData(), t, n), this.markerGroupMap.get(t.id).updateLayout()) }, this) }, n.prototype.renderSeries = function (t, e, n, i) { const r = t.coordinateSystem; const o = t.id; const a = t.getData(); const s = this.markerGroupMap; const l = s.get(o) || s.set(o, new YN()); const u = Sx(r, t, e); e.setData(u), bx(e.getData(), t, i), u.each(function (t) { const n = u.getItemModel(t); let i = n.getShallow('symbol'); let r = n.getShallow('symbolSize'); let o = n.getShallow('symbolRotate'); let s = n.getShallow('symbolOffset'); const l = n.getShallow('symbolKeepAspect'); if (T(i) || T(r) || T(o) || T(s)) { const h = e.getRawValue(t); const c = e.getDataParams(t); T(i) && (i = i(h, c)), T(r) && (r = r(h, c)), T(o) && (o = o(h, c)), T(s) && (s = s(h, c)) } const p = n.getModel('itemStyle').getItemStyle(); const d = Cc(a, 'color'); p.fill || (p.fill = d), u.setItemVisual(t, { symbol: i, symbolSize: r, symbolRotate: o, symbolOffset: s, symbolKeepAspect: l, style: p }) }), l.updateData(u), this.group.add(l.group), u.eachItemGraphicEl(function (t) { t.traverse(function (t) { hD(t).dataModel = e }) }), this.markKeep(l), l.group.silent = e.get('silent') || t.get('silent') }, n.type = 'markPoint', n }(kE)); ff(Mx); var LE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.createMarkerModelFromSeries = function (t, e, i) { return new n(t, e, i) }, n.type = 'markLine', n.defaultOption = { z: 5, symbol: ['circle', 'arrow'], symbolSize: [8, 16], symbolOffset: 0, precision: 2, tooltip: { trigger: 'item' }, label: { show: !0, position: 'end', distance: 5 }, lineStyle: { type: 'dashed' }, emphasis: { label: { show: !0 }, lineStyle: { width: 3 } }, animationEasing: 'linear' }, n }(TE)); const PE = qr(); var OE = function (t, e, n, i) { let r; const o = t.getData(); if (M(i))r = i; else { const a = i.type; if (a === 'min' || a === 'max' || a === 'average' || a === 'median' || i.xAxis != null || i.yAxis != null) { let u = void 0; let c = void 0; if (i.yAxis != null || i.xAxis != null)u = e.getAxis(i.yAxis != null ? 'y' : 'x'), c = B(i.yAxis, i.xAxis); else { const p = yx(i, o, e, t); u = p.valueAxis; const d = pd(o, p.valueDataDim); c = xx(o, d, a) } const f = u.dim === 'x' ? 0 : 1; const g = 1 - f; const y = s(i); const v = { coord: [] }; y.type = null, y.coord = [], y.coord[g] = -1 / 0, v.coord[g] = 1 / 0; const m = n.get('precision'); m >= 0 && D(c) && (c = +c.toFixed(Math.min(m, 20))), y.coord[f] = v.coord[f] = c, r = [y, v, { type: a, valueIndex: i.valueIndex, value: c }] } else r = [] } const _ = [gx(t, r[0]), gx(t, r[1]), h({}, r[2])]; return _[2].type = _[2].type || null, l(_[2], _[0]), l(_[2], _[1]), _ }; var RE = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.updateTransform = function (t, e, n) { e.eachSeries(function (t) { const e = TE.getMarkerModelFromSeries(t, 'markLine'); if (e) { const i = e.getData(); const r = PE(e).from; const o = PE(e).to; r.each(function (e) { kx(r, e, !0, t, n), kx(o, e, !1, t, n) }), i.each(function (t) { i.setItemLayout(t, [r.getItemLayout(t), o.getItemLayout(t)]) }), this.markerGroupMap.get(t.id).updateLayout() } }, this) }, n.prototype.renderSeries = function (t, e, n, i) { function r (e, n, r) { const o = e.getItemModel(n); kx(e, n, r, t, i); const a = o.getModel('itemStyle').getItemStyle(); a.fill == null && (a.fill = Cc(s, 'color')), e.setItemVisual(n, { symbolKeepAspect: o.get('symbolKeepAspect'), symbolOffset: E(o.get('symbolOffset', !0), v[r ? 0 : 1]), symbolRotate: E(o.get('symbolRotate', !0), y[r ? 0 : 1]), symbolSize: E(o.get('symbolSize'), g[r ? 0 : 1]), symbol: E(o.get('symbol', !0), f[r ? 0 : 1]), style: a }) } const o = t.coordinateSystem; const a = t.id; var s = t.getData(); const l = this.markerGroupMap; const u = l.get(a) || l.set(a, new nB()); this.group.add(u.group); const h = Ax(o, t, e); const c = h.from; const p = h.to; const d = h.line; PE(e).from = c, PE(e).to = p, e.setData(d); var f = e.get('symbol'); var g = e.get('symbolSize'); var y = e.get('symbolRotate'); var v = e.get('symbolOffset'); M(f) || (f = [f, f]), M(g) || (g = [g, g]), M(y) || (y = [y, y]), M(v) || (v = [v, v]), h.from.each(function (t) { r(c, t, !0), r(p, t, !1) }), d.each(function (t) { const e = d.getItemModel(t).getModel('lineStyle').getLineStyle(); d.setItemLayout(t, [c.getItemLayout(t), p.getItemLayout(t)]), e.stroke == null && (e.stroke = c.getItemVisual(t, 'style').fill), d.setItemVisual(t, { fromSymbolKeepAspect: c.getItemVisual(t, 'symbolKeepAspect'), fromSymbolOffset: c.getItemVisual(t, 'symbolOffset'), fromSymbolRotate: c.getItemVisual(t, 'symbolRotate'), fromSymbolSize: c.getItemVisual(t, 'symbolSize'), fromSymbol: c.getItemVisual(t, 'symbol'), toSymbolKeepAspect: p.getItemVisual(t, 'symbolKeepAspect'), toSymbolOffset: p.getItemVisual(t, 'symbolOffset'), toSymbolRotate: p.getItemVisual(t, 'symbolRotate'), toSymbolSize: p.getItemVisual(t, 'symbolSize'), toSymbol: p.getItemVisual(t, 'symbol'), style: e }) }), u.updateData(d), h.line.eachItemGraphicEl(function (t) { hD(t).dataModel = e, t.traverse(function (t) { hD(t).dataModel = e }) }), this.markKeep(u), u.group.silent = e.get('silent') || t.get('silent') }, n.type = 'markLine', n }(kE)); ff(Lx); var NE = ['rect', 'polygon', 'keep', 'clear']; var zE = !0; var BE = Math.min; var EE = Math.max; var VE = Math.pow; var FE = 1e4; var HE = 6; var WE = 6; const GE = 'globalPan'; var XE = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] }; var YE = { w: 'ew', e: 'ew', n: 'ns', s: 'ns', ne: 'nesw', sw: 'nesw', nw: 'nwse', se: 'nwse' }; const UE = { brushStyle: { lineWidth: 2, stroke: 'rgba(210,219,238,0.3)', fill: '#D2DBEE' }, transformable: !0, brushMode: 'single', removeOnClick: !1 }; let ZE = 0; const jE = (function (t) { function n (e) { const n = t.call(this) || this; return n._track = [], n._covers = [], n._handlers = {}, n._zr = e, n.group = new CI(), n._uid = 'brushController_' + ZE++, y(qE, function (t, e) { this._handlers[e] = gM(t, this) }, n), n } return e(n, t), n.prototype.enableBrush = function (t) { return this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this }, n.prototype._doEnableBrush = function (t) { const e = this._zr; this._enableGlobalPan || _y(e, GE, this._uid), y(this._handlers, function (t, n) { e.on(n, t) }), this._brushType = t.brushType, this._brushOption = l(s(UE), t, !0) }, n.prototype._doDisableBrush = function () { const t = this._zr; xy(t, GE, this._uid), y(this._handlers, function (e, n) { t.off(n, e) }), this._brushType = this._brushOption = null }, n.prototype.setPanels = function (t) { if (t && t.length) { const e = this._panels = {}; y(t, function (t) { e[t.panelId] = s(t) }) } else this._panels = null; return this }, n.prototype.mount = function (t) { t = t || {}, this._enableGlobalPan = t.enableGlobalPan; const e = this.group; return this._zr.add(e), e.attr({ x: t.x || 0, y: t.y || 0, rotation: t.rotation || 0, scaleX: t.scaleX || 1, scaleY: t.scaleY || 1 }), this._transform = e.getLocalTransform(), this }, n.prototype.updateCovers = function (t) { function e (t, e) { return (t.id != null ? t.id : o + e) + '-' + t.brushType } function n (t, n) { return e(t.__brushOption, n) } function i (e, n) { const i = t[e]; if (n != null && a[n] === c)u[e] = a[n]; else { const r = u[e] = n != null ? (a[n].__brushOption = i, a[n]) : Nx(h, Rx(h, i)); Ex(h, r) } } function r (t) { a[t] !== c && h.group.remove(a[t]) }t = v(t, function (t) { return l(s(UE), t, !0) }); var o = '\x00-brush-index-'; var a = this._covers; var u = this._covers = []; var h = this; var c = this._creatingCover; return new pR(a, t, n, e).add(i).update(i).remove(r).execute(), this }, n.prototype.unmount = function () { return this.enableBrush(!1), Wx(this), this._zr.remove(this.group), this }, n.prototype.dispose = function () { this.unmount(), this.off() }, n }(kM)); var qE = { mousedown: function (t) { if (this._dragging)cw(this, t); else if (!t.target || !t.target.draggable) { sw(t); const e = this.group.transformCoordToLocal(t.offsetX, t.offsetY); this._creatingCover = null; const n = this._creatingPanel = Fx(this, t, e); n && (this._dragging = !0, this._track = [e.slice()]) } }, mousemove: function (t) { const e = t.offsetX; const n = t.offsetY; const i = this.group.transformCoordToLocal(e, n); if (aw(this, t, i), this._dragging) { sw(t); const r = uw(this, t, i, !1); r && Gx(this, r) } }, mouseup: function (t) { cw(this, t) } }; var KE = { lineX: dw(0), lineY: dw(1), rect: { createCover: function (t, e) { function n (t) { return t } return Ux({ toRectRange: n, fromRectRange: n }, t, e, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']]) }, getCreatingRange: function (t) { const e = Yx(t); return $x(e[1][0], e[1][1], e[0][0], e[0][1]) }, updateCoverShape: function (t, e, n, i) { Zx(t, e, n, i) }, updateCommon: jx, contain: lw }, polygon: { createCover: function (t, e) { const n = new CI(); return n.add(new hk({ name: 'main', style: Kx(e), silent: !0 })), n }, getCreatingRange: function (t) { return t }, endCreating: function (t, e) { e.remove(e.childAt(0)), e.add(new lk({ name: 'main', draggable: !0, drift: S(nw, t, e), ondragend: S(Gx, t, { isEnd: !0 }) })) }, updateCoverShape: function (t, e, n) { e.childAt(0).setShape({ points: rw(t, e, n) }) }, updateCommon: jx, contain: lw } }; var $E = y; const QE = k; var JE = -1; var tV = (function () { function t (e) { const n = e.mappingMethod; const i = e.type; const r = this.option = s(e); this.type = i, this.mappingMethod = n, this._normalizeData = eV[n]; const o = t.visualHandlers[i]; this.applyVisual = o.applyVisual, this.getColorMapper = o.getColorMapper, this._normalizedToVisual = o._normalizedToVisual[n], n === 'piecewise' ? (yw(r), fw(r)) : n === 'category' ? r.categories ? gw(r) : yw(r, !0) : (W(n !== 'linear' || r.dataExtent), yw(r)) } return t.prototype.mapValueToVisual = function (t) { const e = this._normalizeData(t); return this._normalizedToVisual(e, t) }, t.prototype.getNormalizer = function () { return gM(this._normalizeData, this) }, t.listVisualTypes = function () { return w(t.visualHandlers) }, t.isValidType = function (e) { return t.visualHandlers.hasOwnProperty(e) }, t.eachVisual = function (t, e, n) { k(t) ? y(t, e, n) : e.call(n, t) }, t.mapVisual = function (e, n, i) { let r; let o = M(e) ? [] : k(e) ? {} : (r = !0, null); return t.eachVisual(e, function (t, e) { const a = n.call(i, t, e); r ? o = a : o[e] = a }), o }, t.retrieveVisuals = function (e) { let n; const i = {}; return e && $E(t.visualHandlers, function (t, r) { e.hasOwnProperty(r) && (i[r] = e[r], n = !0) }), n ? i : null }, t.prepareVisualTypes = function (t) { if (M(t))t = t.slice(); else { if (!QE(t)) return []; const e = []; $E(t, function (t, n) { e.push(n) }), t = e } return t.sort(function (t, e) { return e === 'color' && t !== 'color' && t.indexOf('color') === 0 ? 1 : -1 }), t }, t.dependsOn = function (t, e) { return e === 'color' ? !(!t || t.indexOf(e) !== 0) : t === e }, t.findPieceIndex = function (t, e, n) { function i (e, n) { const i = Math.abs(e - t); o > i && (o = i, r = n) } for (var r, o = 1 / 0, a = 0, s = e.length; s > a; a++) { const l = e[a].value; if (l != null) { if (l === t || I(l) && l === t + '') return a; n && i(l, a) } } for (var a = 0, s = e.length; s > a; a++) { const u = e[a]; const h = u.interval; const c = u.close; if (h) { if (h[0] === -1 / 0) { if (Tw(c[1], t, h[1])) return a } else if (1 / 0 === h[1]) { if (Tw(c[0], h[0], t)) return a } else if (Tw(c[0], h[0], t) && Tw(c[1], t, h[1])) return a; n && i(h[0], a), n && i(h[1], a) } } return n ? 1 / 0 === t ? e.length - 1 : t === -1 / 0 ? 0 : r : void 0 }, t.visualHandlers = { color: { applyVisual: _w('color'), getColorMapper: function () { const t = this.option; return gM(t.mappingMethod === 'category' ? function (t, e) { return !e && (t = this._normalizeData(t)), xw.call(this, t) } : function (e, n, i) { const r = !!i; return !n && (e = this._normalizeData(e)), i = Hn(e, t.parsedVisual, i), r ? i : Yn(i, 'rgba') }, this) }, _normalizedToVisual: { linear: function (t) { return Yn(Hn(t, this.option.parsedVisual), 'rgba') }, category: xw, piecewise: function (t, e) { let n = Sw.call(this, e); return n == null && (n = Yn(Hn(t, this.option.parsedVisual), 'rgba')), n }, fixed: ww } }, colorHue: vw(function (t, e) { return Gn(t, e) }), colorSaturation: vw(function (t, e) { return Gn(t, null, e) }), colorLightness: vw(function (t, e) { return Gn(t, null, null, e) }), colorAlpha: vw(function (t, e) { return Xn(t, e) }), decal: { applyVisual: _w('decal'), _normalizedToVisual: { linear: null, category: xw, piecewise: null, fixed: null } }, opacity: { applyVisual: _w('opacity'), _normalizedToVisual: bw([0, 1]) }, liftZ: { applyVisual: _w('liftZ'), _normalizedToVisual: { linear: ww, category: ww, piecewise: ww, fixed: ww } }, symbol: { applyVisual: function (t, e, n) { const i = this.mapValueToVisual(t); n('symbol', i) }, _normalizedToVisual: { linear: mw, category: xw, piecewise: function (t, e) { let n = Sw.call(this, e); return n == null && (n = mw.call(this, t)), n }, fixed: ww } }, symbolSize: { applyVisual: _w('symbolSize'), _normalizedToVisual: bw([0, 1]) } }, t }()); var eV = { linear: function (t) { return rr(t, this.option.dataExtent, [0, 1], !0) }, piecewise: function (t) { const e = this.option.pieceList; const n = tV.findPieceIndex(t, e, !0); return n != null ? rr(n, [0, e.length - 1], [0, 1], !0) : void 0 }, category: function (t) { const e = this.option.categories ? this.option.categoryMap[t] : t; return e == null ? JE : e }, fixed: Q }; var nV = y; var iV = { lineX: Lw(0), lineY: Lw(1), rect: { point: function (t, e, n) { return t && n.boundingRect.contain(t[0], t[1]) }, rect: function (t, e, n) { return t && n.boundingRect.intersect(t) } }, polygon: { point: function (t, e, n) { return t && n.boundingRect.contain(t[0], t[1]) && yf(n.range, t[0], t[1]) }, rect: function (t, e, n) { const i = n.range; if (!t || i.length <= 1) return !1; const r = t.x; const o = t.y; const a = t.width; const s = t.height; const l = i[0]; return yf(i, r, o) || yf(i, r + a, o) || yf(i, r, o + s) || yf(i, r + a, o + s) || $M.create(t).contain(l[0], l[1]) || Qs(r, o, r + a, o, i) || Qs(r, o, r, o + s, i) || Qs(r + a, o, r + a, o + s, i) || Qs(r, o + s, r + a, o + s, i) ? !0 : void 0 } } }; var rV = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap']; var oV = (function () { function t (t, e, n) { const i = this; this._targetInfoList = []; const r = Ew(e, t); y(aV, function (t, e) { (!n || !n.include || p(n.include, e) >= 0) && t(r, i._targetInfoList) }) } return t.prototype.setOutputRanges = function (t, e) { return this.matchOutputRanges(t, e, function (t, e, n) { if ((t.coordRanges || (t.coordRanges = [])).push(e), !t.coordRange) { t.coordRange = e; const i = uV[t.brushType](0, n, e); t.__rangeOffset = { offset: hV[t.brushType](i.values, t.range, [1, 1]), xyMinMax: i.xyMinMax } } }), t }, t.prototype.matchOutputRanges = function (t, e, n) { y(t, function (t) { const i = this.findTargetInfo(t, e); i && i !== !0 && y(i.coordSyses, function (i) { const r = uV[t.brushType](1, i, t.range, !0); n(t, r.values, i, e) }) }, this) }, t.prototype.setInputRanges = function (t, e) { y(t, function (t) { const n = this.findTargetInfo(t, e); if (t.range = t.range || [], n && n !== !0) { t.panelId = n.panelId; const i = uV[t.brushType](0, n.coordSys, t.coordRange); const r = t.__rangeOffset; t.range = r ? hV[t.brushType](i.values, r.offset, Hw(i.xyMinMax, r.xyMinMax)) : i.values } }, this) }, t.prototype.makePanelOpts = function (t, e) { return v(this._targetInfoList, function (n) { const i = n.getPanelRect(); return { panelId: n.panelId, defaultBrushType: e ? e(n) : null, clipPath: Ow(i), isTargetByCursor: Nw(i, t, n.coordSysModel), getLinearBrushOtherExtent: Rw(i) } }) }, t.prototype.controlSeries = function (t, e, n) { const i = this.findTargetInfo(t, n); return i === !0 || i && p(i.coordSyses, e.coordinateSystem) >= 0 }, t.prototype.findTargetInfo = function (t, e) { for (let n = this._targetInfoList, i = Ew(e, t), r = 0; r < n.length; r++) { const o = n[r]; const a = t.panelId; if (a) { if (o.panelId === a) return o } else for (let s = 0; s < sV.length; s++) if (sV[s](i, o)) return o } return !0 }, t }()); var aV = { grid: function (t, e) { const n = t.xAxisModels; const i = t.yAxisModels; const r = t.gridModels; const o = Z(); const a = {}; const s = {}; (n || i || r) && (y(n, function (t) { const e = t.axis.grid.model; o.set(e.id, e), a[e.id] = !0 }), y(i, function (t) { const e = t.axis.grid.model; o.set(e.id, e), s[e.id] = !0 }), y(r, function (t) { o.set(t.id, t), a[t.id] = !0, s[t.id] = !0 }), o.each(function (t) { const r = t.coordinateSystem; const o = []; y(r.getCartesians(), function (t) { (p(n, t.getAxis('x').model) >= 0 || p(i, t.getAxis('y').model) >= 0) && o.push(t) }), e.push({ panelId: 'grid--' + t.id, gridModel: t, coordSysModel: t, coordSys: o[0], coordSyses: o, getPanelRect: lV.grid, xAxisDeclared: a[t.id], yAxisDeclared: s[t.id] }) })) }, geo: function (t, e) { y(t.geoModels, function (t) { const n = t.coordinateSystem; e.push({ panelId: 'geo--' + t.id, geoModel: t, coordSysModel: t, coordSys: n, coordSyses: [n], getPanelRect: lV.geo }) }) } }; var sV = [function (t, e) { const n = t.xAxisModel; const i = t.yAxisModel; let r = t.gridModel; return !r && n && (r = n.axis.grid.model), !r && i && (r = i.axis.grid.model), r && r === e.gridModel }, function (t, e) { const n = t.geoModel; return n && n === e.geoModel }]; var lV = { grid: function () { return this.coordSys.master.getRect().clone() }, geo: function () { const t = this.coordSys; const e = t.getBoundingRect().clone(); return e.applyTransform(Gs(t)), e } }; var uV = { lineX: S(Vw, 0), lineY: S(Vw, 1), rect: function (t, e, n, i) { const r = t ? e.pointToData([n[0][0], n[1][0]], i) : e.dataToPoint([n[0][0], n[1][0]], i); const o = t ? e.pointToData([n[0][1], n[1][1]], i) : e.dataToPoint([n[0][1], n[1][1]], i); const a = [Bw([r[0], o[0]]), Bw([r[1], o[1]])]; return { values: a, xyMinMax: a } }, polygon: function (t, e, n, i) { const r = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]]; const o = v(n, function (n) { const o = t ? e.pointToData(n, i) : e.dataToPoint(n, i); return r[0][0] = Math.min(r[0][0], o[0]), r[1][0] = Math.min(r[1][0], o[1]), r[0][1] = Math.max(r[0][1], o[0]), r[1][1] = Math.max(r[1][1], o[1]), o }); return { values: o, xyMinMax: r } } }; var hV = { lineX: S(Fw, 0), lineY: S(Fw, 1), rect: function (t, e, n) { return [[t[0][0] - n[0] * e[0][0], t[0][1] - n[0] * e[0][1]], [t[1][0] - n[1] * e[1][0], t[1][1] - n[1] * e[1][1]]] }, polygon: function (t, e, n) { return v(t, function (t, i) { return [t[0] - n[0] * e[i][0], t[1] - n[1] * e[i][1]] }) } }; var cV = ['inBrush', 'outOfBrush']; var pV = '__ecBrushSelect'; var dV = '__ecInBrushSelectEvent'; var fV = { rect: function (t) { return qw(t.range) }, polygon: function (t) { for (var e, n = t.range, i = 0, r = n.length; r > i; i++) { e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]]; const o = n[i]; o[0] < e[0][0] && (e[0][0] = o[0]), o[0] > e[0][1] && (e[0][1] = o[0]), o[1] < e[1][0] && (e[1][0] = o[1]), o[1] > e[1][1] && (e[1][1] = o[1]) } return e && qw(e) } }; var gV = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.init = function (t, e) { this.ecModel = t, this.api = e, this.model, (this._brushController = new jE(e.getZr())).on('brush', gM(this._onBrush, this)).mount() }, n.prototype.render = function (t, e, n, i) { this.model = t, this._updateController(t, e, n, i) }, n.prototype.updateTransform = function (t, e, n, i) { Gw(e), this._updateController(t, e, n, i) }, n.prototype.updateVisual = function (t, e, n, i) { this.updateTransform(t, e, n, i) }, n.prototype.updateView = function (t, e, n, i) { this._updateController(t, e, n, i) }, n.prototype._updateController = function (t, e, n, i) { (!i || i.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(n)).enableBrush(t.brushOption).updateCovers(t.areas.slice()) }, n.prototype.dispose = function () { this._brushController.dispose() }, n.prototype._onBrush = function (t) { const e = this.model.id; const n = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel); (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({ type: 'brush', brushId: e, areas: s(n), $from: e }), t.isEnd && this.api.dispatchAction({ type: 'brushEnd', brushId: e, areas: s(n), $from: e }) }, n.type = 'brush', n }(YL)); const yV = '#ddd'; var vV = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.areas = [], e.brushOption = {}, e } return e(n, t), n.prototype.optionUpdated = function (t, e) { const n = this.option; !e && Dw(n, t, ['inBrush', 'outOfBrush']); const i = n.inBrush = n.inBrush || {}; n.outOfBrush = n.outOfBrush || { color: yV }, i.hasOwnProperty('liftZ') || (i.liftZ = 5) }, n.prototype.setAreas = function (t) { t && (this.areas = v(t, function (t) { return Kw(this.option, t) }, this)) }, n.prototype.setBrushOption = function (t) { this.brushOption = Kw(this.option, t), this.brushType = this.brushOption.brushType }, n.type = 'brush', n.dependencies = ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'], n.defaultOption = { seriesIndex: 'all', brushType: 'rect', brushMode: 'single', transformable: !0, brushStyle: { borderWidth: 1, color: 'rgba(210,219,238,0.3)', borderColor: '#D2DBEE' }, throttleType: 'fixRate', throttleDelay: 0, removeOnClick: !0, z: 1e4 }, n }(CA)); const mV = (function () { function t () {} return t }()); var _V = {}; const xV = ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear']; var wV = (function (t) {
    function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.render = function (t, e) { let n, i, r; e.eachComponent({ mainType: 'brush' }, function (t) { n = t.brushType, i = t.brushOption.brushMode || 'single', r = r || !!t.areas.length }), this._brushType = n, this._brushMode = i, y(t.get('type', !0), function (e) { t.setIconStatus(e, (e === 'keep' ? i === 'multiple' : e === 'clear' ? r : e === n) ? 'emphasis' : 'normal') }) }, n.prototype.updateView = function (t, e, n) { this.render(t, e, n) }, n.prototype.getIcons = function () { const t = this.model; const e = t.get('icon', !0); const n = {}; return y(t.get('type', !0), function (t) { e[t] && (n[t] = e[t]) }), n }, n.prototype.onclick = function (t, e, n) { const i = this._brushType; const r = this._brushMode; n === 'clear' ? (e.dispatchAction({ type: 'axisAreaSelect', intervals: [] }), e.dispatchAction({ type: 'brush', command: 'clear', areas: [] })) : e.dispatchAction({ type: 'takeGlobalCursor', key: 'brush', brushOption: { brushType: n === 'keep' ? i : i === n ? !1 : n, brushMode: n === 'keep' ? r === 'multiple' ? 'single' : 'multiple' : r } }) }, n.getDefaultOption = function (t) {
      const e = { show: !0, type: xV.slice(), icon: { rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13', polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2', lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4', lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4', keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z', clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2' }, title: t.getLocaleModel().get(['toolbox', 'brush', 'title']) }
      return e
    }, n
  }(mV)); ff(Jw); const bV = ['x', 'y', 'radius', 'angle', 'single']; var SV = ['cartesian2d', 'polar', 'singleAxis']; const MV = (function () { function t () { this.indexList = [], this.indexMap = [] } return t.prototype.add = function (t) { this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = !0) }, t }()); const TV = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e._autoThrottle = !0, e._noTarget = !0, e._rangePropMode = ['percent', 'percent'], e } return e(n, t), n.prototype.init = function (t, e, n) { const i = ib(t); this.settledOption = i, this.mergeDefaultAndTheme(t, n), this._doInit(i) }, n.prototype.mergeOption = function (t) { const e = ib(t); l(this.option, t, !0), l(this.settledOption, e, !0), this._doInit(e) }, n.prototype._doInit = function (t) { const e = this.option; this._setDefaultThrottle(t), this._updateRangeUse(t); const n = this.settledOption; y([['start', 'startValue'], ['end', 'endValue']], function (t, i) { this._rangePropMode[i] === 'value' && (e[t[0]] = n[t[0]] = null) }, this), this._resetTarget() }, n.prototype._resetTarget = function () { const t = this.get('orient', !0); const e = this._targetAxisInfoMap = Z(); const n = this._fillSpecifiedTargetAxis(e); n ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || 'horizontal', this._fillAutoTargetAxisByOrient(e, this._orient)), this._noTarget = !0, e.each(function (t) { t.indexList.length && (this._noTarget = !1) }, this) }, n.prototype._fillSpecifiedTargetAxis = function (t) { let e = !1; return y(bV, function (n) { const i = this.getReferringComponents(eb(n), WI); if (i.specified) { e = !0; const r = new MV(); y(i.models, function (t) { r.add(t.componentIndex) }), t.set(n, r) } }, this), e }, n.prototype._fillAutoTargetAxisByOrient = function (t, e) { function n (e, n) { const i = e[0]; if (i) { const o = new MV(); if (o.add(i.componentIndex), t.set(n, o), r = !1, n === 'x' || n === 'y') { const a = i.getReferringComponents('grid', HI).models[0]; a && y(e, function (t) { i.componentIndex !== t.componentIndex && a === t.getReferringComponents('grid', HI).models[0] && o.add(t.componentIndex) }) } } } const i = this.ecModel; var r = !0; if (r) { const o = e === 'vertical' ? 'y' : 'x'; var a = i.findComponents({ mainType: o + 'Axis' }); n(a, o) } if (r) { var a = i.findComponents({ mainType: 'singleAxis', filter: function (t) { return t.get('orient', !0) === e } }); n(a, 'single') }r && y(bV, function (e) { if (r) { const n = i.findComponents({ mainType: eb(e), filter: function (t) { return t.get('type', !0) === 'category' } }); if (n[0]) { const o = new MV(); o.add(n[0].componentIndex), t.set(e, o), r = !1 } } }, this) }, n.prototype._makeAutoOrientByTargetAxis = function () { let t; return this.eachTargetAxis(function (e) { !t && (t = e) }, this), t === 'y' ? 'vertical' : 'horizontal' }, n.prototype._setDefaultThrottle = function (t) { if (t.hasOwnProperty('throttle') && (this._autoThrottle = !1), this._autoThrottle) { const e = this.ecModel.option; this.option.throttle = e.animation && e.animationDurationUpdate > 0 ? 100 : 20 } }, n.prototype._updateRangeUse = function (t) { const e = this._rangePropMode; const n = this.get('rangeMode'); y([['start', 'startValue'], ['end', 'endValue']], function (i, r) { const o = t[i[0]] != null; const a = t[i[1]] != null; o && !a ? e[r] = 'percent' : !o && a ? e[r] = 'value' : n ? e[r] = n[r] : o && (e[r] = 'percent') }) }, n.prototype.noTarget = function () { return this._noTarget }, n.prototype.getFirstTargetAxisModel = function () { let t; return this.eachTargetAxis(function (e, n) { t == null && (t = this.ecModel.getComponent(eb(e), n)) }, this), t }, n.prototype.eachTargetAxis = function (t, e) { this._targetAxisInfoMap.each(function (n, i) { y(n.indexList, function (n) { t.call(e, i, n) }) }) }, n.prototype.getAxisProxy = function (t, e) { const n = this.getAxisModel(t, e); return n ? n.__dzAxisProxy : void 0 }, n.prototype.getAxisModel = function (t, e) { const n = this._targetAxisInfoMap.get(t); return n && n.indexMap[e] ? this.ecModel.getComponent(eb(t), e) : void 0 }, n.prototype.setRawRange = function (t) { const e = this.option; const n = this.settledOption; y([['start', 'startValue'], ['end', 'endValue']], function (i) { (t[i[0]] != null || t[i[1]] != null) && (e[i[0]] = n[i[0]] = t[i[0]], e[i[1]] = n[i[1]] = t[i[1]]) }, this), this._updateRangeUse(t) }, n.prototype.setCalculatedRange = function (t) { const e = this.option; y(['start', 'startValue', 'end', 'endValue'], function (n) { e[n] = t[n] }) }, n.prototype.getPercentRange = function () { const t = this.findRepresentativeAxisProxy(); return t ? t.getDataPercentWindow() : void 0 }, n.prototype.getValueRange = function (t, e) { if (t != null || e != null) return this.getAxisProxy(t, e).getDataValueWindow(); const n = this.findRepresentativeAxisProxy(); return n ? n.getDataValueWindow() : void 0 }, n.prototype.findRepresentativeAxisProxy = function (t) { if (t) return t.__dzAxisProxy; for (var e, n = this._targetAxisInfoMap.keys(), i = 0; i < n.length; i++) for (let r = n[i], o = this._targetAxisInfoMap.get(r), a = 0; a < o.indexList.length; a++) { const s = this.getAxisProxy(r, o.indexList[a]); if (s.hostedBy(this)) return s; e || (e = s) } return e }, n.prototype.getRangePropMode = function () { return this._rangePropMode.slice() }, n.prototype.getOrient = function () { return this._orient }, n.type = 'dataZoom', n.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox'], n.defaultOption = { z: 4, filterMode: 'filter', start: 0, end: 100 }, n }(CA)); var IV = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.type = 'dataZoom.select', n }(TV)); const CV = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.render = function (t, e, n) { this.dataZoomModel = t, this.ecModel = e, this.api = n }, n.type = 'dataZoom', n }(YL)); var DV = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.type = 'dataZoom.select', n }(CV)); var kV = y; const AV = sr; const LV = (function () { function t (t, e, n, i) { this._dimName = t, this._axisIndex = e, this.ecModel = i, this._dataZoomModel = n } return t.prototype.hostedBy = function (t) { return this._dataZoomModel === t }, t.prototype.getDataValueWindow = function () { return this._valueWindow.slice() }, t.prototype.getDataPercentWindow = function () { return this._percentWindow.slice() }, t.prototype.getTargetSeriesModels = function () { const t = []; return this.ecModel.eachSeries(function (e) { if (tb(e)) { const n = eb(this._dimName); const i = e.getReferringComponents(n, HI).models[0]; i && this._axisIndex === i.componentIndex && t.push(e) } }, this), t }, t.prototype.getAxisModel = function () { return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex) }, t.prototype.getMinMaxSpan = function () { return s(this._minMaxSpan) }, t.prototype.calculateDataWindow = function (t) { function e (t, e, n, i, r) { const a = r ? 'Span' : 'ValueSpan'; rb(0, t, n, 'all', h['min' + a], h['max' + a]); for (let s = 0; s < 2; s++)e[s] = rr(t[s], n, i, !0), r && (e[s] = o.parse(e[s])) } let n; const i = this._dataExtent; const r = this.getAxisModel(); var o = r.axis.scale; const a = this._dataZoomModel.getRangePropMode(); const s = [0, 100]; const l = []; const u = []; kV(['start', 'end'], function (e, r) { let h = t[e]; let c = t[e + 'Value']; a[r] === 'percent' ? (h == null && (h = s[r]), c = o.parse(rr(h, s, i))) : (n = !0, c = c == null ? i[r] : o.parse(c), h = rr(c, i, s)), u[r] = c == null || isNaN(c) ? i[r] : c, l[r] = h == null || isNaN(h) ? s[r] : h }), AV(u), AV(l); var h = this._minMaxSpan; return n ? e(u, l, i, s, !1) : e(l, u, s, i, !0), { valueWindow: u, percentWindow: l } }, t.prototype.reset = function (t) { if (t === this._dataZoomModel) { const e = this.getTargetSeriesModels(); this._dataExtent = sb(this, this._dimName, e), this._updateMinMaxSpan(); const n = this.calculateDataWindow(t.settledOption); this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, this._setAxisModel() } }, t.prototype.filterData = function (t) { function e (t) { return t >= o[0] && t <= o[1] } if (t === this._dataZoomModel) { const n = this._dimName; const i = this.getTargetSeriesModels(); const r = t.get('filterMode'); var o = this._valueWindow; r !== 'none' && kV(i, function (t) { let i = t.getData(); const a = i.mapDimensionsAll(n); if (a.length) { if (r === 'weakFilter') { const s = i.getStore(); const l = v(a, function (t) { return i.getDimensionIndex(t) }, i); i.filterSelf(function (t) { for (var e, n, i, r = 0; r < a.length; r++) { const u = s.get(l[r], t); const h = !isNaN(u); const c = u < o[0]; const p = u > o[1]; if (h && !c && !p) return !0; h && (i = !0), c && (e = !0), p && (n = !0) } return i && e && n }) } else kV(a, function (n) { if (r === 'empty')t.setData(i = i.map(n, function (t) { return e(t) ? t : 0 / 0 })); else { const a = {}; a[n] = o, i.selectRange(a) } }); kV(a, function (t) { i.setApproximateExtent(o, t) }) } }) } }, t.prototype._updateMinMaxSpan = function () { const t = this._minMaxSpan = {}; const e = this._dataZoomModel; const n = this._dataExtent; kV(['min', 'max'], function (i) { let r = e.get(i + 'Span'); let o = e.get(i + 'ValueSpan'); o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? r = rr(n[0] + o, n, [0, 100], !0) : r != null && (o = rr(r, [0, 100], n, !0) - n[0]), t[i + 'Span'] = r, t[i + 'ValueSpan'] = o }, this) }, t.prototype._setAxisModel = function () { const t = this.getAxisModel(); const e = this._percentWindow; const n = this._valueWindow; if (e) { let i = hr(n, [0, 500]); i = Math.min(i, 20); const r = t.axis.scale.rawExtentInfo; e[0] !== 0 && r.setDeterminedMinMax('min', +n[0].toFixed(i)), e[1] !== 100 && r.setDeterminedMinMax('max', +n[1].toFixed(i)), r.freeze() } }, t }()); var PV = { getTargetSeries: function (t) { function e (e) { t.eachComponent('dataZoom', function (n) { n.eachTargetAxis(function (i, r) { const o = t.getComponent(eb(i), r); e(i, r, o, n) }) }) }e(function (t, e, n) { n.__dzAxisProxy = null }); const n = []; e(function (e, i, r, o) { r.__dzAxisProxy || (r.__dzAxisProxy = new LV(e, i, o, t), n.push(r.__dzAxisProxy)) }); const i = Z(); return y(n, function (t) { y(t.getTargetSeriesModels(), function (t) { i.set(t.uid, t) }) }), i }, overallReset: function (t, e) { t.eachComponent('dataZoom', function (t) { t.eachTargetAxis(function (e, n) { t.getAxisProxy(e, n).reset(t) }), t.eachTargetAxis(function (n, i) { t.getAxisProxy(n, i).filterData(t, e) }) }), t.eachComponent('dataZoom', function (t) { const e = t.findRepresentativeAxisProxy(); if (e) { const n = e.getDataPercentWindow(); const i = e.getDataValueWindow(); t.setCalculatedRange({ start: n[0], end: n[1], startValue: i[0], endValue: i[1] }) } }) } }; var OV = !1; var RV = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.optionUpdated = function () { t.prototype.optionUpdated.apply(this, arguments); const e = this.ecModel; y(this.option.feature, function (t, n) { const i = Qw(n); i && (i.getDefaultOption && (i.defaultOption = i.getDefaultOption(e)), l(t, i.defaultOption)) }) }, n.type = 'toolbox', n.layoutMode = { type: 'box', ignoreSize: !0 }, n.defaultOption = { show: !0, z: 6, orient: 'horizontal', left: 'right', top: 'top', backgroundColor: 'transparent', borderColor: '#ccc', borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: !0, iconStyle: { borderColor: '#666', color: 'none' }, emphasis: { iconStyle: { borderColor: '#3E98C5' } }, tooltip: { show: !1, position: 'bottom' } }, n }(CA)); var NV = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.render = function (t, e, n, i) { function r (r, a) { let s; const l = c[r]; const p = c[a]; const d = u[l]; const f = new Jk(d, t, t.ecModel); if (i && i.newTitle != null && i.featureName === l && (d.title = i.newTitle), l && !p) { if (cb(l))s = { onclick: f.option.onclick, featureName: l }; else { const g = Qw(l); if (!g) return; s = new g() }h[l] = s } else if (s = h[p], !s) return; s.uid = yl('toolbox-feature'), s.model = f, s.ecModel = e, s.api = n; const y = s instanceof mV; return !l && p ? void (y && s.dispose && s.dispose(e, n)) : !f.get('show') || y && s.unusable ? void (y && s.remove && s.remove(e, n)) : (o(f, s, l), f.setIconStatus = function (t, e) { const n = this.option; const i = this.iconPaths; n.iconStatus = n.iconStatus || {}, n.iconStatus[t] = e, i[t] && (e === 'emphasis' ? Pa : Oa)(i[t]) }, void (s instanceof mV && s.render && s.render(f, e, n, i))) } function o (i, r, o) { let u; let h; const c = i.getModel('iconStyle'); const p = i.getModel(['emphasis', 'iconStyle']); const d = r instanceof mV && r.getIcons ? r.getIcons() : i.get('icon'); const f = i.get('title') || {}; I(d) ? (u = {}, u[o] = d) : u = d, I(f) ? (h = {}, h[o] = f) : h = f; const g = i.iconPaths = {}; y(u, function (o, u) { const d = $s(o, {}, { x: -s / 2, y: -s / 2, width: s, height: s }); d.setStyle(c.getItemStyle()); const f = d.ensureState('emphasis'); f.style = p.getItemStyle(); const y = new aD({ style: { text: h[u], align: p.get('textAlign'), borderRadius: p.get('textBorderRadius'), padding: p.get('textPadding'), fill: null }, ignore: !0 }); d.setTextContent(y), nl({ el: d, componentModel: t, itemName: u, formatterParamsExtra: { title: h[u] } }), d.__title = h[u], d.on('mouseover', function () { const e = p.getItemStyle(); const i = l ? t.get('right') == null && t.get('left') !== 'right' ? 'right' : 'left' : t.get('bottom') == null && t.get('top') !== 'bottom' ? 'bottom' : 'top'; y.setStyle({ fill: p.get('textFill') || e.fill || e.stroke || '#000', backgroundColor: p.get('textBackgroundColor') }), d.setTextConfig({ position: p.get('textPosition') || i }), y.ignore = !t.get('showTitle'), n.enterEmphasis(this) }).on('mouseout', function () { i.get(['iconStatus', u]) !== 'emphasis' && n.leaveEmphasis(this), y.hide() }), (i.get(['iconStatus', u]) === 'emphasis' ? Pa : Oa)(d), a.add(d), d.on('click', gM(r.onclick, r, e, n, u)), g[u] = d }) } var a = this.group; if (a.removeAll(), t.get('show')) { var s = +t.get('itemSize'); var l = t.get('orient') === 'vertical'; var u = t.get('feature') || {}; var h = this._features || (this._features = {}); var c = []; y(u, function (t, e) { c.push(e) }), new pR(this._featureNames || [], c).add(r).update(r).remove(S(r, null)).execute(), this._featureNames = c, Um(a, t, n), a.add(Zm(a.getBoundingRect(), t)), l || a.eachChild(function (t) { const e = t.__title; const i = t.ensureState('emphasis'); const r = i.textConfig || (i.textConfig = {}); const o = t.getTextContent(); const l = o && o.ensureState('emphasis'); if (l && !T(l) && e) { const u = l.style || (l.style = {}); const h = Bi(e, aD.makeFont(u)); const c = t.x + a.x; const p = t.y + a.y + s; let d = !1; p + h.height > n.getHeight() && (r.position = 'top', d = !0); const f = d ? -5 - h.height : s + 10; c + h.width / 2 > n.getWidth() ? (r.position = ['100%', f], u.align = 'right') : c - h.width / 2 < 0 && (r.position = [0, f], u.align = 'left') } }) } }, n.prototype.updateView = function (t, e, n, i) { y(this._features, function (t) { t instanceof mV && t.updateView && t.updateView(t.model, e, n, i) }) }, n.prototype.remove = function (t, e) { y(this._features, function (n) { n instanceof mV && n.remove && n.remove(t, e) }), this.group.removeAll() }, n.prototype.dispose = function (t, e) { y(this._features, function (n) { n instanceof mV && n.dispose && n.dispose(t, e) }) }, n.type = 'toolbox', n }(YL)); var zV = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.onclick = function (t, e) { const n = this.model; const i = n.get('name') || t.get('title.0.text') || 'echarts'; const r = e.getZr().painter.getType() === 'svg'; const o = r ? 'svg' : n.get('type', !0) || 'png'; const a = e.getConnectedDataURL({ type: o, backgroundColor: n.get('backgroundColor', !0) || t.get('backgroundColor') || '#fff', connectedBackgroundColor: n.get('connectedBackgroundColor'), excludeComponents: n.get('excludeComponents'), pixelRatio: n.get('pixelRatio') }); const s = ZS.browser; if (T(MouseEvent) && (s.newEdge || !s.ie && !s.edge)) { const l = document.createElement('a'); l.download = i + '.' + o, l.target = '_blank', l.href = a; const u = new MouseEvent('click', { view: document.defaultView, bubbles: !0, cancelable: !1 }); l.dispatchEvent(u) } else if (window.navigator.msSaveOrOpenBlob || r) { const h = a.split(','); const c = h[0].indexOf('base64') > -1; let p = r ? decodeURIComponent(h[1]) : h[1]; c && (p = window.atob(p)); const d = i + '.' + o; if (window.navigator.msSaveOrOpenBlob) { for (var f = p.length, g = new Uint8Array(f); f--;)g[f] = p.charCodeAt(f); const y = new Blob([g]); window.navigator.msSaveOrOpenBlob(y, d) } else { const v = document.createElement('iframe'); document.body.appendChild(v); const m = v.contentWindow; const _ = m.document; _.open('image/svg+xml', 'replace'), _.write(p), _.close(), m.focus(), _.execCommand('SaveAs', !0, d), document.body.removeChild(v) } } else { const x = n.get('lang'); const w = '<body style="margin:0;"><img src="' + a + '" style="max-width:100%;" title="' + (x && x[0] || '') + '" /></body>'; const b = window.open(); b.document.write(w), b.document.title = i } }, n.getDefaultOption = function (t) { const e = { show: !0, icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0', title: t.getLocaleModel().get(['toolbox', 'saveAsImage', 'title']), type: 'png', connectedBackgroundColor: '#fff', name: '', excludeComponents: ['toolbox'], lang: t.getLocaleModel().get(['toolbox', 'saveAsImage', 'lang']) }; return e }, n }(mV)); const BV = '__ec_magicType_stack__'; const EV = [['line', 'bar'], ['stack']]; var VV = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.getIcons = function () { const t = this.model; const e = t.get('icon'); const n = {}; return y(t.get('type'), function (t) { e[t] && (n[t] = e[t]) }), n }, n.getDefaultOption = function (t) { const e = { show: !0, type: [], icon: { line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4', bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7', stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z' }, title: t.getLocaleModel().get(['toolbox', 'magicType', 'title']), option: {}, seriesIndex: {} }; return e }, n.prototype.onclick = function (t, e, n) { const i = this.model; const r = i.get(['seriesIndex', n]); if (FV[n]) { const o = { series: [] }; const a = function (t) { const e = t.subType; const r = t.id; const a = FV[n](e, r, t, i); a && (c(a, t.option), o.series.push(a)); const s = t.coordinateSystem; if (s && s.type === 'cartesian2d' && (n === 'line' || n === 'bar')) { const l = s.getAxesByScale('ordinal')[0]; if (l) { const u = l.dim; const h = u + 'Axis'; const p = t.getReferringComponents(h, HI).models[0]; const d = p.componentIndex; o[h] = o[h] || []; for (let f = 0; d >= f; f++)o[h][d] = o[h][d] || {}; o[h][d].boundaryGap = n === 'bar' } } }; y(EV, function (t) { p(t, n) >= 0 && y(t, function (t) { i.setIconStatus(t, 'normal') }) }), i.setIconStatus(n, 'emphasis'), t.eachComponent({ mainType: 'series', query: r == null ? null : { seriesIndex: r } }, a); let s; let u = n; n === 'stack' && (s = l({ stack: i.option.title.tiled, tiled: i.option.title.stack }, i.option.title), i.get(['iconStatus', n]) !== 'emphasis' && (u = 'tiled')), e.dispatchAction({ type: 'changeMagicType', currentType: u, newOption: o, newTitle: s, featureName: 'magicType' }) } }, n }(mV)); var FV = { line: function (t, e, n, i) { return t === 'bar' ? l({ id: e, type: 'line', data: n.get('data'), stack: n.get('stack'), markPoint: n.get('markPoint'), markLine: n.get('markLine') }, i.get(['option', 'line']) || {}, !0) : void 0 }, bar: function (t, e, n, i) { return t === 'line' ? l({ id: e, type: 'bar', data: n.get('data'), stack: n.get('stack'), markPoint: n.get('markPoint'), markLine: n.get('markLine') }, i.get(['option', 'bar']) || {}, !0) : void 0 }, stack: function (t, e, n, i) { const r = n.get('stack') === BV; return t === 'line' || t === 'bar' ? (i.setIconStatus('stack', r ? 'normal' : 'emphasis'), l({ id: e, stack: r ? '' : BV }, i.get(['option', 'stack']) || {}, !0)) : void 0 } }; zp({ type: 'changeMagicType', event: 'magicTypeChanged', update: 'prepareAndUpdate' }, function (t, e) { e.mergeOption(t.newOption) }); var HV = new Array(60).join('-'); var WV = '    '; var GV = new RegExp('[' + WV + ']+', 'g'); var XV = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.onclick = function (t, e) { function n () { i.removeChild(o), x._dom = null }setTimeout(function () { e.dispatchAction({ type: 'hideTip' }) }); var i = e.getDom(); const r = this.model; this._dom && i.removeChild(this._dom); var o = document.createElement('div'); o.style.cssText = 'position:absolute;top:0;bottom:0;left:0;right:0;padding:5px', o.style.backgroundColor = r.get('backgroundColor') || '#fff'; const a = document.createElement('h4'); const s = r.get('lang') || []; a.innerHTML = s[0] || r.get('title'), a.style.cssText = 'margin:10px 20px', a.style.color = r.get('textColor'); const l = document.createElement('div'); const u = document.createElement('textarea'); l.style.cssText = 'overflow:auto'; const h = r.get('optionToContent'); const c = r.get('contentToOption'); const p = gb(t); if (T(h)) { const d = h(e.getOption()); I(d) ? l.innerHTML = d : P(d) && l.appendChild(d) } else { u.readOnly = r.get('readOnly'); const f = u.style; f.cssText = 'display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none', f.color = r.get('textColor'), f.borderColor = r.get('textareaBorderColor'), f.backgroundColor = r.get('textareaColor'), u.value = p.value, l.appendChild(u) } const g = p.meta; const y = document.createElement('div'); y.style.cssText = 'position:absolute;bottom:5px;left:0;right:0'; let v = 'float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px'; const m = document.createElement('div'); const _ = document.createElement('div'); v += ';background-color:' + r.get('buttonColor'), v += ';color:' + r.get('buttonTextColor'); var x = this; Oe(m, 'click', n), Oe(_, 'click', function () { if (c == null && h != null || c != null && h == null) return void n(); let t; try { t = T(c) ? c(l, e.getOption()) : xb(u.value, g) } catch (i) { throw n(), new Error('Data view format error ' + i) }t && e.dispatchAction({ type: 'changeDataView', newOption: t }), n() }), m.innerHTML = s[1], _.innerHTML = s[2], _.style.cssText = m.style.cssText = v, !r.get('readOnly') && y.appendChild(_), y.appendChild(m), o.appendChild(a), o.appendChild(l), o.appendChild(y), l.style.height = i.clientHeight - 80 + 'px', i.appendChild(o), this._dom = o }, n.prototype.remove = function (t, e) { this._dom && e.getDom().removeChild(this._dom) }, n.prototype.dispose = function (t, e) { this.remove(t, e) }, n.getDefaultOption = function (t) { const e = { show: !0, readOnly: !1, optionToContent: null, contentToOption: null, icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28', title: t.getLocaleModel().get(['toolbox', 'dataView', 'title']), lang: t.getLocaleModel().get(['toolbox', 'dataView', 'lang']), backgroundColor: '#fff', textColor: '#000', textareaColor: '#fff', textareaBorderColor: '#333', buttonColor: '#c23531', buttonTextColor: '#fff' }; return e }, n }(mV)); zp({ type: 'changeDataView', event: 'dataViewChanged', update: 'prepareAndUpdate' }, function (t, e) { const n = []; y(t.newOption.series, function (t) { const i = e.getSeriesByName(t.name)[0]; if (i) { const r = i.get('data'); n.push({ name: t.name, data: wb(t.data, r) }) } else n.push(h({ type: 'scatter' }, t)) }), e.mergeOption(c({ series: n }, t.newOption)) }); var YV = y; var UV = qr(); var ZV = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.onclick = function (t, e) { Mb(t), e.dispatchAction({ type: 'restore', from: this.uid }) }, n.getDefaultOption = function (t) { const e = { show: !0, icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5', title: t.getLocaleModel().get(['toolbox', 'restore', 'title']) }; return e }, n }(mV)); zp({ type: 'restore', event: 'restore', update: 'prepareAndUpdate' }, function (t, e) { e.resetOption('recreate') }); const jV = y; const qV = Yr('toolbox-dataZoom_'); var KV = (function (t) { function n () { return t !== null && t.apply(this, arguments) || this } return e(n, t), n.prototype.render = function (t, e, n, i) { this._brushController || (this._brushController = new jE(n.getZr()), this._brushController.on('brush', gM(this._onBrush, this)).mount()), kb(t, e, this, i, n), Db(t, e) }, n.prototype.onclick = function (t, e, n) { $V[n].call(this) }, n.prototype.remove = function () { this._brushController && this._brushController.unmount() }, n.prototype.dispose = function () { this._brushController && this._brushController.dispose() }, n.prototype._onBrush = function (t) { function e (t, e, i) { const a = e.getAxis(t); const s = a.model; const l = n(t, s, o); const u = l.findRepresentativeAxisProxy(s).getMinMaxSpan(); (u.minValueSpan != null || u.maxValueSpan != null) && (i = rb(0, i.slice(), a.scale.getExtent(), 0, u.minValueSpan, u.maxValueSpan)), l && (r[l.id] = { dataZoomId: l.id, startValue: i[0], endValue: i[1] }) } function n (t, e, n) { let i; return n.eachComponent({ mainType: 'dataZoom', subType: 'select' }, function (n) { const r = n.getAxisModel(t, e.componentIndex); r && (i = n) }), i } const i = t.areas; if (t.isEnd && i.length) { var r = {}; var o = this.ecModel; this._brushController.updateCovers([]); const a = new oV(Cb(this.model), o, { include: ['grid'] }); a.matchOutputRanges(i, o, function (t, n, i) { if (i.type === 'cartesian2d') { const r = t.brushType; r === 'rect' ? (e('x', i, n[0]), e('y', i, n[1])) : e({ lineX: 'x', lineY: 'y' }[r], i, n) } }), bb(o, r), this._dispatchZoomAction(r) } }, n.prototype._dispatchZoomAction = function (t) { const e = []; jV(t, function (t) { e.push(s(t)) }), e.length && this.api.dispatchAction({ type: 'dataZoom', from: this.uid, batch: e }) }, n.getDefaultOption = function (t) { const e = { show: !0, filterMode: 'filter', icon: { zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1', back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26' }, title: t.getLocaleModel().get(['toolbox', 'dataZoom', 'title']), brushStyle: { borderWidth: 0, color: 'rgba(210,219,238,0.2)' } }; return e }, n }(mV)); var $V = { zoom: function () { const t = !this._isZoomActive; this.api.dispatchAction({ type: 'takeGlobalCursor', key: 'dataZoomSelect', dataZoomSelectActive: t }) }, back: function () { this._dispatchZoomAction(Sb(this.ecModel)) } }; mu('dataZoom', function (t) { function e (t, e, n) { const i = t.componentIndex; const a = { type: 'select', $fromToolbox: !0, filterMode: r.get('filterMode', !0) || 'filter', id: qV + e + i }; a[n] = i, o.push(a) } const n = t.getComponent('toolbox', 0); const i = ['feature', 'dataZoom']; if (n && n.get(i) != null) { var r = n.getModel(i); var o = []; const a = Cb(r); const s = Kr(t, a); return jV(s.xAxisModels, function (t) { return e(t, 'xAxis', 'xAxisIndex') }), jV(s.yAxisModels, function (t) { return e(t, 'yAxis', 'yAxisIndex') }), o } }), ff(Ab); var QV = ['transition', 'enterFrom', 'leaveTo']; var JV = QV.concat(['enterAnimation', 'updateAnimation', 'leaveAnimation']); var tF = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e.preventAutoZ = !0, e } return e(n, t), n.prototype.mergeOption = function (e, n) { const i = this.option.elements; this.option.elements = null, t.prototype.mergeOption.call(this, e, n), this.option.elements = i }, n.prototype.optionUpdated = function (t, e) { const n = this.option; const i = (e ? n : t).elements; const r = n.elements = e ? [] : n.elements; const o = []; this._flatten(i, o, null); const a = Or(r, o, 'normalMerge'); const s = this._elOptionsToUpdate = []; y(a, function (t, e) { const n = t.newOption; n && (s.push(n), Lb(t, n), Ob(r, e, n), Nb(r[e], n)) }, this), n.elements = _(r, function (t) { return t && delete t.$action, t != null }) }, n.prototype._flatten = function (t, e, n) { y(t, function (t) { if (t) { n && (t.parentOption = n), e.push(t); const i = t.children; i && i.length && this._flatten(i, e, t), delete t.children } }, this) }, n.prototype.useElOptionsToUpdate = function () { const t = this._elOptionsToUpdate; return this._elOptionsToUpdate = null, t }, n.type = 'graphic', n.defaultOption = { elements: [] }, n }(CA)); var eF = { path: null, compoundPath: null, group: CI, image: QC, text: aD }; var nF = qr(); var iF = (function (t) { function n () { const e = t !== null && t.apply(this, arguments) || this; return e.type = n.type, e } return e(n, t), n.prototype.init = function () { this._elMap = Z() }, n.prototype.render = function (t, e, n) { t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, n) }, n.prototype._updateElements = function (t) { const e = t.useElOptionsToUpdate(); if (e) { const n = this._elMap; const i = this.group; const r = t.get('z'); const o = t.get('zlevel'); y(e, function (e) { const a = Wr(e.id, null); const s = a != null ? n.get(a) : null; const l = Wr(e.parentId, null); const u = l != null ? n.get(l) : i; const h = e.type; const c = e.style; h === 'text' && c && e.hv && e.hv[1] && (c.textVerticalAlign = c.textBaseline = c.verticalAlign = c.align = null); let p = e.textContent; let d = e.textConfig; if (c && Zv(c, h, !!d, !!p)) { const f = jv(c, h, !0); !d && f.textConfig && (d = e.textConfig = f.textConfig), !p && f.textContent && (p = f.textContent) } const g = Fb(e); const y = e.$action || 'merge'; const v = y === 'merge'; const m = y === 'replace'; if (v) { var _ = !s; let x = s; _ ? x = Bb(a, u, e.type, n) : (x && (nF(x).isNew = !1), dm(x)), x && (Jv(x, g, t, { isInit: _ }), Vb(x, e, r, o)) } else if (m) { Eb(s, e, n, t); const w = Bb(a, u, e.type, n); w && (Jv(w, g, t, { isInit: !0 }), Vb(w, e, r, o)) } else y === 'remove' && (tm(s, e), Eb(s, e, n, t)); const b = n.get(a); if (b && p) if (v) { const S = b.getTextContent(); S ? S.attr(p) : b.setTextContent(new aD(p)) } else m && b.setTextContent(new aD(p)); if (b) { const M = e.clipPath; if (M) { const T = M.type; let I = void 0; var _ = !1; if (v) { const C = b.getClipPath(); _ = !C || nF(C).type !== T, I = _ ? zb(T) : C } else m && (_ = !0, I = zb(T)); b.setClipPath(I), Jv(I, M, t, { isInit: _ }), fm(I, M.keyframeAnimation, t) } const D = nF(b); b.setTextConfig(d), D.option = e, Hb(b, t, e), nl({ el: b, componentModel: t, itemName: b.name, itemTooltipOption: e.tooltip }), fm(b, e.keyframeAnimation, t) } }) } }, n.prototype._relocate = function (t, e) { for (var n = t.option.elements, i = this.group, r = this._elMap, o = e.getWidth(), a = e.getHeight(), s = ['x', 'y'], l = 0; l < n.length; l++) { var u = n[l]; var h = Wr(u.id, null); var c = h != null ? r.get(h) : null; if (c && c.isGroup) { var d = c.parent; const f = d === i; const g = nF(c); var y = nF(d); g.width = or(g.option.width, f ? o : y.width) || 0, g.height = or(g.option.height, f ? a : y.height) || 0 } } for (var l = n.length - 1; l >= 0; l--) { var u = n[l]; var h = Wr(u.id, null); var c = h != null ? r.get(h) : null; if (c) { var d = c.parent; var y = nF(d); const v = d === i ? { width: o, height: a } : { width: y.width, height: y.height }; const m = {}; const _ = ou(c, u, v, null, { hv: u.hv, boundingMode: u.bounding }, m); if (!nF(c).isNew && _) { for (var x = u.transition, w = {}, b = 0; b < s.length; b++) { const S = s[b]; const M = m[S]; x && (nm(x) || p(x, S) >= 0) ? w[S] = M : c[S] = M }Is(c, w, t, 0) } else c.attr(m) } } }, n.prototype._clear = function () { const t = this; const e = this._elMap; e.each(function (n) { Eb(n, nF(n).option, e, t._lastGraphicModel) }), this._elMap = Z() }, n.prototype.dispose = function () { this._clear() }, n.type = 'graphic', n }(YL)); ff(Wb); const rF = Math.sin; const oF = Math.cos; const aF = Math.PI; const sF = 2 * Math.PI; const lF = 180 / aF; var uF = (function () { function t () {} return t.prototype.reset = function (t) { this._start = !0, this._d = [], this._str = '', this._p = Math.pow(10, t || 4) }, t.prototype.moveTo = function (t, e) { this._add('M', t, e) }, t.prototype.lineTo = function (t, e) { this._add('L', t, e) }, t.prototype.bezierCurveTo = function (t, e, n, i, r, o) { this._add('C', t, e, n, i, r, o) }, t.prototype.quadraticCurveTo = function (t, e, n, i) { this._add('Q', t, e, n, i) }, t.prototype.arc = function (t, e, n, i, r, o) { this.ellipse(t, e, n, n, 0, i, r, o) }, t.prototype.ellipse = function (t, e, n, i, r, o, a, s) { const l = a - o; const u = !s; const h = Math.abs(l); const c = qn(h - sF) || (u ? l >= sF : -l >= sF); const p = l > 0 ? l % sF : l % sF + sF; let d = !1; d = c ? !0 : qn(h) ? !1 : p >= aF == !!u; const f = t + n * oF(o); const g = e + i * rF(o); this._start && this._add('M', f, g); const y = Math.round(r * lF); if (c) { const v = 1 / this._p; const m = (u ? 1 : -1) * (sF - v); this._add('A', n, i, y, 1, +u, t + n * oF(o + m), e + i * rF(o + m)), v > 0.01 && this._add('A', n, i, y, 0, +u, f, g) } else { const _ = t + n * oF(a); const x = e + i * rF(a); this._add('A', n, i, y, +d, +u, _, x) } }, t.prototype.rect = function (t, e, n, i) { this._add('M', t, e), this._add('l', n, 0), this._add('l', 0, i), this._add('l', -n, 0), this._add('Z') }, t.prototype.closePath = function () { this._d.length > 0 && this._add('Z') }, t.prototype._add = function (t) { for (var e = [], n = this._p, i = 1; i < arguments.length; i++) { const r = arguments[i]; if (isNaN(r)) return void (this._invalid = !0); e.push(Math.round(r * n) / n) } this._d.push(t + e.join(' ')), this._start = t === 'Z' }, t.prototype.generateStr = function () { this._str = this._invalid ? '' : this._d.join(''), this._d = [] }, t.prototype.getStr = function () { return this._str }, t }()); var hF = 'none'; var cF = Math.round; var pF = ['lineCap', 'miterLimit', 'lineJoin']; var dF = v(pF, function (t) { return 'stroke-' + t.toLowerCase() }); var fF = 'http://www.w3.org/2000/svg'; var gF = 'http://www.w3.org/1999/xlink'; var yF = 'http://www.w3.org/2000/xmlns/'; var vF = 'http://www.w3.org/XML/1998/namespace'; var mF = { cubicIn: '0.32,0,0.67,0', cubicOut: '0.33,1,0.68,1', cubicInOut: '0.65,0,0.35,1', quadraticIn: '0.11,0,0.5,0', quadraticOut: '0.5,1,0.89,1', quadraticInOut: '0.45,0,0.55,1', quarticIn: '0.5,0,0.75,0', quarticOut: '0.25,1,0.5,1', quarticInOut: '0.76,0,0.24,1', quinticIn: '0.64,0,0.78,0', quinticOut: '0.22,1,0.36,1', quinticInOut: '0.83,0,0.17,1', sinusoidalIn: '0.12,0,0.39,0', sinusoidalOut: '0.61,1,0.88,1', sinusoidalInOut: '0.37,0,0.63,1', exponentialIn: '0.7,0,0.84,0', exponentialOut: '0.16,1,0.3,1', exponentialInOut: '0.87,0,0.13,1', circularIn: '0.55,0,1,0.45', circularOut: '0,0.55,0.45,1', circularInOut: '0.85,0,0.15,1' }; var _F = 'transform-origin'; var xF = { fill: 'fill', opacity: 'opacity', lineWidth: 'stroke-width', lineDashOffset: 'stroke-dashoffset' }; var wF = Math.round; var bF = { circle: [fS(['cx', 'cy', 'r'])], polyline: [pS, dS], polygon: [pS, dS] }; var SF = 58; var MF = 120; var TF = Zb('', ''); let IF = 0; const CF = (function () {
    function t (t, e, n) { if (this.type = 'svg', this.refreshHover = WS('refreshHover'), this.configLayer = WS('configLayer'), this.storage = e, this._opts = n = h({}, n), this.root = t, this._id = 'zr' + IF++, this._oldVNode = Jb(n.width, n.height), t && !n.ssr) { const i = this._viewport = document.createElement('div'); i.style.cssText = 'position:relative;overflow:hidden'; const r = this._svgDom = this._oldVNode.elm = Ub('svg'); ES(null, this._oldVNode), i.appendChild(r), t.appendChild(i) } this.resize(n.width, n.height) } return t.prototype.getType = function () { return this.type }, t.prototype.getViewportRoot = function () { return this._viewport }, t.prototype.getViewportRootOffset = function () { const t = this.getViewportRoot(); return t ? { offsetLeft: t.offsetLeft || 0, offsetTop: t.offsetTop || 0 } : void 0 }, t.prototype.getSvgDom = function () { return this._svgDom }, t.prototype.refresh = function () { if (this.root) { const t = this.renderToVNode({ willUpdate: !0 }); t.attrs.style = 'position:absolute;left:0;top:0;user-select:none', HS(this._oldVNode, t), this._oldVNode = t } }, t.prototype.renderOneToVNode = function (t) { return _S(t, Qb(this._id)) }, t.prototype.renderToVNode = function (t) { t = t || {}; const e = this.storage.getDisplayList(!0); const n = this._width; const i = this._height; const r = Qb(this._id); r.animation = t.animation, r.willUpdate = t.willUpdate, r.compress = t.compress; const o = []; const a = this._bgVNode = GS(n, i, this._backgroundColor, r); a && o.push(a); const s = t.compress ? null : this._mainVNode = Zb('g', 'main', {}, []); this._paintList(e, r, s ? s.children : o), s && o.push(s); const l = v(w(r.defs), function (t) { return r.defs[t] }); if (l.length && o.push(Zb('defs', 'defs', {}, l)), t.animation) { const u = $b(r.cssNodes, r.cssAnims, { newline: !0 }); if (u) { const h = Zb('style', 'stl', {}, [], u); o.push(h) } } return Jb(n, i, o, t.useViewBox) }, t.prototype.renderToString = function (t) { return t = t || {}, Kb(this.renderToVNode({ animation: E(t.cssAnimation, !0), willUpdate: !1, compress: !0, useViewBox: E(t.useViewBox, !0) }), { newline: !0 }) }, t.prototype.setBackgroundColor = function (t) {
      this._backgroundColor = t
    }, t.prototype.getSvgRoot = function () { return this._mainVNode && this._mainVNode.elm }, t.prototype._paintList = function (t, e, n) { for (var i, r, o = t.length, a = [], s = 0, l = 0, u = 0; o > u; u++) { const h = t[u]; if (!h.invisible) { const c = h.__clipPaths; const p = c && c.length || 0; const d = r && r.length || 0; let f = void 0; for (f = Math.max(p - 1, d - 1); f >= 0 && (!c || !r || c[f] !== r[f]); f--);for (let g = d - 1; g > f; g--)s--, i = a[s - 1]; for (let y = f + 1; p > y; y++) { const v = {}; SS(c[y], v, e); const m = Zb('g', 'clip-g-' + l++, v, []); (i ? i.children : n).push(m), a[s++] = m, i = m }r = c; const _ = _S(h, e); _ && (i ? i.children : n).push(_) } } }, t.prototype.resize = function (t, e) { const n = this._opts; const i = this.root; const r = this._viewport; if (t != null && (n.width = t), e != null && (n.height = e), i && r && (r.style.display = 'none', t = Wc(i, 0, n), e = Wc(i, 1, n), r.style.display = ''), this._width !== t || this._height !== e) { if (this._width = t, this._height = e, r) { const o = r.style; o.width = t + 'px', o.height = e + 'px' } if (ri(this._backgroundColor)) this.refresh(); else { const a = this._svgDom; a && (a.setAttribute('width', t), a.setAttribute('height', e)); const s = this._bgVNode && this._bgVNode.elm; s && (s.setAttribute('width', t), s.setAttribute('height', e)) } } }, t.prototype.getWidth = function () { return this._width }, t.prototype.getHeight = function () { return this._height }, t.prototype.dispose = function () { this.root && (this.root.innerHTML = ''), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null }, t.prototype.clear = function () { this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null }, t.prototype.toDataURL = function (t) { let e = this.renderToString(); const n = 'data:image/svg+xml;'; return t ? (e = BT(e), e && n + 'base64,' + e) : n + 'charset=UTF-8,' + encodeURIComponent(e) }, t
  }()); nr('svg', CF), t.version = ZP, t.dependencies = jP, t.PRIORITY = cO, t.init = Mp, t.connect = Tp, t.disConnect = Ip, t.disconnect = eR, t.dispose = Cp, t.getInstanceByDom = Dp, t.getInstanceById = kp, t.registerTheme = Ap, t.registerPreprocessor = Lp, t.registerProcessor = Pp, t.registerPostInit = Op, t.registerPostUpdate = Rp, t.registerUpdateLifecycle = Np, t.registerAction = zp, t.registerCoordinateSystem = Bp, t.getCoordinateSystemDimensions = Ep, t.registerLayout = Vp, t.registerVisual = Fp, t.registerLoading = Wp, t.setCanvasCreator = Gp, t.registerMap = Xp, t.getMap = Yp, t.registerTransform = iR, t.dataTool = cR, t.registerLocale = xl, t.zrender = PI, t.matrix = HM, t.vector = IM, t.zrUtil = wM, t.color = OT, t.helper = tN, t.number = uN, t.time = hN, t.graphic = cN, t.format = pN, t.util = dN, t.List = TR, t.ComponentModel = CA, t.ComponentView = YL, t.SeriesModel = XL, t.ChartView = jL, t.extendComponentModel = Ff, t.extendComponentView = Hf, t.extendSeriesModel = Wf, t.extendChartView = Gf, t.throttle = hc, t.use = ff, t.setPlatformAPI = r, t.parseGeoJSON = Sf, t.parseGeoJson = Sf, t.env = ZS, t.Model = Jk, t.Axis = yN, t.innerDrawElementOnCanvas = up
}))
